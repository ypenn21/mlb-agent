var EM = Object.defineProperty, kM = Object.defineProperties;
var SM = Object.getOwnPropertyDescriptors;
var Ac = Object.getOwnPropertySymbols;
var py = Object.prototype.hasOwnProperty,
    gy = Object.prototype.propertyIsEnumerable;
var fy = (n, t, e) => t in n ?
    EM(n, t, {enumerable: !0, configurable: !0, writable: !0, value: e}) :
    n[t] = e,
    y = (n, t) => {
      for (var e in t ||= {}) py.call(t, e) && fy(n, e, t[e]);
      if (Ac)
        for (var e of Ac(t)) gy.call(t, e) && fy(n, e, t[e]);
      return n
    }, ae = (n, t) => kM(n, SM(t));
var Xh = (n, t) => {
  var e = {};
  for (var i in n) py.call(n, i) && t.indexOf(i) < 0 && (e[i] = n[i]);
  if (n != null && Ac)
    for (var i of Ac(n)) t.indexOf(i) < 0 && gy.call(n, i) && (e[i] = n[i]);
  return e
};
var Tt = (n, t, e) => new Promise((i, r) => {
  var o = l => {
    try {
      a(e.next(l))
    } catch (c) {
      r(c)
    }
  }, s = l => {
    try {
      a(e.throw(l))
    } catch (c) {
      r(c)
    }
  }, a = l => l.done ? i(l.value) : Promise.resolve(l.value).then(o, s);
  a((e = e.apply(n, t)).next())
});
function by(n, t) {
  return Object.is(n, t)
}
var pt = null, Oc = !1, tf = 1, $t = Symbol('SIGNAL');
function Me(n) {
  let t = pt;
  return pt = n, t
}
function vy() {
  return pt
}
var Ko = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: !1,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: !1,
  consumerIsAlwaysLive: !1,
  kind: 'unknown',
  producerMustRecompute: () => !1,
  producerRecomputeValue: () => {},
  consumerMarkedDirty: () => {},
  consumerOnSignalRead: () => {}
};
function Pc(n) {
  if (Oc) throw new Error('');
  if (pt === null) return;
  pt.consumerOnSignalRead(n);
  let t = pt.nextProducerIndex++;
  if (jc(pt),
      t < pt.producerNode.length && pt.producerNode[t] !== n && Ia(pt)) {
    let e = pt.producerNode[t];
    Vc(e, pt.producerIndexOfThis[t])
  }
  pt.producerNode[t] !== n &&
      (pt.producerNode[t] = n,
       pt.producerIndexOfThis[t] = Ia(pt) ? Cy(n, pt, t) : 0),
      pt.producerLastReadVersion[t] = n.version
}
function IM() {
  tf++
}
function yy(n) {
  if (!(Ia(n) && !n.dirty) && !(!n.dirty && n.lastCleanEpoch === tf)) {
    if (!n.producerMustRecompute(n) && !Lc(n)) {
      _y(n);
      return
    }
    n.producerRecomputeValue(n), _y(n)
  }
}
function wy(n) {
  if (n.liveConsumerNode === void 0) return;
  let t = Oc;
  Oc = !0;
  try {
    for (let e of n.liveConsumerNode) e.dirty || MM(e)
  } finally {
    Oc = t
  }
}
function xy() {
  return pt?.consumerAllowSignalWrites !== !1
}
function MM(n) {
  n.dirty = !0, wy(n), n.consumerMarkedDirty?.(n)
}
function _y(n) {
  n.dirty = !1, n.lastCleanEpoch = tf
}
function Ma(n) {
  return n && (n.nextProducerIndex = 0), Me(n)
}
function Fc(n, t) {
  if (Me(t),
      !(!n || n.producerNode === void 0 || n.producerIndexOfThis === void 0 ||
        n.producerLastReadVersion === void 0)) {
    if (Ia(n))
      for (let e = n.nextProducerIndex; e < n.producerNode.length; e++)
        Vc(n.producerNode[e], n.producerIndexOfThis[e]);
    for (; n.producerNode.length > n.nextProducerIndex;)
      n.producerNode.pop(), n.producerLastReadVersion.pop(),
          n.producerIndexOfThis.pop()
  }
}
function Lc(n) {
  jc(n);
  for (let t = 0; t < n.producerNode.length; t++) {
    let e = n.producerNode[t], i = n.producerLastReadVersion[t];
    if (i !== e.version || (yy(e), i !== e.version)) return !0
  }
  return !1
}
function Ta(n) {
  if (jc(n), Ia(n))
    for (let t = 0; t < n.producerNode.length; t++)
      Vc(n.producerNode[t], n.producerIndexOfThis[t]);
  n.producerNode.length = n.producerLastReadVersion.length =
      n.producerIndexOfThis.length = 0,
  n.liveConsumerNode &&
      (n.liveConsumerNode.length = n.liveConsumerIndexOfThis.length = 0)
}
function Cy(n, t, e) {
  if (Dy(n), n.liveConsumerNode.length === 0 && Ey(n))
    for (let i = 0; i < n.producerNode.length; i++)
      n.producerIndexOfThis[i] = Cy(n.producerNode[i], n, i);
  return n.liveConsumerIndexOfThis.push(e), n.liveConsumerNode.push(t) - 1
}
function Vc(n, t) {
  if (Dy(n), n.liveConsumerNode.length === 1 && Ey(n))
    for (let i = 0; i < n.producerNode.length; i++)
      Vc(n.producerNode[i], n.producerIndexOfThis[i]);
  let e = n.liveConsumerNode.length - 1;
  if (n.liveConsumerNode[t] = n.liveConsumerNode[e],
      n.liveConsumerIndexOfThis[t] = n.liveConsumerIndexOfThis[e],
      n.liveConsumerNode.length--, n.liveConsumerIndexOfThis.length--,
      t < n.liveConsumerNode.length) {
    let i = n.liveConsumerIndexOfThis[t], r = n.liveConsumerNode[t];
    jc(r), r.producerIndexOfThis[i] = t
  }
}
function Ia(n) {
  return n.consumerIsAlwaysLive || (n?.liveConsumerNode?.length ?? 0) > 0
}
function jc(n) {
  n.producerNode ??= [], n.producerIndexOfThis ??= [],
  n.producerLastReadVersion ??= []
}
function Dy(n) {
  n.liveConsumerNode ??= [], n.liveConsumerIndexOfThis ??= []
}
function Ey(n) {
  return n.producerNode !== void 0
}
function nf(n, t) {
  let e = Object.create(TM);
  e.computation = n, t !== void 0 && (e.equal = t);
  let i = () => {
    if (yy(e), Pc(e), e.value === Nc) throw e.error;
    return e.value
  };
  return i[$t] = e, i
}
var Jh = Symbol('UNSET'), ef = Symbol('COMPUTING'), Nc = Symbol('ERRORED'),
    TM = ae(y({}, Ko), {
      value: Jh,
      dirty: !0,
      error: null,
      equal: by,
      kind: 'computed',
      producerMustRecompute(n) {
        return n.value === Jh || n.value === ef
      },
      producerRecomputeValue(n) {
        if (n.value === ef) throw new Error('Detected cycle in computations.');
        let t = n.value;
        n.value = ef;
        let e = Ma(n), i, r = !1;
        try {
          i = n.computation(), Me(null),
          r = t !== Jh && t !== Nc && i !== Nc && n.equal(t, i)
        } catch (o) {
          i = Nc, n.error = o
        } finally {
          Fc(n, e)
        }
        if (r) {
          n.value = t;
          return
        }
        n.value = i, n.version++
      }
    });
function RM() {
  throw new Error
}
var ky = RM;
function Sy(n) {
  ky(n)
}
function Iy(n) {
  ky = n
}
var AM = null;
function My(n, t) {
  let e = Object.create(rf);
  e.value = n, t !== void 0 && (e.equal = t);
  let i = () => (Pc(e), e.value);
  return i[$t] = e, i
}
function Bc(n, t) {
  xy() || Sy(n), n.equal(n.value, t) || (n.value = t, OM(n))
}
function Ty(n, t) {
  xy() || Sy(n), Bc(n, t(n.value))
}
var rf = ae(y({}, Ko), {equal: by, value: void 0, kind: 'signal'});
function OM(n) {
  n.version++, IM(), wy(n), AM?.()
}
function Ry(n) {
  let t = Me(null);
  try {
    return n()
  } finally {
    Me(t)
  }
}
var of ;
function Ra() {
  return of
}
function Mi(n) {
  let t = of;
  return of = n, t
}
var sf = Symbol('NotFound');
function le(n) {
  return typeof n == 'function'
}
function Xo(n) {
  let e = n(i => {Error.call(i), i.stack = new Error().stack});
  return e.prototype = Object.create(Error.prototype),
         e.prototype.constructor = e, e
}
var zc = Xo(n => function(e) {
  n(this),
      this.message = e ? `${e.length} errors occurred during unsubscription:
${e.map((i, r) => `${r + 1}) ${i.toString()}`).join(`
  `)}` :
                         '',
      this.name = 'UnsubscriptionError', this.errors = e
});
function eo(n, t) {
  if (n) {
    let e = n.indexOf(t);
    0 <= e && n.splice(e, 1)
  }
}
var ge = class n {
  constructor(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null,
    this._finalizers = null
  }
  unsubscribe() {
    let t;
    if (!this.closed) {
      this.closed = !0;
      let {_parentage: e} = this;
      if (e)
        if (this._parentage = null, Array.isArray(e))
          for (let o of e) o.remove(this);
        else
          e.remove(this);
      let {initialTeardown: i} = this;
      if (le(i)) try {
          i()
        } catch (o) {
          t = o instanceof zc ? o.errors : [o]
        }
      let {_finalizers: r} = this;
      if (r) {
        this._finalizers = null;
        for (let o of r) try {
            Ay(o)
          } catch (s) {
            t = t ?? [], s instanceof zc ? t = [...t, ...s.errors] : t.push(s)
          }
      }
      if (t) throw new zc(t)
    }
  }
  add(t) {
    var e;
    if (t && t !== this)
      if (this.closed)
        Ay(t);
      else {
        if (t instanceof n) {
          if (t.closed || t._hasParent(this)) return;
          t._addParent(this)
        }
        (this._finalizers =
             (e = this._finalizers) !== null && e !== void 0 ? e : [])
            .push(t)
      }
  }
  _hasParent(t) {
    let {_parentage: e} = this;
    return e === t || Array.isArray(e) && e.includes(t)
  }
  _addParent(t) {
    let {_parentage: e} = this;
    this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t
  }
  _removeParent(t) {
    let {_parentage: e} = this;
    e === t ? this._parentage = null : Array.isArray(e) && eo(e, t)
  }
  remove(t) {
    let {_finalizers: e} = this;
    e && eo(e, t), t instanceof n && t._removeParent(this)
  }
};
ge.EMPTY = (() => {
  let n = new ge;
  return n.closed = !0, n
})();
var af = ge.EMPTY;
function Hc(n) {
  return n instanceof ge ||
      n && 'closed' in n && le(n.remove) && le(n.add) && le(n.unsubscribe)
}
function Ay(n) {
  le(n) ? n() : n.unsubscribe()
}
var Sn = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
};
var Jo = {
  setTimeout(n, t, ...e) {
    let {delegate: i} = Jo;
    return i?.setTimeout ? i.setTimeout(n, t, ...e) : setTimeout(n, t, ...e)
  },
  clearTimeout(n) {
    let {delegate: t} = Jo;
    return (t?.clearTimeout || clearTimeout)(n)
  },
  delegate: void 0
};
function Uc(n) {
  Jo.setTimeout(() => {
    let {onUnhandledError: t} = Sn;
    if (t)
      t(n);
    else
      throw n
  })
}
function Aa() {}
var Oy = lf('C', void 0, void 0);
function Ny(n) {
  return lf('E', void 0, n)
}
function Py(n) {
  return lf('N', n, void 0)
}
function lf(n, t, e) {
  return {
    kind: n, value: t, error: e
  }
}
var to = null;
function es(n) {
  if (Sn.useDeprecatedSynchronousErrorHandling) {
    let t = !to;
    if (t && (to = {errorThrown: !1, error: null}), n(), t) {
      let {errorThrown: e, error: i} = to;
      if (to = null, e) throw i
    }
  } else
    n()
}
function Fy(n) {
  Sn.useDeprecatedSynchronousErrorHandling && to &&
      (to.errorThrown = !0, to.error = n)
}
var Ti = class extends ge {
  constructor(t) {
    super(),
        this.isStopped = !1,
        t ? (this.destination = t, Hc(t) && t.add(this)) : this.destination = FM
  }
  static create(t, e, i) {
    return new Ri(t, e, i)
  }
  next(t) {
    this.isStopped ? df(Py(t), this) : this._next(t)
  }
  error(t) {
    this.isStopped ? df(Ny(t), this) : (this.isStopped = !0, this._error(t))
  }
  complete() {
    this.isStopped ? df(Oy, this) : (this.isStopped = !0, this._complete())
  }
  unsubscribe() {
    this.closed ||
        (this.isStopped = !0, super.unsubscribe(), this.destination = null)
  }
  _next(t) {
    this.destination.next(t)
  }
  _error(t) {
    try {
      this.destination.error(t)
    } finally {
      this.unsubscribe()
    }
  }
  _complete() {
    try {
      this.destination.complete()
    } finally {
      this.unsubscribe()
    }
  }
}
, NM = Function.prototype.bind;
function cf(n, t) {
  return NM.call(n, t)
}
var uf = class {
  constructor(t) {
    this.partialObserver = t
  }
  next(t) {
    let {partialObserver: e} = this;
    if (e.next) try {
        e.next(t)
      } catch (i) {
        $c(i)
      }
  }
  error(t) {
    let {partialObserver: e} = this;
    if (e.error) try {
        e.error(t)
      } catch (i) {
        $c(i)
      }
    else
      $c(t)
  }
  complete() {
    let {partialObserver: t} = this;
    if (t.complete) try {
        t.complete()
      } catch (e) {
        $c(e)
      }
  }
}
, Ri = class extends Ti {
  constructor(t, e, i) {
    super();
    let r;
    if (le(t) || !t)
      r = {next: t ?? void 0, error: e ?? void 0, complete: i ?? void 0};
    else {
      let o;
      this && Sn.useDeprecatedNextContext ?
          (o = Object.create(t), o.unsubscribe = () => this.unsubscribe(), r = {
            next: t.next && cf(t.next, o),
            error: t.error && cf(t.error, o),
            complete: t.complete && cf(t.complete, o)
          }) :
          r = t
    }
    this.destination = new uf(r)
  }
};
function $c(n) {
  Sn.useDeprecatedSynchronousErrorHandling ? Fy(n) : Uc(n)
}
function PM(n) {
  throw n
}
function df(n, t) {
  let {onStoppedNotification: e} = Sn;
  e && Jo.setTimeout(() => e(n, t))
}
var FM = {closed: !0, next: Aa, error: PM, complete: Aa};
var ts = typeof Symbol == 'function' && Symbol.observable || '@@observable';
function Vt(n) {
  return n
}
function mf(...n) {
  return hf(n)
}
function hf(n) {
  return n.length === 0 ? Vt :
      n.length === 1    ? n[0] :
                          function(e) {
                         return n.reduce((i, r) => r(i), e)
                       }
}
var ie = (() => {
  class n {
    constructor(e) {
      e && (this._subscribe = e)
    }
    lift(e) {
      let i = new n;
      return i.source = this, i.operator = e, i
    }
    subscribe(e, i, r) {
      let o = VM(e) ? e : new Ri(e, i, r);
      return es(() => {
               let {operator: s, source: a} = this;
               o.add(
                   s     ? s.call(o, a) :
                       a ? this._subscribe(o) :
                           this._trySubscribe(o))
             }),
             o
    }
    _trySubscribe(e) {
      try {
        return this._subscribe(e)
      } catch (i) {
        e.error(i)
      }
    }
    forEach(e, i) {
      return i = Ly(i), new i((r, o) => {
               let s = new Ri({
                 next: a => {
                   try {
                     e(a)
                   } catch (l) {
                     o(l), s.unsubscribe()
                   }
                 },
                 error: o,
                 complete: r
               });
               this.subscribe(s)
             })
    }
    _subscribe(e) {
      var i;
      return (i = this.source) === null || i === void 0 ? void 0 :
                                                          i.subscribe(e)
    }
    [ts]() {
      return this
    }
    pipe(...e) {
      return hf(e)(this)
    }
    toPromise(e) {
      return e = Ly(e), new e((i, r) => {
               let o;
               this.subscribe(s => o = s, s => r(s), () => i(o))
             })
    }
  } return n.create = t => new n(t),
  n
})();
function Ly(n) {
  var t;
  return (t = n ?? Sn.Promise) !== null && t !== void 0 ? t : Promise
}
function LM(n) {
  return n && le(n.next) && le(n.error) && le(n.complete)
}
function VM(n) {
  return n && n instanceof Ti || LM(n) && Hc(n)
}
function ff(n) {
  return le(n?.lift)
}
function _e(n) {
  return t => {
    if (ff(t))
      return t.lift(function(e) {
        try {
          return n(e, this)
        } catch (i) {
          this.error(i)
        }
      });
    throw new TypeError('Unable to lift unknown Observable type')
  }
}
function fe(n, t, e, i, r) {
  return new pf(n, t, e, i, r)
}
var pf = class extends Ti {
  constructor(t, e, i, r, o, s) {
    super(t), this.onFinalize = o, this.shouldUnsubscribe = s,
              this._next = e ? function(a) {
                try {
                  e(a)
                } catch (l) {
                  t.error(l)
                }
              } : super._next, this._error = r ? function(a) {
                try {
                  r(a)
                } catch (l) {
                  t.error(l)
                } finally {
                  this.unsubscribe()
                }
              } : super._error, this._complete = i ? function() {
                try {
                  i()
                } catch (a) {
                  t.error(a)
                } finally {
                  this.unsubscribe()
                }
              } : super._complete
  }
  unsubscribe() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      let {closed: e} = this;
      super.unsubscribe(),
          !e && ((t = this.onFinalize) === null || t === void 0 || t.call(this))
    }
  }
};
function ns() {
  return _e((n, t) => {
    let e = null;
    n._refCount++;
    let i = fe(t, void 0, void 0, void 0, () => {
      if (!n || n._refCount <= 0 || 0 < --n._refCount) {
        e = null;
        return
      }
      let r = n._connection, o = e;
      e = null, r && (!o || r === o) && r.unsubscribe(), t.unsubscribe()
    });
    n.subscribe(i), i.closed || (e = n.connect())
  })
}
var sr = class extends ie {
  constructor(t, e) {
    super(), this.source = t, this.subjectFactory = e, this._subject = null,
             this._refCount = 0, this._connection = null,
             ff(t) && (this.lift = t.lift)
  }
  _subscribe(t) {
    return this.getSubject().subscribe(t)
  }
  getSubject() {
    let t = this._subject;
    return (!t || t.isStopped) && (this._subject = this.subjectFactory()),
           this._subject
  }
  _teardown() {
    this._refCount = 0;
    let {_connection: t} = this;
    this._subject = this._connection = null, t?.unsubscribe()
  }
  connect() {
    let t = this._connection;
    if (!t) {
      t = this._connection = new ge;
      let e = this.getSubject();
      t.add(this.source.subscribe(
          fe(e, void 0, () => {this._teardown(), e.complete()},
             i => {this._teardown(), e.error(i)}, () => this._teardown()))),
          t.closed && (this._connection = null, t = ge.EMPTY)
    }
    return t
  }
  refCount() {
    return ns()(this)
  }
};
var Vy = Xo(n => function() {
  n(this), this.name = 'ObjectUnsubscribedError',
           this.message = 'object unsubscribed'
});
var I=(()=>{class n extends ie{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){let i=new is(this,this);return i.operator=e,i}_throwIfClosed(){if(this.closed)throw new Vy}next(e){es(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let i of this.currentObservers)i.next(e)}})}error(e){es(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;let{observers:i}=this;for(;i.length;)i.shift().error(e)}})}complete(){es(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return((e=this.observers)===null||e===void 0?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){let{hasError:i,isStopped:r,observers:o}=this;return i||r?af:(this.currentObservers=null,o.push(e),new ge(()=>{this.currentObservers=null,eo(o,e)}))}_checkFinalizedStatuses(e){let{hasError:i,thrownError:r,isStopped:o}=this;i?e.error(r):o&&e.complete()}asObservable(){let e=new ie;return e.source=this,e}}return n.create=(t,e)=>new is(t,e),n})(),is=class extends I{
  constructor(t, e) {
    super(), this.destination = t, this.source = e
  }
  next(t) {
    var e, i;
    (i = (e = this.destination) === null || e === void 0 ? void 0 : e.next) ===
            null ||
        i === void 0 || i.call(e, t)
  }
  error(t) {
    var e, i;
    (i = (e = this.destination) === null || e === void 0 ? void 0 : e.error) ===
            null ||
        i === void 0 || i.call(e, t)
  }
  complete() {
    var t, e;
    (e = (t = this.destination) === null || t === void 0 ?
         void 0 :
         t.complete) === null ||
        e === void 0 || e.call(t)
  }
  _subscribe(t) {
    var e, i;
    return (i = (e = this.source) === null || e === void 0 ?
                void 0 :
                e.subscribe(t)) !== null &&
            i !== void 0 ?
        i :
        af
  }
};
var Le = class extends I {
  constructor(t) {
    super(), this._value = t
  }
  get value() {
    return this.getValue()
  }
  _subscribe(t) {
    let e = super._subscribe(t);
    return !e.closed && t.next(this._value), e
  }
  getValue() {
    let {hasError: t, thrownError: e, _value: i} = this;
    if (t) throw e;
    return this._throwIfClosed(), i
  }
  next(t) {
    super.next(this._value = t)
  }
};
var Oa = {
  now() {
    return (Oa.delegate || Date).now()
  },
  delegate: void 0
};
var In = class extends I {
  constructor(t = 1 / 0, e = 1 / 0, i = Oa) {
    super(),
        this._bufferSize = t, this._windowTime = e, this._timestampProvider = i,
        this._buffer = [], this._infiniteTimeWindow = !0,
        this._infiniteTimeWindow = e === 1 / 0,
        this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, e)
  }
  next(t) {
    let {
      isStopped: e,
      _buffer: i,
      _infiniteTimeWindow: r,
      _timestampProvider: o,
      _windowTime: s
    } = this;
    e || (i.push(t), !r && i.push(o.now() + s)), this._trimBuffer(),
        super.next(t)
  }
  _subscribe(t) {
    this._throwIfClosed(), this._trimBuffer();
    let e = this._innerSubscribe(t),
        {_infiniteTimeWindow: i, _buffer: r} = this, o = r.slice();
    for (let s = 0; s < o.length && !t.closed; s += i ? 1 : 2) t.next(o[s]);
    return this._checkFinalizedStatuses(t), e
  }
  _trimBuffer() {
    let {
      _bufferSize: t,
      _timestampProvider: e,
      _buffer: i,
      _infiniteTimeWindow: r
    } = this,
   o = (r ? 1 : 2) * t;
    if (t < 1 / 0 && o < i.length && i.splice(0, i.length - o), !r) {
      let s = e.now(), a = 0;
      for (let l = 1; l < i.length && i[l] <= s; l += 2) a = l;
      a && i.splice(0, a + 1)
    }
  }
};
var Wc = class extends ge {
  constructor(t, e) {
    super()
  }
  schedule(t, e = 0) {
    return this
  }
};
var Na = {
  setInterval(n, t, ...e) {
    let {delegate: i} = Na;
    return i?.setInterval ? i.setInterval(n, t, ...e) : setInterval(n, t, ...e)
  },
  clearInterval(n) {
    let {delegate: t} = Na;
    return (t?.clearInterval || clearInterval)(n)
  },
  delegate: void 0
};
var qc = class extends Wc {
  constructor(t, e) {
    super(t, e), this.scheduler = t, this.work = e, this.pending = !1
  }
  schedule(t, e = 0) {
    var i;
    if (this.closed) return this;
    this.state = t;
    let r = this.id, o = this.scheduler;
    return r != null && (this.id = this.recycleAsyncId(o, r, e)),
           this.pending = !0, this.delay = e,
           this.id = (i = this.id) !== null && i !== void 0 ?
               i :
               this.requestAsyncId(o, this.id, e),
           this
  }
  requestAsyncId(t, e, i = 0) {
    return Na.setInterval(t.flush.bind(t, this), i)
  }
  recycleAsyncId(t, e, i = 0) {
    if (i != null && this.delay === i && this.pending === !1) return e;
    e != null && Na.clearInterval(e)
  }
  execute(t, e) {
    if (this.closed) return new Error('executing a cancelled action');
    this.pending = !1;
    let i = this._execute(t, e);
    if (i) return i;
    this.pending === !1 && this.id != null &&
        (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
  }
  _execute(t, e) {
    let i = !1, r;
    try {
      this.work(t)
    } catch (o) {
      i = !0, r = o || new Error('Scheduled action threw falsy error')
    }
    if (i) return this.unsubscribe(), r
  }
  unsubscribe() {
    if (!this.closed) {
      let {id: t, scheduler: e} = this, {actions: i} = e;
      this.work = this.state = this.scheduler = null, this.pending = !1,
      eo(i, this), t != null && (this.id = this.recycleAsyncId(e, t, null)),
      this.delay = null, super.unsubscribe()
    }
  }
};
var rs = class n {
  constructor(t, e = n.now) {
    this.schedulerActionCtor = t, this.now = e
  }
  schedule(t, e = 0, i) {
    return new this.schedulerActionCtor(this, t).schedule(i, e)
  }
};
rs.now = Oa.now;
var Gc = class extends rs {
  constructor(t, e = rs.now) {
    super(t, e), this.actions = [], this._active = !1
  }
  flush(t) {
    let {actions: e} = this;
    if (this._active) {
      e.push(t);
      return
    }
    let i;
    this._active = !0;
    do
      if (i = t.execute(t.state, t.delay)) break;
    while (t = e.shift());
    if (this._active = !1, i) {
      for (; t = e.shift();) t.unsubscribe();
      throw i
    }
  }
};
var Pa = new Gc(qc), jy = Pa;
var mt = new ie(n => n.complete());
function Qc(n) {
  return n && le(n.schedule)
}
function gf(n) {
  return n[n.length - 1]
}
function Yc(n) {
  return le(gf(n)) ? n.pop() : void 0
}
function Kn(n) {
  return Qc(gf(n)) ? n.pop() : void 0
}
function By(n, t) {
  return typeof gf(n) == 'number' ? n.pop() : t
}
function Hy(n, t, e, i) {
  function r(o) {
    return o instanceof e ? o : new e(function(s) {
      s(o)
    })
  }
  return new (e || (e = Promise))(function(o, s) {
    function a(d) {
      try {
        c(i.next(d))
      } catch (m) {
        s(m)
      }
    }
    function l(d) {
      try {
        c(i.throw(d))
      } catch (m) {
        s(m)
      }
    }
    function c(d) {
      d.done ? o(d.value) : r(d.value).then(a, l)
    }
    c((i = i.apply(n, t || [])).next())
  })
}
function zy(n) {
  var t = typeof Symbol == 'function' && Symbol.iterator, e = t && n[t], i = 0;
  if (e) return e.call(n);
  if (n && typeof n.length == 'number')
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), {
          value: n && n[i++], done: !n
        }
      }
    };
  throw new TypeError(
      t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
}
function no(n) {
  return this instanceof no ? (this.v = n, this) : new no(n)
}
function Uy(n, t, e) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var i = e.apply(n, t || []), r, o = [];
  return r = Object.create(
             (typeof AsyncIterator == 'function' ? AsyncIterator : Object)
                 .prototype),
         a('next'), a('throw'), a('return', s),
         r[Symbol.asyncIterator] = function() {
           return this
         }, r;
  function s(h) {
    return function(_) {
      return Promise.resolve(_).then(h, m)
    }
  }
  function a(h, _) {
    i[h] && (r[h] = function(v) {
      return new Promise(function(k, F) {
        o.push([h, v, k, F]) > 1 || l(h, v)
      })
    }, _ && (r[h] = _(r[h])))
  }
  function l(h, _) {
    try {
      c(i[h](_))
    } catch (v) {
      p(o[0][3], v)
    }
  }
  function c(h) {
    h.value instanceof no ? Promise.resolve(h.value.v).then(d, m) :
                            p(o[0][2], h)
  }
  function d(h) {
    l('next', h)
  }
  function m(h) {
    l('throw', h)
  }
  function p(h, _) {
    h(_), o.shift(), o.length && l(o[0][0], o[0][1])
  }
}
function $y(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var t = n[Symbol.asyncIterator], e;
  return t ? t.call(n) :
             (n = typeof zy == 'function' ? zy(n) : n[Symbol.iterator](),
              e = {}, i('next'), i('throw'), i('return'),
              e[Symbol.asyncIterator] = function() {
                return this
              }, e);
  function i(o) {
    e[o] = n[o] && function(s) {
      return new Promise(function(a, l) {
        s = n[o](s), r(a, l, s.done, s.value)
      })
    }
  }
  function r(o, s, a, l) {
    Promise.resolve(l).then(function(c) {
      o({value: c, done: a})
    }, s)
  }
}
var os = n => n && typeof n.length == 'number' && typeof n != 'function';
function Zc(n) {
  return le(n?.then)
}
function Kc(n) {
  return le(n[ts])
}
function Xc(n) {
  return Symbol.asyncIterator && le(n?.[Symbol.asyncIterator])
}
function Jc(n) {
  return new TypeError(`You provided ${
      n !== null && typeof n == 'object' ?
          'an invalid object' :
          `'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
}
function jM() {
  return typeof Symbol != 'function' || !Symbol.iterator ? '@@iterator' :
                                                           Symbol.iterator
}
var ed = jM();
function td(n) {
  return le(n?.[ed])
}
function nd(n) {
  return Uy(this, arguments, function*() {
    let e = n.getReader();
    try {
      for (;;) {
        let {value: i, done: r} = yield no(e.read());
        if (r) return yield no(void 0);
        yield yield no(i)
      }
    } finally {
      e.releaseLock()
    }
  })
}
function id(n) {
  return le(n?.getReader)
}
function ze(n) {
  if (n instanceof ie) return n;
  if (n != null) {
    if (Kc(n)) return BM(n);
    if (os(n)) return zM(n);
    if (Zc(n)) return HM(n);
    if (Xc(n)) return Wy(n);
    if (td(n)) return UM(n);
    if (id(n)) return $M(n)
  }
  throw Jc(n)
}
function BM(n) {
  return new ie(t => {
    let e = n[ts]();
    if (le(e.subscribe)) return e.subscribe(t);
    throw new TypeError(
        'Provided object does not correctly implement Symbol.observable')
  })
}
function zM(n) {
  return new ie(t => {
    for (let e = 0; e < n.length && !t.closed; e++) t.next(n[e]);
    t.complete()
  })
}
function HM(n) {
  return new ie(
      t => {
          n.then(e => {t.closed || (t.next(e), t.complete())}, e => t.error(e))
              .then(null, Uc)})
}
function UM(n) {
  return new ie(t => {
    for (let e of n)
      if (t.next(e), t.closed) return;
    t.complete()
  })
}
function Wy(n) {
  return new ie(t => {WM(n, t).catch(e => t.error(e))})
}
function $M(n) {
  return Wy(nd(n))
}
function WM(n, t) {
  var e, i, r, o;
  return Hy(this, void 0, void 0, function*() {
    try {
      for (e = $y(n); i = yield e.next(), !i.done;) {
        let s = i.value;
        if (t.next(s), t.closed) return
      }
    } catch (s) {
      r = { error: s }
    } finally {
      try {
        i && !i.done && (o = e.return) && (yield o.call(e))
      } finally {
        if (r) throw r.error
      }
    }
    t.complete()
  })
}
function Wt(n, t, e, i = 0, r = !1) {
  let o = t.schedule(function() {
    e(), r ? n.add(this.schedule(null, i)) : this.unsubscribe()
  }, i);
  if (n.add(o), !r) return o
}
function rd(n, t = 0) {
  return _e(
      (e, i) => {e.subscribe(
          fe(i, r => Wt(i, n, () => i.next(r), t),
             () => Wt(i, n, () => i.complete(), t),
             r => Wt(i, n, () => i.error(r), t)))})
}
function od(n, t = 0) {
  return _e((e, i) => {i.add(n.schedule(() => e.subscribe(i), t))})
}
function qy(n, t) {
  return ze(n).pipe(od(t), rd(t))
}
function Gy(n, t) {
  return ze(n).pipe(od(t), rd(t))
}
function Qy(n, t) {
  return new ie(e => {
    let i = 0;
    return t.schedule(function() {
      i === n.length ? e.complete() :
                       (e.next(n[i++]), e.closed || this.schedule())
    })
  })
}
function Yy(n, t) {
  return new ie(e => {
    let i;
    return Wt(e, t, () => {
             i = n[ed](),
             Wt(e, t,
                () => {
                  let r, o;
                  try {
                    ({value: r, done: o} = i.next())
                  } catch (s) {
                    e.error(s);
                    return
                  }
                  o ? e.complete() : e.next(r)
                },
                0, !0)
           }),
           () => le(i?.return) && i.return()
  })
}
function sd(n, t) {
  if (!n) throw new Error('Iterable cannot be null');
  return new ie(e => {Wt(e, t, () => {
                  let i = n[Symbol.asyncIterator]();
                  Wt(e, t,
                     () => {i.next().then(
                         r => {r.done ? e.complete() : e.next(r.value)})},
                     0, !0)
                })})
}
function Zy(n, t) {
  return sd(nd(n), t)
}
function Ky(n, t) {
  if (n != null) {
    if (Kc(n)) return qy(n, t);
    if (os(n)) return Qy(n, t);
    if (Zc(n)) return Gy(n, t);
    if (Xc(n)) return sd(n, t);
    if (td(n)) return Yy(n, t);
    if (id(n)) return Zy(n, t)
  }
  throw Jc(n)
}
function Ue(n, t) {
  return t ? Ky(n, t) : ze(n)
}
function G(...n) {
  let t = Kn(n);
  return Ue(n, t)
}
function ar(n, t) {
  let e = le(n) ? n : () => n, i = r => r.error(e());
  return new ie(t ? r => t.schedule(i, 0, r) : i)
}
function lr(n) {
  return !!n && (n instanceof ie || le(n.lift) && le(n.subscribe))
}
var Ai = Xo(n => function() {
  n(this), this.name = 'EmptyError', this.message = 'no elements in sequence'
});
function Xy(n) {
  return n instanceof Date && !isNaN(n)
}
function Q(n, t) {
  return _e((e, i) => {
    let r = 0;
    e.subscribe(fe(i, o => {i.next(n.call(t, o, r++))}))
  })
}
var {isArray: qM} = Array;
function GM(n, t) {
  return qM(t) ? n(...t) : n(t)
}
function ss(n) {
  return Q(t => GM(n, t))
}
var {isArray: QM} = Array,
              {getPrototypeOf: YM, prototype: ZM, keys: KM} = Object;
function ad(n) {
  if (n.length === 1) {
    let t = n[0];
    if (QM(t)) return {args: t, keys: null};
    if (XM(t)) {
      let e = KM(t);
      return {
        args: e.map(i => t[i]), keys: e
      }
    }
  }
  return {
    args: n, keys: null
  }
}
function XM(n) {
  return n && typeof n == 'object' && YM(n) === ZM
}
function ld(n, t) {
  return n.reduce((e, i, r) => (e[i] = t[r], e), {})
}
function Mn(...n) {
  let t = Kn(n), e = Yc(n), {args: i, keys: r} = ad(n);
  if (i.length === 0) return Ue([], t);
  let o = new ie(JM(i, t, r ? s => ld(r, s) : Vt));
  return e ? o.pipe(ss(e)) : o
}
function JM(n, t, e = Vt) {
  return i => {
    Jy(t, () => {
      let {length: r} = n, o = new Array(r), s = r, a = r;
      for (let l = 0; l < r; l++)
        Jy(t, () => {
          let c = Ue(n[l], t), d = !1;
          c.subscribe(fe(
              i, m => {o[l] = m, d || (d = !0, a--), a || i.next(e(o.slice()))},
              () => {--s || i.complete()}))
        }, i)
    }, i)
  }
}
function Jy(n, t, e) {
  n ? Wt(e, n, t) : t()
}
function e0(n, t, e, i, r, o, s, a) {
  let l = [], c = 0, d = 0, m = !1, p = () => {
    m && !l.length && !c && t.complete()
  }, h = v => c < i ? _(v) : l.push(v), _ = v => {
    o && t.next(v), c++;
    let k = !1;
    ze(e(v, d++)).subscribe(fe(
        t, F => {r?.(F), o ? h(F) : t.next(F)}, () => {k = !0}, void 0, () => {
          if (k) try {
              for (c--; l.length && c < i;) {
                let F = l.shift();
                s ? Wt(t, s, () => _(F)) : _(F)
              }
              p()
            } catch (F) {
              t.error(F)
            }
        }))
  };
  return n.subscribe(fe(t, h, () => {m = !0, p()})), () => {
    a?.()
  }
}
function ot(n, t, e = 1 / 0) {
  return le(t) ? ot((i, r) => Q((o, s) => t(i, o, r, s))(ze(n(i, r))), e) :
                 (typeof t == 'number' && (e = t), _e((i, r) => e0(i, r, n, e)))
}
function cr(n = 1 / 0) {
  return ot(Vt, n)
}
function t0() {
  return cr(1)
}
function dr(...n) {
  return t0()(Ue(n, Kn(n)))
}
function Xn(n) {
  return new ie(t => {ze(n()).subscribe(t)})
}
function Fa(...n) {
  let t = Yc(n), {args: e, keys: i} = ad(n),
      r = new ie(o => {
        let {length: s} = e;
        if (!s) {
          o.complete();
          return
        }
        let a = new Array(s), l = s, c = s;
        for (let d = 0; d < s; d++) {
          let m = !1;
          ze(e[d]).subscribe(fe(
              o, p => {m || (m = !0, c--), a[d] = p}, () => l--, void 0,
              () => {
                  (!l || !m) && (c || o.next(i ? ld(i, a) : a), o.complete())}))
        }
      });
  return t ? r.pipe(ss(t)) : r
}
var eT = ['addListener', 'removeListener'],
    tT = ['addEventListener', 'removeEventListener'], nT = ['on', 'off'];
function La(n, t, e, i) {
  if (le(e) && (i = e, e = void 0), i) return La(n, t, e).pipe(ss(i));
  let [r, o] = oT(n) ? tT.map(s => a => n[s](t, a, e)) :
      iT(n)          ? eT.map(n0(n, t)) :
      rT(n)          ? nT.map(n0(n, t)) :
                       [];
  if (!r && os(n)) return ot(s => La(s, t, e))(ze(n));
  if (!r) throw new TypeError('Invalid event target');
  return new ie(s => {
    let a = (...l) => s.next(1 < l.length ? l : l[0]);
    return r(a), () => o(a)
  })
}
function n0(n, t) {
  return e => i => n[e](t, i)
}
function iT(n) {
  return le(n.addListener) && le(n.removeListener)
}
function rT(n) {
  return le(n.on) && le(n.off)
}
function oT(n) {
  return le(n.addEventListener) && le(n.removeEventListener)
}
function io(n = 0, t, e = jy) {
  let i = -1;
  return t != null && (Qc(t) ? e = t : i = t), new ie(r => {
           let o = Xy(n) ? +n - e.now() : n;
           o < 0 && (o = 0);
           let s = 0;
           return e.schedule(function() {
             r.closed ||
                 (r.next(s++), 0 <= i ? this.schedule(void 0, i) : r.complete())
           }, o)
         })
}
function Ke(...n) {
  let t = Kn(n), e = By(n, 1 / 0), i = n;
  return i.length ? i.length === 1 ? ze(i[0]) : cr(e)(Ue(i, t)) : mt
}
function me(n, t) {
  return _e((e, i) => {
    let r = 0;
    e.subscribe(fe(i, o => n.call(t, o, r++) && i.next(o)))
  })
}
function i0(n) {
  return _e((t, e) => {
    let i = !1, r = null, o = null, s = !1, a = () => {
      if (o?.unsubscribe(), o = null, i) {
        i = !1;
        let c = r;
        r = null, e.next(c)
      }
      s && e.complete()
    }, l = () => {
      o = null, s && e.complete()
    };
    t.subscribe(
        fe(e, c => {i = !0, r = c, o || ze(n(c)).subscribe(o = fe(e, a, l))},
           () => {s = !0, (!i || !o || o.closed) && e.complete()}))
  })
}
function cd(n, t = Pa) {
  return i0(() => io(n, t))
}
function sn(n) {
  return _e((t, e) => {
    let i = null, r = !1, o;
    i = t.subscribe(fe(e, void 0, void 0, s => {
      o = ze(n(s, sn(n)(t))),
      i ? (i.unsubscribe(), i = null, o.subscribe(e)) : r = !0
    })),
    r && (i.unsubscribe(), i = null, o.subscribe(e))
  })
}
function r0(n, t, e, i, r) {
  return (o, s) => {
    let a = e, l = t, c = 0;
    o.subscribe(fe(s, d => {
      let m = c++;
      l = a ? n(l, d, m) : (a = !0, d), i && s.next(l)
    }, r && (() => {a && s.next(l), s.complete()})))
  }
}
function Oi(n, t) {
  return le(t) ? ot(n, t, 1) : ot(n, 1)
}
function Tn(n, t = Pa) {
  return _e((e, i) => {
    let r = null, o = null, s = null, a = () => {
      if (r) {
        r.unsubscribe(), r = null;
        let c = o;
        o = null, i.next(c)
      }
    };
    function l() {
      let c = s + n, d = t.now();
      if (d < c) {
        r = this.schedule(void 0, c - d), i.add(r);
        return
      }
      a()
    }
    e.subscribe(
        fe(i, c => {o = c, s = t.now(), r || (r = t.schedule(l, n), i.add(r))},
           () => {a(), i.complete()}, void 0, () => {o = r = null}))
  })
}
function ur(n) {
  return _e((t, e) => {
    let i = !1;
    t.subscribe(
        fe(e, r => {i = !0, e.next(r)}, () => {i || e.next(n), e.complete()}))
  })
}
function Ye(n) {
  return n <= 0 ? () => mt : _e((t, e) => {
    let i = 0;
    t.subscribe(fe(e, r => {++i <= n && (e.next(r), n <= i && e.complete())}))
  })
}
function as (n) {
  return Q(() => n)
}
function Rn(n, t = Vt) {
  return n = n ?? sT, _e((e, i) => {
           let r, o = !0;
           e.subscribe(fe(i, s => {
             let a = t(s);
             (o || !n(r, a)) && (o = !1, r = a, i.next(s))
           }))
         })
}
function sT(n, t) {
  return n === t
}
function dd(n = aT) {
  return _e((t, e) => {
    let i = !1;
    t.subscribe(
        fe(e, r => {i = !0, e.next(r)}, () => i ? e.complete() : e.error(n())))
  })
}
function aT() {
  return new Ai
}
function Jn(n) {
  return _e((t, e) => {
    try {
      t.subscribe(e)
    } finally {
      e.add(n)
    }
  })
}
function ei(n, t) {
  let e = arguments.length >= 2;
  return i => i.pipe(
             n ? me((r, o) => n(r, o, i)) : Vt, Ye(1),
             e ? ur(t) : dd(() => new Ai))
}
function ls(n) {
  return n <= 0 ? () => mt : _e((t, e) => {
    let i = [];
    t.subscribe(fe(e, r => {i.push(r), n < i.length && i.shift()}, () => {
      for (let r of i) e.next(r);
      e.complete()
    }, void 0, () => {i = null}))
  })
}
function _f(n, t) {
  let e = arguments.length >= 2;
  return i => i.pipe(
             n ? me((r, o) => n(r, o, i)) : Vt, ls(1),
             e ? ur(t) : dd(() => new Ai))
}
function ud() {
  return _e((n, t) => {
    let e, i = !1;
    n.subscribe(fe(t, r => {
      let o = e;
      e = r, i && t.next([o, r]), i = !0
    }))
  })
}
function bf(n, t) {
  return _e(r0(n, t, arguments.length >= 2, !0))
}
function Va(n = {}) {
  let {
    connector: t = () => new I,
    resetOnError: e = !0,
    resetOnComplete: i = !0,
    resetOnRefCountZero: r = !0
  } = n;
  return o => {
    let s, a, l, c = 0, d = !1, m = !1, p = () => {
      a?.unsubscribe(), a = void 0
    }, h = () => {
      p(), s = l = void 0, d = m = !1
    }, _ = () => {
      let v = s;
      h(), v?.unsubscribe()
    };
    return _e((v, k) => {
      c++, !m && !d && p();
      let F = l = l ?? t();
      k.add(() => {c--, c === 0 && !m && !d && (a = vf(_, r))}), F.subscribe(k),
          !s && c > 0 &&
          (s = new Ri({
             next: se => F.next(se),
             error: se => {m = !0, p(), a = vf(h, e, se), F.error(se)},
             complete: () => {
               d = !0, p(), a = vf(h, i), F.complete()
             }
           }),
           ze(v).subscribe(s))
    })(o)
  }
}
function vf(n, t, ...e) {
  if (t === !0) {
    n();
    return
  }
  if (t === !1) return;
  let i = new Ri({
    next: () => {
      i.unsubscribe(), n()
    }
  });
  return ze(t(...e)).subscribe(i)
}
function Ni(n, t, e) {
  let i, r = !1;
  return n && typeof n == 'object' ? {
    bufferSize: i = 1 / 0,
    windowTime: t = 1 / 0,
    refCount: r = !1,
    scheduler: e
  } = n :
                                     i = n ?? 1 / 0,
 Va({
      connector: () => new In(i, t, e),
      resetOnError: !0,
      resetOnComplete: !1,
      resetOnRefCountZero: r
         })
}
function ro(n) {
  return me((t, e) => n <= e)
}
function Xe(...n) {
  let t = Kn(n);
  return _e((e, i) => {(t ? dr(n, e, t) : dr(n, e)).subscribe(i)})
}
function $e(n, t) {
  return _e((e, i) => {
    let r = null, o = 0, s = !1, a = () => s && !r && i.complete();
    e.subscribe(fe(i, l => {
      r?.unsubscribe();
      let c = 0, d = o++;
      ze(n(l, d)).subscribe(
          r = fe(
              i, m => i.next(t ? t(l, m, d, c++) : m), () => {r = null, a()}))
    }, () => {s = !0, a()}))
  })
}
function re(n) {
  return _e((t, e) => {
    ze(n).subscribe(fe(e, () => e.complete(), Aa)),
    !e.closed && t.subscribe(e)
  })
}
function yf(n, t = !1) {
  return _e((e, i) => {
    let r = 0;
    e.subscribe(fe(i, o => {
      let s = n(o, r++);
      (s || t) && i.next(o), !s && i.complete()
    }))
  })
}
function He(n, t, e) {
  let i = le(n) || t || e ? {next: n, error: t, complete: e} : n;
  return i ? _e((r, o) => {
    var s;
    (s = i.subscribe) === null || s === void 0 || s.call(i);
    let a = !0;
    r.subscribe(
        fe(o,
           l => {
             var c;
             (c = i.next) === null || c === void 0 || c.call(i, l), o.next(l)
           },
           () => {
             var l;
             a = !1, (l = i.complete) === null || l === void 0 || l.call(i),
             o.complete()
           },
           l => {
             var c;
             a = !1, (c = i.error) === null || c === void 0 || c.call(i, l),
             o.error(l)
           },
           () => {
             var l, c;
             a && ((l = i.unsubscribe) === null || l === void 0 || l.call(i)),
                 (c = i.finalize) === null || c === void 0 || c.call(i)
           }))
  }) :
             Vt
}
var Z0 =
        'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss',
    S = class extends Error {
  code;
  constructor(t, e) {
    super(Xd(t, e)), this.code = t
  }
};
function Xd(n, t) {
  return `${`NG0${Math.abs(n)}`}${t ? ': ' + t : ''}`
}
var K0 = Symbol('InputSignalNode#UNSET'), lT = ae(y({}, rf), {
                                            transformFn: void 0,
                                            applyValueToInputSignal(n, t) {
                                              Bc(n, t)
                                            }
                                          });
function X0(n, t) {
  let e = Object.create(lT);
  e.value = n, e.transformFn = t?.transform;
  function i() {
    if (Pc(e), e.value === K0) {
      let r = null;
      throw new S(-950, r)
    }
    return e.value
  }
  return i[$t] = e, i
}
function Xa(n) {
  return {toString: n}.toString()
}
var md = '__parameters__';
function cT(n) {
  return function(...e) {
    if (n) {
      let i = n(...e);
      for (let r in i) this[r] = i[r]
    }
  }
}
function J0(n, t, e) {
  return Xa(() => {
    let i = cT(t);
    function r(...o) {
      if (this instanceof r) return i.apply(this, o), this;
      let s = new r(...o);
      return a.annotation = s, a;
      function a(l, c, d) {
        let m = l.hasOwnProperty(md) ?
            l[md] :
            Object.defineProperty(l, md, {value: []})[md];
        for (; m.length <= d;) m.push(null);
        return (m[d] = m[d] || []).push(s), l
      }
    }
    return r.prototype.ngMetadataName = n, r.annotationCls = r, r
  })
}
var Pn = globalThis;
function We(n) {
  for (let t in n)
    if (n[t] === We) return t;
  throw Error('Could not find renamed property on target object.')
}
function dT(n, t) {
  for (let e in t) t.hasOwnProperty(e) && !n.hasOwnProperty(e) && (n[e] = t[e])
}
function Gt(n) {
  if (typeof n == 'string') return n;
  if (Array.isArray(n)) return `[${n.map(Gt).join(', ')}]`;
  if (n == null) return '' + n;
  let t = n.overriddenName || n.name;
  if (t) return `${t}`;
  let e = n.toString();
  if (e == null) return '' + e;
  let i = e.indexOf(`
`);
  return i >= 0 ? e.slice(0, i) : e
}
function Pf(n, t) {
  return n ? t ? `${n} ${t}` : n : t || ''
}
var uT = We({__forward_ref__: We});
function Zt(n) {
  return n.__forward_ref__ = Zt, n.toString = function() {
    return Gt(this())
  }, n
}
function Dt(n) {
  return ew(n) ? n() : n
}
function ew(n) {
  return typeof n == 'function' && n.hasOwnProperty(uT) &&
      n.__forward_ref__ === Zt
}
function C(n) {
  return {
    token: n.token, providedIn: n.providedIn || null, factory: n.factory,
        value: void 0
  }
}
function V(n) {
  return {
    providers: n.providers || [], imports: n.imports || []
  }
}
function Jd(n) {
  return o0(n, nw) || o0(n, iw)
}
function tw(n) {
  return Jd(n) !== null
}
function o0(n, t) {
  return n.hasOwnProperty(t) ? n[t] : null
}
function mT(n) {
  let t = n && (n[nw] || n[iw]);
  return t || null
}
function s0(n) {
  return n && (n.hasOwnProperty(a0) || n.hasOwnProperty(hT)) ? n[a0] : null
}
var nw = We({\u0275prov: We}), a0 = We({\u0275inj: We}),
    iw = We({ngInjectableDef: We}), hT = We({ngInjectorDef: We}), w = class {
  _desc;
  ngMetadataName = 'InjectionToken';
  \u0275prov;
  constructor(t, e) {
    this._desc = t, this.\u0275prov = void 0,
    typeof e == 'number' ?
        this.__NG_ELEMENT_ID__ = e :
        e !== void 0 && (this.\u0275prov = C({
                           token: this,
                           providedIn: e.providedIn || 'root',
                           factory: e.factory
                         }))
  }
  get multi() {
    return this
  }
  toString() {
    return `InjectionToken ${this._desc}`
  }
};
function rw(n) {
  return n && !!n.\u0275providers
}
var fT = We({\u0275cmp: We}), pT = We({\u0275dir: We}),
    gT = We({\u0275pipe: We}), _T = We({\u0275mod: We}),
    xd = We({\u0275fac: We}), Ha = We({__NG_ELEMENT_ID__: We}),
    l0 = We({__NG_ENV_ID__: We});
function eu(n) {
  return typeof n == 'string' ? n : n == null ? '' : String(n)
}
function bT(n) {
  return typeof n == 'function' ? n.name || n.toString() :
      typeof n == 'object' && n != null && typeof n.type == 'function' ?
                                  n.type.name || n.type.toString() :
                                  eu(n)
}
function ow(n, t) {
  throw new S(-200, n)
}
function $p(n, t) {
  throw new S(-201, !1)
}
var ke = function(n) {
  return n[n.Default = 0] = 'Default', n[n.Host = 1] = 'Host',
                       n[n.Self = 2] = 'Self', n[n.SkipSelf = 4] = 'SkipSelf',
                       n[n.Optional = 8] = 'Optional', n
}(ke || {}), Ff;
function sw() {
  return Ff
}
function qt(n) {
  let t = Ff;
  return Ff = n, t
}
function aw(n, t, e) {
  let i = Jd(n);
  if (i && i.providedIn == 'root')
    return i.value === void 0 ? i.value = i.factory() : i.value;
  if (e & ke.Optional) return null;
  if (t !== void 0) return t;
  $p(n, 'Injector')
}
var vT = {}, oo = vT, Lf = '__NG_DI_FLAG__', Cd = class {
  injector;
  constructor(t) {
    this.injector = t
  }
  retrieve(t, e) {
    let i = e;
    return this.injector.get(t, i.optional ? sf : oo, i)
  }
}
, Dd = 'ngTempTokenPath', yT = 'ngTokenPath', wT = /\n/gm, xT = '\u0275',
  c0 = '__source';
function CT(n, t = ke.Default) {
  if (Ra() === void 0) throw new S(-203, !1);
  if (Ra() === null) return aw(n, void 0, t);
  {
    let e = Ra(), i;
    return e instanceof Cd ? i = e.injector : i = e,
                             i.get(n, t & ke.Optional ? null : void 0, t)
  }
}
function A(n, t = ke.Default) {
  return (sw() || CT)(Dt(n), t)
}
function u(n, t = ke.Default) {
  return A(n, tu(t))
}
function tu(n) {
  return typeof n > 'u' || typeof n == 'number' ?
      n :
      0 | (n.optional && 8) | (n.host && 1) | (n.self && 2) | (n.skipSelf && 4)
}
function Vf(n) {
  let t = [];
  for (let e = 0; e < n.length; e++) {
    let i = Dt(n[e]);
    if (Array.isArray(i)) {
      if (i.length === 0) throw new S(900, !1);
      let r, o = ke.Default;
      for (let s = 0; s < i.length; s++) {
        let a = i[s], l = DT(a);
        typeof l == 'number' ? l === -1 ? r = a.token : o |= l : r = a
      }
      t.push(A(r, o))
    } else
      t.push(A(i))
  }
  return t
}
function lw(n, t) {
  return n[Lf] = t, n.prototype[Lf] = t, n
}
function DT(n) {
  return n[Lf]
}
function ET(n, t, e, i) {
  let r = n[Dd];
  throw t[c0] && r.unshift(t[c0]),
      n.message =
          kT(`
` + n.message,
             r, e, i),
      n[yT] = r, n[Dd] = null, n
}
function kT(n, t, e, i = null) {
  n = n && n.charAt(0) === `
` && n.charAt(1) == xT ?
      n.slice(2) :
      n;
  let r = Gt(t);
  if (Array.isArray(t))
    r = t.map(Gt).join(' -> ');
  else if (typeof t == 'object') {
    let o = [];
    for (let s in t)
      if (t.hasOwnProperty(s)) {
        let a = t[s];
        o.push(s + ':' + (typeof a == 'string' ? JSON.stringify(a) : Gt(a)))
      }
    r = `{${o.join(', ')}}`
  }
  return `${e}${i ? '(' + i + ')' : ''}[${r}]: ${n.replace(wT, `
  `)}`
}
var bo = lw(J0('Optional'), 8);
var Ja = lw(J0('SkipSelf'), 4);
function ao(n, t) {
  let e = n.hasOwnProperty(xd);
  return e ? n[xd] : null
}
function ST(n, t, e) {
  if (n.length !== t.length) return !1;
  for (let i = 0; i < n.length; i++) {
    let r = n[i], o = t[i];
    if (e && (r = e(r), o = e(o)), o !== r) return !1
  }
  return !0
}
function IT(n) {
  return n.flat(Number.POSITIVE_INFINITY)
}
function Wp(n, t) {
  n.forEach(e => Array.isArray(e) ? Wp(e, t) : t(e))
}
function cw(n, t, e) {
  t >= n.length ? n.push(e) : n.splice(t, 0, e)
}
function Ed(n, t) {
  return t >= n.length - 1 ? n.pop() : n.splice(t, 1)[0]
}
function MT(n, t) {
  let e = [];
  for (let i = 0; i < n; i++) e.push(t);
  return e
}
function TT(n, t, e, i) {
  let r = n.length;
  if (r == t)
    n.push(e, i);
  else if (r === 1)
    n.push(i, n[0]), n[0] = e;
  else {
    for (r--, n.push(n[r - 1], n[r]); r > t;) {
      let o = r - 2;
      n[r] = n[o], r--
    }
    n[t] = e, n[t + 1] = i
  }
}
function nu(n, t, e) {
  let i = el(n, t);
  return i >= 0 ? n[i | 1] = e : (i = ~i, TT(n, i, t, e)), i
}
function wf(n, t) {
  let e = el(n, t);
  if (e >= 0) return n[e | 1]
}
function el(n, t) {
  return RT(n, t, 1)
}
function RT(n, t, e) {
  let i = 0, r = n.length >> e;
  for (; r !== i;) {
    let o = i + (r - i >> 1), s = n[o << e];
    if (t === s) return o << e;
    s > t ? r = o : i = o + 1
  }
  return ~(r << e)
}
var ni = {}, jt = [], ps = new w(''), dw = new w('', -1), uw = new w(''),
    kd = class {
  get(t, e = oo) {
    if (e === oo) {
      let i = new Error(`NullInjectorError: No provider for ${Gt(t)}!`);
      throw i.name = 'NullInjectorError', i
    }
    return e
  }
};
function mw(n, t) {
  let e = n[_T] || null;
  if (!e && t === !0)
    throw new Error(`Type ${Gt(n)} does not have '\u0275mod' property.`);
  return e
}
function fr(n) {
  return n[fT] || null
}
function hw(n) {
  return n[pT] || null
}
function AT(n) {
  return n[gT] || null
}
function iu(n) {
  return {
    \u0275providers: n
  }
}
function OT(...n) {
  return {
    \u0275providers: fw(!0, n), \u0275fromNgModule: !0
  }
}
function fw(n, ...t) {
  let e = [], i = new Set, r, o = s => {
    e.push(s)
  };
  return Wp(t, s => {
           let a = s;
           jf(a, o, [], i) && (r ||= [], r.push(a))
         }), r !== void 0 && pw(r, o), e
}
function pw(n, t) {
  for (let e = 0; e < n.length; e++) {
    let {ngModule: i, providers: r} = n[e];
    qp(r, o => {t(o, i)})
  }
}
function jf(n, t, e, i) {
  if (n = Dt(n), !n) return !1;
  let r = null, o = s0(n), s = !o && fr(n);
  if (!o && !s) {
    let l = n.ngModule;
    if (o = s0(l), o)
      r = l;
    else
      return !1
  } else {
    if (s && !s.standalone) return !1;
    r = n
  }
  let a = i.has(r);
  if (s) {
    if (a) return !1;
    if (i.add(r), s.dependencies) {
      let l = typeof s.dependencies == 'function' ? s.dependencies() :
                                                    s.dependencies;
      for (let c of l) jf(c, t, e, i)
    }
  } else if (o) {
    if (o.imports != null && !a) {
      i.add(r);
      let c;
      try {
        Wp(o.imports, d => {jf(d, t, e, i) && (c ||= [], c.push(d))})
      } finally {
      }
      c !== void 0 && pw(c, t)
    }
    if (!a) {
      let c = ao(r) || (() => new r);
      t({provide: r, useFactory: c, deps: jt}, r),
          t({provide: uw, useValue: r, multi: !0}, r),
          t({provide: ps, useValue: () => A(r), multi: !0}, r)
    }
    let l = o.providers;
    if (l != null && !a) {
      let c = n;
      qp(l, d => {t(d, c)})
    }
  } else
    return !1;
  return r !== n && n.providers !== void 0
}
function qp(n, t) {
  for (let e of n)
    rw(e) && (e = e.\u0275providers), Array.isArray(e) ? qp(e, t) : t(e)
}
var NT = We({provide: String, useValue: We});
function gw(n) {
  return n !== null && typeof n == 'object' && NT in n
}
function PT(n) {
  return !!(n && n.useExisting)
}
function FT(n) {
  return !!(n && n.useFactory)
}
function gs(n) {
  return typeof n == 'function'
}
function LT(n) {
  return !!n.useClass
}
var ru = new w(''), _d = {}, d0 = {}, xf;
function ou() {
  return xf === void 0 && (xf = new kd), xf
}
var _t = class {}
, $a = class extends _t {
  parent;
  source;
  scopes;
  records = new Map;
  _ngOnDestroyHooks = new Set;
  _onDestroyHooks = [];
  get destroyed() {
    return this._destroyed
  }
  _destroyed = !1;
  injectorDefTypes;
  constructor(t, e, i, r) {
    super(), this.parent = e, this.source = i, this.scopes = r,
             zf(t, s => this.processProvider(s)),
             this.records.set(dw, cs(void 0, this)),
             r.has('environment') && this.records.set(_t, cs(void 0, this));
    let o = this.records.get(ru);
    o != null && typeof o.value == 'string' && this.scopes.add(o.value),
        this.injectorDefTypes = new Set(this.get(uw, jt, ke.Self))
  }
  retrieve(t, e) {
    let i = e;
    return this.get(t, i.optional ? sf : oo, i)
  }
  destroy() {
    Ba(this), this._destroyed = !0;
    let t = Me(null);
    try {
      for (let i of this._ngOnDestroyHooks) i.ngOnDestroy();
      let e = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (let i of e) i()
    } finally {
      this.records.clear(), this._ngOnDestroyHooks.clear(),
          this.injectorDefTypes.clear(), Me(t)
    }
  }
  onDestroy(t) {
    return Ba(this), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t)
  }
  runInContext(t) {
    Ba(this);
    let e = Mi(this), i = qt(void 0), r;
    try {
      return t()
    } finally {
      Mi(e), qt(i)
    }
  }
  get(t, e = oo, i = ke.Default) {
    if (Ba(this), t.hasOwnProperty(l0)) return t[l0](this);
    i = tu(i);
    let r, o = Mi(this), s = qt(void 0);
    try {
      if (!(i & ke.SkipSelf)) {
        let l = this.records.get(t);
        if (l === void 0) {
          let c = HT(t) && Jd(t);
          c && this.injectableDefInScope(c) ? l = cs(Bf(t), _d) : l = null,
                                              this.records.set(t, l)
        }
        if (l != null) return this.hydrate(t, l)
      }
      let a = i & ke.Self ? ou() : this.parent;
      return e = i & ke.Optional && e === oo ? null : e, a.get(t, e)
    } catch (a) {
      if (a.name === 'NullInjectorError') {
        if ((a[Dd] = a[Dd] || []).unshift(Gt(t)), o) throw a;
        return ET(a, t, 'R3InjectorError', this.source)
      } else
        throw a
    } finally {
      qt(s), Mi(o)
    }
  }
  resolveInjectorInitializers() {
    let t = Me(null), e = Mi(this), i = qt(void 0), r;
    try {
      let o = this.get(ps, jt, ke.Self);
      for (let s of o) s()
    } finally {
      Mi(e), qt(i), Me(t)
    }
  }
  toString() {
    let t = [], e = this.records;
    for (let i of e.keys()) t.push(Gt(i));
    return `R3Injector[${t.join(', ')}]`
  }
  processProvider(t) {
    t = Dt(t);
    let e = gs(t) ? t : Dt(t && t.provide), i = jT(t);
    if (!gs(t) && t.multi === !0) {
      let r = this.records.get(e);
      r ||
          (r = cs(void 0, _d, !0), r.factory = () => Vf(r.multi),
           this.records.set(e, r)),
          e = t, r.multi.push(t)
    }
    this.records.set(e, i)
  }
  hydrate(t, e) {
    let i = Me(null);
    try {
      return e.value === d0 ?
                 ow(Gt(t)) :
                 e.value === _d && (e.value = d0, e.value = e.factory()),
             typeof e.value == 'object' && e.value && zT(e.value) &&
                 this._ngOnDestroyHooks.add(e.value),
             e.value
    } finally {
      Me(i)
    }
  }
  injectableDefInScope(t) {
    if (!t.providedIn) return !1;
    let e = Dt(t.providedIn);
    return typeof e == 'string' ? e === 'any' || this.scopes.has(e) :
                                  this.injectorDefTypes.has(e)
  }
  removeOnDestroy(t) {
    let e = this._onDestroyHooks.indexOf(t);
    e !== -1 && this._onDestroyHooks.splice(e, 1)
  }
};
function Bf(n) {
  let t = Jd(n), e = t !== null ? t.factory : ao(n);
  if (e !== null) return e;
  if (n instanceof w) throw new S(204, !1);
  if (n instanceof Function) return VT(n);
  throw new S(204, !1)
}
function VT(n) {
  if (n.length > 0) throw new S(204, !1);
  let e = mT(n);
  return e !== null ? () => e.factory(n) : () => new n
}
function jT(n) {
  if (gw(n)) return cs(void 0, n.useValue);
  {
    let t = _w(n);
    return cs(t, _d)
  }
}
function _w(n, t, e) {
  let i;
  if (gs(n)) {
    let r = Dt(n);
    return ao(r) || Bf(r)
  } else if (gw(n))
    i = () => Dt(n.useValue);
  else if (FT(n))
    i = () => n.useFactory(...Vf(n.deps || []));
  else if (PT(n))
    i = () => A(Dt(n.useExisting));
  else {
    let r = Dt(n && (n.useClass || n.provide));
    if (BT(n))
      i = () => new r(...Vf(n.deps));
    else
      return ao(r) || Bf(r)
  }
  return i
}
function Ba(n) {
  if (n.destroyed) throw new S(205, !1)
}
function cs(n, t, e = !1) {
  return {
    factory: n, value: t, multi: e ? [] : void 0
  }
}
function BT(n) {
  return !!n.deps
}
function zT(n) {
  return n !== null && typeof n == 'object' &&
      typeof n.ngOnDestroy == 'function'
}
function HT(n) {
  return typeof n == 'function' || typeof n == 'object' && n instanceof w
}
function zf(n, t) {
  for (let e of n)
    Array.isArray(e) ? zf(e, t) : e && rw(e) ? zf(e.\u0275providers, t) : t(e)
}
function Kt(n, t) {
  let e;
  n instanceof $a ? (Ba(n), e = n) : e = new Cd(n);
  let i, r = Mi(e), o = qt(void 0);
  try {
    return t()
  } finally {
    Mi(r), qt(o)
  }
}
function bw() {
  return sw() !== void 0 || Ra() != null
}
function su(n) {
  if (!bw()) throw new S(-203, !1)
}
function UT(n) {
  let t = Pn.ng;
  if (t && t.\u0275compilerFacade) return t.\u0275compilerFacade;
  throw new Error('JIT compiler unavailable')
}
function $T(n) {
  return typeof n == 'function'
}
var ji = 0, xe = 1, be = 2, At = 3, Nn = 4, Xt = 5, _s = 6, Sd = 7, gt = 8,
    Wa = 9, Pi = 10, nt = 11, qa = 12, u0 = 13, Cs = 14, an = 15, lo = 16,
    ds = 17, Fi = 18, au = 19, vw = 20, mr = 21, Cf = 22, co = 23, _n = 24,
    hs = 25, bt = 26, yw = 1;
var uo = 7, Id = 8, bs = 9, Rt = 10;
function hr(n) {
  return Array.isArray(n) && typeof n[yw] == 'object'
}
function Bi(n) {
  return Array.isArray(n) && n[yw] === !0
}
function Gp(n) {
  return (n.flags & 4) !== 0
}
function Ds(n) {
  return n.componentOffset > -1
}
function lu(n) {
  return (n.flags & 1) === 1
}
function ii(n) {
  return !!n.template
}
function Md(n) {
  return (n[be] & 512) !== 0
}
function tl(n) {
  return (n[be] & 256) === 256
}
var Hf = class {
  previousValue;
  currentValue;
  firstChange;
  constructor(t, e, i) {
    this.previousValue = t, this.currentValue = e, this.firstChange = i
  }
  isFirstChange() {
    return this.firstChange
  }
};
function ww(n, t, e, i) {
  t !== null ? t.applyValueToInputSignal(t, i) : n[e] = i
}
var Pe = (() => {
  let n = () => xw;
  return n.ngInherit = !0, n
})();
function xw(n) {
  return n.type.prototype.ngOnChanges && (n.setInput = qT), WT
}
function WT() {
  let n = Dw(this), t = n?.current;
  if (t) {
    let e = n.previous;
    if (e === ni)
      n.previous = t;
    else
      for (let i in t) e[i] = t[i];
    n.current = null, this.ngOnChanges(t)
  }
}
function qT(n, t, e, i, r) {
  let o = this.declaredInputs[i],
      s = Dw(n) || GT(n, {previous: ni, current: null}),
      a = s.current || (s.current = {}), l = s.previous, c = l[o];
  a[o] = new Hf(c && c.currentValue, e, l === ni), ww(n, t, r, e)
}
var Cw = '__ngSimpleChanges__';
function Dw(n) {
  return n[Cw] || null
}
function GT(n, t) {
  return n[Cw] = t
}
var m0 = null;
var Qe = function(n, t = null, e) {
  m0?.(n, t, e)
}, Ew = 'svg', QT = 'math';
function ri(n) {
  for (; Array.isArray(n);) n = n[ji];
  return n
}
function kw(n, t) {
  return ri(t[n])
}
function ci(n, t) {
  return ri(t[n.index])
}
function Qp(n, t) {
  return n.data[t]
}
function Yp(n, t) {
  return n[t]
}
function oi(n, t) {
  let e = t[n];
  return hr(e) ? e : e[ji]
}
function YT(n) {
  return (n[be] & 4) === 4
}
function Zp(n) {
  return (n[be] & 128) === 128
}
function ZT(n) {
  return Bi(n[At])
}
function pr(n, t) {
  return t == null ? null : n[t]
}
function Sw(n) {
  n[ds] = 0
}
function Iw(n) {
  n[be]&1024 || (n[be] |= 1024, Zp(n) && Es(n))
}
function KT(n, t) {
  for (; n > 0;) t = t[Cs], n--;
  return t
}
function cu(n) {
  return !!(n[be] & 9216 || n[_n]?.dirty)
}
function Uf(n) {
  n[Pi].changeDetectionScheduler?.notify(8), n[be]&64 && (n[be] |= 1024),
      cu(n) && Es(n)
}
function Es(n) {
  n[Pi].changeDetectionScheduler?.notify(0);
  let t = mo(n);
  for (; t !== null && !(t[be] & 8192 || (t[be] |= 8192, !Zp(t)));) t = mo(t)
}
function Mw(n, t) {
  if (tl(n)) throw new S(911, !1);
  n[mr] === null && (n[mr] = []), n[mr].push(t)
}
function XT(n, t) {
  if (n[mr] === null) return;
  let e = n[mr].indexOf(t);
  e !== -1 && n[mr].splice(e, 1)
}
function mo(n) {
  let t = n[At];
  return Bi(t) ? t[At] : t
}
function Tw(n) {
  return n[Sd] ??= []
}
function Rw(n) {
  return n.cleanup ??= []
}
function JT(n, t, e, i) {
  let r = Tw(t);
  r.push(e), n.firstCreatePass && Rw(n).push(i, r.length - 1)
}
var De = {lFrame: Vw(null), bindingsEnabled: !0, skipHydrationRootTNode: null};
var $f = !1;
function eR() {
  return De.lFrame.elementDepthCount
}
function tR() {
  De.lFrame.elementDepthCount++
}
function nR() {
  De.lFrame.elementDepthCount--
}
function Kp() {
  return De.bindingsEnabled
}
function Aw() {
  return De.skipHydrationRootTNode !== null
}
function iR(n) {
  return De.skipHydrationRootTNode === n
}
function rR() {
  De.skipHydrationRootTNode = null
}
function ve() {
  return De.lFrame.lView
}
function it() {
  return De.lFrame.tView
}
function N(n) {
  return De.lFrame.contextLView = n, n[gt]
}
function P(n) {
  return De.lFrame.contextLView = null, n
}
function Nt() {
  let n = Ow();
  for (; n !== null && n.type === 64;) n = n.parent;
  return n
}
function Ow() {
  return De.lFrame.currentTNode
}
function oR() {
  let n = De.lFrame, t = n.currentTNode;
  return n.isParent ? t : t.parent
}
function vo(n, t) {
  let e = De.lFrame;
  e.currentTNode = n, e.isParent = t
}
function Xp() {
  return De.lFrame.isParent
}
function Jp() {
  De.lFrame.isParent = !1
}
function sR() {
  return De.lFrame.contextLView
}
function Nw() {
  return $f
}
function Td(n) {
  let t = $f;
  return $f = n, t
}
function nl() {
  let n = De.lFrame, t = n.bindingRootIndex;
  return t === -1 && (t = n.bindingRootIndex = n.tView.bindingStartIndex), t
}
function aR(n) {
  return De.lFrame.bindingIndex = n
}
function yo() {
  return De.lFrame.bindingIndex++
}
function Pw(n) {
  let t = De.lFrame, e = t.bindingIndex;
  return t.bindingIndex = t.bindingIndex + n, e
}
function lR() {
  return De.lFrame.inI18n
}
function cR(n, t) {
  let e = De.lFrame;
  e.bindingIndex = e.bindingRootIndex = n, Wf(t)
}
function dR() {
  return De.lFrame.currentDirectiveIndex
}
function Wf(n) {
  De.lFrame.currentDirectiveIndex = n
}
function uR(n) {
  let t = De.lFrame.currentDirectiveIndex;
  return t === -1 ? null : n[t]
}
function eg() {
  return De.lFrame.currentQueryIndex
}
function du(n) {
  De.lFrame.currentQueryIndex = n
}
function mR(n) {
  let t = n[xe];
  return t.type === 2 ? t.declTNode : t.type === 1 ? n[Xt] : null
}
function Fw(n, t, e) {
  if (e & ke.SkipSelf) {
    let r = t, o = n;
    for (; r = r.parent, r === null && !(e & ke.Host);)
      if (r = mR(o), r === null || (o = o[Cs], r.type & 10)) break;
    if (r === null) return !1;
    t = r, n = o
  }
  let i = De.lFrame = Lw();
  return i.currentTNode = t, i.lView = n, !0
}
function tg(n) {
  let t = Lw(), e = n[xe];
  De.lFrame = t, t.currentTNode = e.firstChild, t.lView = n, t.tView = e,
  t.contextLView = n, t.bindingIndex = e.bindingStartIndex, t.inI18n = !1
}
function Lw() {
  let n = De.lFrame, t = n === null ? null : n.child;
  return t === null ? Vw(n) : t
}
function Vw(n) {
  let t = {
    currentTNode: null,
    isParent: !0,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent: n,
    child: null,
    inI18n: !1
  };
  return n !== null && (n.child = t), t
}
function jw() {
  let n = De.lFrame;
  return De.lFrame = n.parent, n.currentTNode = null, n.lView = null, n
}
var Bw = jw;
function ng() {
  let n = jw();
  n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null,
  n.elementDepthCount = 0, n.currentDirectiveIndex = -1,
  n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1,
  n.currentQueryIndex = 0
}
function hR(n) {
  return (De.lFrame.contextLView = KT(n, De.lFrame.contextLView))[gt]
}
function _r() {
  return De.lFrame.selectedIndex
}
function ho(n) {
  De.lFrame.selectedIndex = n
}
function uu() {
  let n = De.lFrame;
  return Qp(n.tView, n.selectedIndex)
}
function Bt() {
  De.lFrame.currentNamespace = Ew
}
function wo() {
  fR()
}
function fR() {
  De.lFrame.currentNamespace = null
}
function pR() {
  return De.lFrame.currentNamespace
}
var zw = !0;
function mu() {
  return zw
}
function hu(n) {
  zw = n
}
function gR(n, t, e) {
  let {ngOnChanges: i, ngOnInit: r, ngDoCheck: o} = t.type.prototype;
  if (i) {
    let s = xw(t);
    (e.preOrderHooks ??= []).push(n, s),
        (e.preOrderCheckHooks ??= []).push(n, s)
  }
  r && (e.preOrderHooks ??= []).push(0 - n, r),
      o &&
      ((e.preOrderHooks ??= []).push(n, o),
       (e.preOrderCheckHooks ??= []).push(n, o))
}
function ig(n, t) {
  for (let e = t.directiveStart, i = t.directiveEnd; e < i; e++) {
    let o = n.data[e].type.prototype, {
      ngAfterContentInit: s,
      ngAfterContentChecked: a,
      ngAfterViewInit: l,
      ngAfterViewChecked: c,
      ngOnDestroy: d
    } = o;
    s && (n.contentHooks ??= []).push(-e, s),
        a &&
        ((n.contentHooks ??= []).push(e, a),
         (n.contentCheckHooks ??= []).push(e, a)),
        l && (n.viewHooks ??= []).push(-e, l),
        c &&
        ((n.viewHooks ??= []).push(e, c), (n.viewCheckHooks ??= []).push(e, c)),
        d != null && (n.destroyHooks ??= []).push(e, d)
  }
}
function bd(n, t, e) {
  Hw(n, t, 3, e)
}
function vd(n, t, e, i) {
  (n[be] & 3) === e && Hw(n, t, e, i)
}
function Df(n, t) {
  let e = n[be];
  (e & 3) === t && (e &= 16383, e += 1, n[be] = e)
}
function Hw(n, t, e, i) {
  let r = i !== void 0 ? n[ds] & 65535 : 0, o = i ?? -1, s = t.length - 1,
      a = 0;
  for (let l = r; l < s; l++)
    if (typeof t[l + 1] == 'number') {
      if (a = t[l], i != null && a >= i) break
    } else
      t[l] < 0 && (n[ds] += 65536),
          (a < o || o == -1) &&
          (_R(n, e, t, l), n[ds] = (n[ds] & 4294901760) + l + 2),
          l++
}
function h0(n, t) {
  Qe(4, n, t);
  let e = Me(null);
  try {
    t.call(n)
  } finally {
    Me(e), Qe(5, n, t)
  }
}
function _R(n, t, e, i) {
  let r = e[i] < 0, o = e[i + 1], s = r ? -e[i] : e[i], a = n[s];
  r ? n[be] >> 14 < n[ds] >> 16 && (n[be] & 3) === t &&
          (n[be] += 16384, h0(a, o)) :
      h0(a, o)
}
var fs = -1, fo = class {
  factory;
  injectImpl;
  resolving = !1;
  canSeeViewProviders;
  multi;
  componentProviders;
  index;
  providerFactory;
  constructor(t, e, i) {
    this.factory = t, this.canSeeViewProviders = e, this.injectImpl = i
  }
};
function bR(n) {
  return (n.flags & 8) !== 0
}
function vR(n) {
  return (n.flags & 16) !== 0
}
function yR(n, t, e) {
  let i = 0;
  for (; i < e.length;) {
    let r = e[i];
    if (typeof r == 'number') {
      if (r !== 0) break;
      i++;
      let o = e[i++], s = e[i++], a = e[i++];
      n.setAttribute(t, s, a, o)
    } else {
      let o = r, s = e[++i];
      wR(o) ? n.setProperty(t, o, s) : n.setAttribute(t, o, s), i++
    }
  }
  return i
}
function Uw(n) {
  return n === 3 || n === 4 || n === 6
}
function wR(n) {
  return n.charCodeAt(0) === 64
}
function vs(n, t) {
  if (!(t === null || t.length === 0))
    if (n === null || n.length === 0)
      n = t.slice();
    else {
      let e = -1;
      for (let i = 0; i < t.length; i++) {
        let r = t[i];
        typeof r == 'number' ? e = r :
                               e === 0 ||
                (e === -1 || e === 2 ? f0(n, e, r, null, t[++i]) :
                                       f0(n, e, r, null, null))
      }
    }
  return n
}
function f0(n, t, e, i, r) {
  let o = 0, s = n.length;
  if (t === -1)
    s = -1;
  else
    for (; o < n.length;) {
      let a = n[o++];
      if (typeof a == 'number') {
        if (a === t) {
          s = -1;
          break
        } else if (a > t) {
          s = o - 1;
          break
        }
      }
    }
  for (; o < n.length;) {
    let a = n[o];
    if (typeof a == 'number') break;
    if (a === e) {
      r !== null && (n[o + 1] = r);
      return
    }
    o++, r !== null && o++
  }
  s !== -1 && (n.splice(s, 0, t), o = s + 1), n.splice(o++, 0, e),
      r !== null && n.splice(o++, 0, r)
}
var Ef = {}, qf = class {
  injector;
  parentInjector;
  constructor(t, e) {
    this.injector = t, this.parentInjector = e
  }
  get(t, e, i) {
    i = tu(i);
    let r = this.injector.get(t, Ef, i);
    return r !== Ef || e === Ef ? r : this.parentInjector.get(t, e, i)
  }
};
function $w(n) {
  return n !== fs
}
function Rd(n) {
  return n & 32767
}
function xR(n) {
  return n >> 16
}
function Ad(n, t) {
  let e = xR(n), i = t;
  for (; e > 0;) i = i[Cs], e--;
  return i
}
var Gf = !0;
function Od(n) {
  let t = Gf;
  return Gf = n, t
}
var CR = 256, Ww = CR - 1, qw = 5, DR = 0, ti = {};
function ER(n, t, e) {
  let i;
  typeof e == 'string' ? i = e.charCodeAt(0) || 0 :
                         e.hasOwnProperty(Ha) && (i = e[Ha]),
                         i == null && (i = e[Ha] = DR++);
  let r = i & Ww, o = 1 << r;
  t.data[n + (r >> qw)] |= o
}
function Nd(n, t) {
  let e = Gw(n, t);
  if (e !== -1) return e;
  let i = t[xe];
  i.firstCreatePass &&
      (n.injectorIndex = t.length, kf(i.data, n), kf(t, null),
       kf(i.blueprint, null));
  let r = rg(n, t), o = n.injectorIndex;
  if ($w(r)) {
    let s = Rd(r), a = Ad(r, t), l = a[xe].data;
    for (let c = 0; c < 8; c++) t[o + c] = a[s + c] | l[s + c]
  }
  return t[o + 8] = r, o
}
function kf(n, t) {
  n.push(0, 0, 0, 0, 0, 0, 0, 0, t)
}
function Gw(n, t) {
  return n.injectorIndex === -1 ||
          n.parent && n.parent.injectorIndex === n.injectorIndex ||
          t[n.injectorIndex + 8] === null ?
      -1 :
      n.injectorIndex
}
function rg(n, t) {
  if (n.parent && n.parent.injectorIndex !== -1) return n.parent.injectorIndex;
  let e = 0, i = null, r = t;
  for (; r !== null;) {
    if (i = Xw(r), i === null) return fs;
    if (e++, r = r[Cs], i.injectorIndex !== -1) return i.injectorIndex | e << 16
  }
  return fs
}
function Qf(n, t, e) {
  ER(n, t, e)
}
function kR(n, t) {
  if (t === 'class') return n.classes;
  if (t === 'style') return n.styles;
  let e = n.attrs;
  if (e) {
    let i = e.length, r = 0;
    for (; r < i;) {
      let o = e[r];
      if (Uw(o)) break;
      if (o === 0)
        r = r + 2;
      else if (typeof o == 'number')
        for (r++; r < i && typeof e[r] == 'string';) r++;
      else {
        if (o === t) return e[r + 1];
        r = r + 2
      }
    }
  }
  return null
}
function Qw(n, t, e) {
  if (e & ke.Optional || n !== void 0) return n;
  $p(t, 'NodeInjector')
}
function Yw(n, t, e, i) {
  if (e & ke.Optional && i === void 0 && (i = null),
      (e & (ke.Self | ke.Host)) === 0) {
    let r = n[Wa], o = qt(void 0);
    try {
      return r ? r.get(t, i, e & ke.Optional) : aw(t, i, e & ke.Optional)
    } finally {
      qt(o)
    }
  }
  return Qw(i, t, e)
}
function Zw(n, t, e, i = ke.Default, r) {
  if (n !== null) {
    if (t[be] & 2048 && !(i & ke.Self)) {
      let s = TR(n, t, e, i, ti);
      if (s !== ti) return s
    }
    let o = Kw(n, t, e, i, ti);
    if (o !== ti) return o
  }
  return Yw(t, e, i, r)
}
function Kw(n, t, e, i, r) {
  let o = IR(e);
  if (typeof o == 'function') {
    if (!Fw(t, n, i)) return i & ke.Host ? Qw(r, e, i) : Yw(t, e, i, r);
    try {
      let s;
      if (s = o(i), s == null && !(i & ke.Optional))
        $p(e);
      else
        return s
    } finally {
      Bw()
    }
  } else if (typeof o == 'number') {
    let s = null, a = Gw(n, t), l = fs, c = i & ke.Host ? t[an][Xt] : null;
    for ((a === -1 || i & ke.SkipSelf) &&
             (l = a === -1 ? rg(n, t) : t[a + 8],
             l === fs || !g0(i, !1) ? a = -1 :
                                      (s = t[xe], a = Rd(l), t = Ad(l, t)));
         a !== -1;) {
      let d = t[xe];
      if (p0(o, a, d.data)) {
        let m = SR(a, t, e, s, i, c);
        if (m !== ti) return m
      }
      l = t[a + 8],
      l !== fs && g0(i, t[xe].data[a + 8] === c) && p0(o, a, t) ?
          (s = d, a = Rd(l), t = Ad(l, t)) :
          a = -1
    }
  }
  return r
}
function SR(n, t, e, i, r, o) {
  let s = t[xe], a = s.data[n + 8],
      l = i == null ? Ds(a) && Gf : i != s && (a.type & 3) !== 0,
      c = r & ke.Host && o === a, d = yd(a, s, e, l, c);
  return d !== null ? Ga(t, s, d, a) : ti
}
function yd(n, t, e, i, r) {
  let o = n.providerIndexes, s = t.data, a = o & 1048575, l = n.directiveStart,
      c = n.directiveEnd, d = o >> 20, m = i ? a : a + d, p = r ? a + d : c;
  for (let h = m; h < p; h++) {
    let _ = s[h];
    if (h < l && e === _ || h >= l && _.type === e) return h
  }
  if (r) {
    let h = s[l];
    if (h && ii(h) && h.type === e) return l
  }
  return null
}
function Ga(n, t, e, i) {
  let r = n[e], o = t.data;
  if (r instanceof fo) {
    let s = r;
    s.resolving && ow(bT(o[e]));
    let a = Od(s.canSeeViewProviders);
    s.resolving = !0;
    let l, c = s.injectImpl ? qt(s.injectImpl) : null, d = Fw(n, i, ke.Default);
    try {
      r = n[e] = s.factory(void 0, o, n, i),
      t.firstCreatePass && e >= i.directiveStart && gR(e, o[e], t)
    } finally {
      c !== null && qt(c), Od(a), s.resolving = !1, Bw()
    }
  }
  return r
}
function IR(n) {
  if (typeof n == 'string') return n.charCodeAt(0) || 0;
  let t = n.hasOwnProperty(Ha) ? n[Ha] : void 0;
  return typeof t == 'number' ? t >= 0 ? t & Ww : MR : t
}
function p0(n, t, e) {
  let i = 1 << n;
  return !!(e[t + (n >> qw)] & i)
}
function g0(n, t) {
  return !(n & ke.Self) && !(n & ke.Host && t)
}
var so = class {
  _tNode;
  _lView;
  constructor(t, e) {
    this._tNode = t, this._lView = e
  }
  get(t, e, i) {
    return Zw(this._tNode, this._lView, t, tu(i), e)
  }
};
function MR() {
  return new so(Nt(), ve())
}
function Te(n) {
  return Xa(() => {
    let t = n.prototype.constructor, e = t[xd] || Yf(t), i = Object.prototype,
        r = Object.getPrototypeOf(n.prototype).constructor;
    for (; r && r !== i;) {
      let o = r[xd] || Yf(r);
      if (o && o !== e) return o;
      r = Object.getPrototypeOf(r)
    }
    return o => new o
  })
}
function Yf(n) {
  return ew(n) ? () => {
    let t = Yf(Dt(n));
    return t && t()
  } : ao(n)
}
function TR(n, t, e, i, r) {
  let o = n, s = t;
  for (; o !== null && s !== null && s[be] & 2048 && !Md(s);) {
    let a = Kw(o, s, e, i | ke.Self, ti);
    if (a !== ti) return a;
    let l = o.parent;
    if (!l) {
      let c = s[vw];
      if (c) {
        let d = c.get(e, ti, i);
        if (d !== ti) return d
      }
      l = Xw(s), s = s[Cs]
    }
    o = l
  }
  return r
}
function Xw(n) {
  let t = n[xe], e = t.type;
  return e === 2 ? t.declTNode : e === 1 ? n[Xt] : null
}
function og(n) {
  return kR(Nt(), n)
}
function _0(n, t = null, e = null, i) {
  let r = Jw(n, t, e, i);
  return r.resolveInjectorInitializers(), r
}
function Jw(n, t = null, e = null, i, r = new Set) {
  let o = [e || jt, OT(n)];
  return i = i || (typeof n == 'object' ? void 0 : Gt(n)),
         new $a(o, t || ou(), i || null, r)
}
var he = class n {
  static THROW_IF_NOT_FOUND = oo;
  static NULL = new kd;
  static create(t, e) {
    if (Array.isArray(t)) return _0({name: ''}, e, t, '');
    {
      let i = t.name ?? '';
      return _0({name: i}, t.parent, t.providers, i)
    }
  }
  static \u0275prov = C({token: n, providedIn: 'any', factory: () => A(dw)});
  static __NG_ELEMENT_ID__ = -1
};
var Qt = class {
  attributeName;
  constructor(t) {
    this.attributeName = t
  }
  __NG_ELEMENT_ID__ = () => og(this.attributeName);
  toString() {
    return `HostAttributeToken ${this.attributeName}`
  }
}
, RR = new w('');
RR.__NG_ELEMENT_ID__ = n => {
  let t = Nt();
  if (t === null) throw new S(204, !1);
  if (t.type & 2) return t.value;
  if (n & ke.Optional) return null;
  throw new S(204, !1)
};
var ex = !1, ks = (() => {
               class n {
                 static __NG_ELEMENT_ID__ = AR;
                 static __NG_ENV_ID__ = e => e
               } return n
             })(),
    Pd = class extends ks {
  _lView;
  constructor(t) {
    super(), this._lView = t
  }
  onDestroy(t) {
    return Mw(this._lView, t), () => XT(this._lView, t)
  }
};
function AR() {
  return new Pd(ve())
}
var po = class {}
, sg = new w('', {providedIn: 'root', factory: () => !1});
var tx = new w(''), nx = new w(''),
    zi = (() => {
      class n {
        taskId = 0;
        pendingTasks = new Set;
        get _hasPendingTasks() {
          return this.hasPendingTasks.value
        }
        hasPendingTasks = new Le(!1);
        add() {
          this._hasPendingTasks || this.hasPendingTasks.next(!0);
          let e = this.taskId++;
          return this.pendingTasks.add(e), e
        }
        has(e) {
          return this.pendingTasks.has(e)
        }
        remove(e) {
          this.pendingTasks.delete(e),
              this.pendingTasks.size === 0 && this._hasPendingTasks &&
              this.hasPendingTasks.next(!1)
        }
        ngOnDestroy() {
          this.pendingTasks.clear(),
              this._hasPendingTasks && this.hasPendingTasks.next(!1)
        }
        static \u0275prov =
            C({token: n, providedIn: 'root', factory: () => new n})
      } return n
    })();
var Zf = class extends I {
  __isAsync;
  destroyRef = void 0;
  pendingTasks = void 0;
  constructor(t = !1) {
    super(), this.__isAsync = t,
             bw() &&
        (this.destroyRef = u(ks, {optional: !0}) ?? void 0,
         this.pendingTasks = u(zi, {optional: !0}) ?? void 0)
  }
  emit(t) {
    let e = Me(null);
    try {
      super.next(t)
    } finally {
      Me(e)
    }
  }
  subscribe(t, e, i) {
    let r = t, o = e || (() => null), s = i;
    if (t && typeof t == 'object') {
      let l = t;
      r = l.next?.bind(l), o = l.error?.bind(l), s = l.complete?.bind(l)
    }
    this.__isAsync &&
        (o = this.wrapInTimeout(o), r && (r = this.wrapInTimeout(r)),
         s && (s = this.wrapInTimeout(s)));
    let a = super.subscribe({next: r, error: o, complete: s});
    return t instanceof ge && t.add(a), a
  }
  wrapInTimeout(t) {
    return e => {
      let i = this.pendingTasks?.add();
      setTimeout(() => {t(e), i !== void 0 && this.pendingTasks?.remove(i)})
    }
  }
}
, H = Zf;
function Qa(...n) {}
function ix(n) {
  let t, e;
  function i() {
    n = Qa;
    try {
      e !== void 0 && typeof cancelAnimationFrame == 'function' &&
          cancelAnimationFrame(e),
          t !== void 0 && clearTimeout(t)
    } catch {
    }
  }
  return t = setTimeout(() => {n(), i()}),
         typeof requestAnimationFrame == 'function' &&
             (e = requestAnimationFrame(() => {n(), i()})),
         () => i()
}
function b0(n) {
  return queueMicrotask(() => n()), () => {
    n = Qa
  }
}
var ag = 'isAngularZone', Fd = ag + '_ID', OR = 0, U = class n {
  hasPendingMacrotasks = !1;
  hasPendingMicrotasks = !1;
  isStable = !0;
  onUnstable = new H(!1);
  onMicrotaskEmpty = new H(!1);
  onStable = new H(!1);
  onError = new H(!1);
  constructor(t) {
    let {
      enableLongStackTrace: e = !1,
      shouldCoalesceEventChangeDetection: i = !1,
      shouldCoalesceRunChangeDetection: r = !1,
      scheduleInRootZone: o = ex
    } = t;
    if (typeof Zone > 'u') throw new S(908, !1);
    Zone.assertZonePatched();
    let s = this;
    s._nesting = 0, s._outer = s._inner = Zone.current,
    Zone.TaskTrackingZoneSpec &&
        (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)),
    e && Zone.longStackTraceZoneSpec &&
        (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)),
    s.shouldCoalesceEventChangeDetection = !r && i,
    s.shouldCoalesceRunChangeDetection = r, s.callbackScheduled = !1,
    s.scheduleInRootZone = o, FR(s)
  }
  static isInAngularZone() {
    return typeof Zone < 'u' && Zone.current.get(ag) === !0
  }
  static assertInAngularZone() {
    if (!n.isInAngularZone()) throw new S(909, !1)
  }
  static assertNotInAngularZone() {
    if (n.isInAngularZone()) throw new S(909, !1)
  }
  run(t, e, i) {
    return this._inner.run(t, e, i)
  }
  runTask(t, e, i, r) {
    let o = this._inner,
        s = o.scheduleEventTask('NgZoneEvent: ' + r, t, NR, Qa, Qa);
    try {
      return o.runTask(s, e, i)
    } finally {
      o.cancelTask(s)
    }
  }
  runGuarded(t, e, i) {
    return this._inner.runGuarded(t, e, i)
  }
  runOutsideAngular(t) {
    return this._outer.run(t)
  }
}
, NR = {};
function lg(n) {
  if (n._nesting == 0 && !n.hasPendingMicrotasks && !n.isStable) try {
      n._nesting++, n.onMicrotaskEmpty.emit(null)
    } finally {
      if (n._nesting--, !n.hasPendingMicrotasks) try {
          n.runOutsideAngular(() => n.onStable.emit(null))
        } finally {
          n.isStable = !0
        }
    }
}
function PR(n) {
  if (n.isCheckStableRunning || n.callbackScheduled) return;
  n.callbackScheduled = !0;
  function t() {
    ix(() => {
      n.callbackScheduled = !1,
      Kf(n),
      n.isCheckStableRunning = !0,
      lg(n),
      n.isCheckStableRunning = !1
    })
  }
  n.scheduleInRootZone ? Zone.root.run(() => {t()}) : n._outer.run(() => {t()}),
      Kf(n)
}
function FR(n) {
  let t = () => {
    PR(n)
  }, e = OR++;
  n._inner = n._inner.fork({
    name: 'angular',
    properties: {[ag]: !0, [Fd]: e, [Fd + e]: !0},
    onInvokeTask: (i, r, o, s, a, l) => {
      if (LR(l)) return i.invokeTask(o, s, a, l);
      try {
        return v0(n), i.invokeTask(o, s, a, l)
      } finally {
        (n.shouldCoalesceEventChangeDetection && s.type === 'eventTask' ||
         n.shouldCoalesceRunChangeDetection) &&
            t(),
            y0(n)
      }
    },
    onInvoke: (i, r, o, s, a, l, c) => {
      try {
        return v0(n), i.invoke(o, s, a, l, c)
      } finally {
        n.shouldCoalesceRunChangeDetection && !n.callbackScheduled && !VR(l) &&
            t(),
            y0(n)
      }
    },
    onHasTask: (i, r, o, s) => {
      i.hasTask(o, s),
      r === o &&
          (s.change == 'microTask' ?
               (n._hasPendingMicrotasks = s.microTask, Kf(n), lg(n)) :
               s.change == 'macroTask' &&
                   (n.hasPendingMacrotasks = s.macroTask))
    },
    onHandleError: (i, r, o, s) =>
        (i.handleError(o, s), n.runOutsideAngular(() => n.onError.emit(s)), !1)
  })
}
function Kf(n) {
  n._hasPendingMicrotasks ||
          (n.shouldCoalesceEventChangeDetection ||
           n.shouldCoalesceRunChangeDetection) && n.callbackScheduled === !0 ?
      n.hasPendingMicrotasks = !0 :
      n.hasPendingMicrotasks = !1
}
function v0(n) {
  n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null))
}
function y0(n) {
  n._nesting--, lg(n)
}
var Ld = class {
  hasPendingMicrotasks = !1;
  hasPendingMacrotasks = !1;
  isStable = !0;
  onUnstable = new H;
  onMicrotaskEmpty = new H;
  onStable = new H;
  onError = new H;
  run(t, e, i) {
    return t.apply(e, i)
  }
  runGuarded(t, e, i) {
    return t.apply(e, i)
  }
  runOutsideAngular(t) {
    return t()
  }
  runTask(t, e, i, r) {
    return t.apply(e, i)
  }
};
function LR(n) {
  return rx(n, '__ignore_ng_zone__')
}
function VR(n) {
  return rx(n, '__scheduler_tick__')
}
function rx(n, t) {
  return !Array.isArray(n) || n.length !== 1 ? !1 : n[0]?.data?.[t] === !0
}
function jR(n = 'zone.js', t) {
  return n === 'noop' ? new Ld : n === 'zone.js' ? new U(t) : n
}
var ln = class {
  _console = console;
  handleError(t) {
    this._console.error('ERROR', t)
  }
}
, BR = new w('', {
    providedIn: 'root',
    factory: () => {
      let n = u(U), t = u(ln);
      return e => n.runOutsideAngular(() => t.handleError(e))
    }
  });
function w0(n, t) {
  return X0(n, t)
}
function zR(n) {
  return X0(K0, n)
}
var ox = (w0.required = zR, w0);
function HR() {
  return Ss(Nt(), ve())
}
function Ss(n, t) {
  return new L(ci(n, t))
}
var L = (() => {
  class n {
    nativeElement;
    constructor(e) {
      this.nativeElement = e
    }
    static __NG_ELEMENT_ID__ = HR
  } return n
})();
function sx(n) {
  return n instanceof L ? n.nativeElement : n
}
function br(n) {
  return typeof n == 'function' && n[$t] !== void 0
}
function Jt(n, t) {
  let e = My(n, t?.equal), i = e[$t];
  return e.set = r => Bc(i, r), e.update = r => Ty(i, r),
         e.asReadonly = UR.bind(e), e
}
function UR() {
  let n = this[$t];
  if (n.readonlyFn === void 0) {
    let t = () => this();
    t[$t] = n, n.readonlyFn = t
  }
  return n.readonlyFn
}
function ax(n) {
  return br(n) && typeof n.set == 'function'
}
function $R() {
  return this._results[Symbol.iterator]()
}
var si = class {
  _emitDistinctChangesOnly;
  dirty = !0;
  _onDirty = void 0;
  _results = [];
  _changesDetected = !1;
  _changes = void 0;
  length = 0;
  first = void 0;
  last = void 0;
  get changes() {
    return this._changes ??= new I
  }
  constructor(t = !1) {
    this._emitDistinctChangesOnly = t
  }
  get(t) {
    return this._results[t]
  }
  map(t) {
    return this._results.map(t)
  }
  filter(t) {
    return this._results.filter(t)
  }
  find(t) {
    return this._results.find(t)
  }
  reduce(t, e) {
    return this._results.reduce(t, e)
  }
  forEach(t) {
    this._results.forEach(t)
  }
  some(t) {
    return this._results.some(t)
  }
  toArray() {
    return this._results.slice()
  }
  toString() {
    return this._results.toString()
  }
  reset(t, e) {
    this.dirty = !1;
    let i = IT(t);
    (this._changesDetected = !ST(this._results, i, e)) &&
        (this._results = i, this.length = i.length,
         this.last = i[this.length - 1], this.first = i[0])
  }
  notifyOnChanges() {
    this._changes !== void 0 &&
        (this._changesDetected || !this._emitDistinctChangesOnly) &&
        this._changes.next(this)
  }
  onDirty(t) {
    this._onDirty = t
  }
  setDirty() {
    this.dirty = !0, this._onDirty?.()
  }
  destroy() {
    this._changes !== void 0 &&
        (this._changes.complete(), this._changes.unsubscribe())
  }
  [Symbol.iterator] = $R
};
function lx(n) {
  return (n.flags & 128) === 128
}
var cx = function(n) {
  return n[n.OnPush = 0] = 'OnPush', n[n.Default = 1] = 'Default', n
}(cx || {}), dx = new Map, WR = 0;
function qR() {
  return WR++
}
function GR(n) {
  dx.set(n[au], n)
}
function Xf(n) {
  dx.delete(n[au])
}
var x0 = '__ngContext__';
function Is(n, t) {
  hr(t) ? (n[x0] = t[au], GR(t)) : n[x0] = t
}
function ux(n) {
  return hx(n[qa])
}
function mx(n) {
  return hx(n[Nn])
}
function hx(n) {
  for (; n !== null && !Bi(n);) n = n[Nn];
  return n
}
var Jf;
function fx(n) {
  Jf = n
}
function QR() {
  if (Jf !== void 0) return Jf;
  if (typeof document < 'u') return document;
  throw new S(210, !1)
}
var Ms = new w('', {providedIn: 'root', factory: () => YR}), YR = 'ng',
    cg = new w(''),
    Fn = new w('', {providedIn: 'platform', factory: () => 'unknown'});
var Ve = new w(''), il = new w('', {
                      providedIn: 'root',
                      factory: () => QR().body?.querySelector('[ngCspNonce]')
                                         ?.getAttribute('ngCspNonce') ||
                          null
                    });
var ZR = 'h', KR = 'b';
var px = !1, XR = new w('', {providedIn: 'root', factory: () => px});
var dg = function(n) {
  return n[n.CHANGE_DETECTION = 0] = 'CHANGE_DETECTION',
                                n[n.AFTER_NEXT_RENDER = 1] =
                                    'AFTER_NEXT_RENDER',
                                n
}(dg || {}), Ts = new w(''), C0 = new Set;
function vr(n) {
  C0.has(n) ||
      (C0.add(n),
       performance?.mark?.('mark_feature_usage', {detail: {feature: n}}))
}
var ug = (() => {
  class n {
    view;
    node;
    constructor(e, i) {
      this.view = e, this.node = i
    }
    static __NG_ELEMENT_ID__ = JR
  } return n
})();
function JR() {
  return new ug(ve(), Nt())
}
var us =
        function(n) {
  return n[n.EarlyRead = 0] = 'EarlyRead', n[n.Write = 1] = 'Write',
                         n[n.MixedReadWrite = 2] = 'MixedReadWrite',
                         n[n.Read = 3] = 'Read', n
}(us || {}),
    gx = (() => {
      class n {
        impl = null;
        execute() {
          this.impl?.execute()
        }
        static \u0275prov =
            C({token: n, providedIn: 'root', factory: () => new n})
      } return n
    })(),
    eA = [us.EarlyRead, us.Write, us.MixedReadWrite, us.Read],
    tA = (() => {
      class n {
        ngZone = u(U);
        scheduler = u(po);
        errorHandler = u(ln, {optional: !0});
        sequences = new Set;
        deferredRegistrations = new Set;
        executing = !1;
        constructor() {
          u(Ts, {optional: !0})
        }
        execute() {
          let e = this.sequences.size > 0;
          e && Qe(16), this.executing = !0;
          for (let i of eA)
            for (let r of this.sequences)
              if (!(r.erroredOrDestroyed || !r.hooks[i])) try {
                  r.pipelinedValue = this.ngZone.runOutsideAngular(
                      () => this.maybeTrace(() => {
                        let o = r.hooks[i];
                        return o(r.pipelinedValue)
                      }, r.snapshot))
                } catch (o) {
                  r.erroredOrDestroyed = !0, this.errorHandler?.handleError(o)
                }
          this.executing = !1;
          for (let i of this.sequences)
            i.afterRun(), i.once && (this.sequences.delete(i), i.destroy());
          for (let i of this.deferredRegistrations) this.sequences.add(i);
          this.deferredRegistrations.size > 0 && this.scheduler.notify(7),
              this.deferredRegistrations.clear(), e && Qe(17)
        }
        register(e) {
          let {view: i} = e;
          i !== void 0       ? ((i[hs] ??= []).push(e), Es(i), i[be] |= 8192) :
              this.executing ? this.deferredRegistrations.add(e) :
                               this.addSequence(e)
        }
        addSequence(e) {
          this.sequences.add(e), this.scheduler.notify(7)
        }
        unregister(e) {
          this.executing && this.sequences.has(e) ?
              (e.erroredOrDestroyed = !0, e.pipelinedValue = void 0,
               e.once = !0) :
              (this.sequences.delete(e), this.deferredRegistrations.delete(e))
        }
        maybeTrace(e, i) {
          return i ? i.run(dg.AFTER_NEXT_RENDER, e) : e()
        }
        static \u0275prov =
            C({token: n, providedIn: 'root', factory: () => new n})
      } return n
    })(),
    ep = class {
  impl;
  hooks;
  view;
  once;
  snapshot;
  erroredOrDestroyed = !1;
  pipelinedValue = void 0;
  unregisterOnDestroy;
  constructor(t, e, i, r, o, s = null) {
    this.impl = t, this.hooks = e, this.view = i, this.once = r,
    this.snapshot = s,
    this.unregisterOnDestroy = o?.onDestroy(() => this.destroy())
  }
  afterRun() {
    this.erroredOrDestroyed = !1, this.pipelinedValue = void 0,
    this.snapshot?.dispose(), this.snapshot = null
  }
  destroy() {
    this.impl.unregister(this), this.unregisterOnDestroy?.();
    let t = this.view?.[hs];
    t && (this.view[hs] = t.filter(e => e !== this))
  }
};
function rl(n, t) {
  !t?.injector && su(rl);
  let e = t?.injector ?? u(he);
  return vr('NgAfterRender'), _x(n, e, t, !1)
}
function ht(n, t) {
  !t?.injector && su(ht);
  let e = t?.injector ?? u(he);
  return vr('NgAfterNextRender'), _x(n, e, t, !0)
}
function nA(n, t) {
  if (n instanceof Function) {
    let e = [void 0, void 0, void 0, void 0];
    return e[t] = n, e
  } else
    return [n.earlyRead, n.write, n.mixedReadWrite, n.read]
}
function _x(n, t, e, i) {
  let r = t.get(gx);
  r.impl ??= t.get(tA);
  let o = t.get(Ts, null, {optional: !0}), s = e?.phase ?? us.MixedReadWrite,
      a = e?.manualCleanup !== !0 ? t.get(ks) : null,
      l = t.get(ug, null, {optional: !0}),
      c = new ep(r.impl, nA(n, s), l?.view, i, a, o?.snapshot(null));
  return r.impl.register(c), c
}
var iA = () => null;
function bx(n, t, e = !1) {
  return iA(n, t, e)
}
function vx(n, t) {
  let e = n.contentQueries;
  if (e !== null) {
    let i = Me(null);
    try {
      for (let r = 0; r < e.length; r += 2) {
        let o = e[r], s = e[r + 1];
        if (s !== -1) {
          let a = n.data[s];
          du(o), a.contentQueries(2, t[s], s)
        }
      }
    } finally {
      Me(i)
    }
  }
}
function tp(n, t, e) {
  du(0);
  let i = Me(null);
  try {
    t(n, e)
  } finally {
    Me(i)
  }
}
function mg(n, t, e) {
  if (Gp(t)) {
    let i = Me(null);
    try {
      let r = t.directiveStart, o = t.directiveEnd;
      for (let s = r; s < o; s++) {
        let a = n.data[s];
        if (a.contentQueries) {
          let l = e[s];
          a.contentQueries(1, l, s)
        }
      }
    } finally {
      Me(i)
    }
  }
}
var ai = function(n) {
  return n[n.Emulated = 0] = 'Emulated', n[n.None = 2] = 'None',
                        n[n.ShadowDom = 3] = 'ShadowDom', n
}(ai || {}), hd;
function rA() {
  if (hd === void 0 && (hd = null, Pn.trustedTypes)) try {
      hd = Pn.trustedTypes.createPolicy(
          'angular',
          {createHTML: n => n, createScript: n => n, createScriptURL: n => n})
    } catch {
    }
  return hd
}
function fu(n) {
  return rA()?.createHTML(n) || n
}
var Li = class {
  changingThisBreaksApplicationSecurity;
  constructor(t) {
    this.changingThisBreaksApplicationSecurity = t
  }
  toString() {
    return `SafeValue must use [property]=binding: ${
        this.changingThisBreaksApplicationSecurity} (see ${Z0})`
  }
}
, np = class extends Li {
  getTypeName() {
    return 'HTML'
  }
}
, ip = class extends Li {
  getTypeName() {
    return 'Style'
  }
}
, rp = class extends Li {
  getTypeName() {
    return 'Script'
  }
}
, op = class extends Li {
  getTypeName() {
    return 'URL'
  }
}
, sp = class extends Li {
  getTypeName() {
    return 'ResourceURL'
  }
};
function di(n) {
  return n instanceof Li ? n.changingThisBreaksApplicationSecurity : n
}
function xo(n, t) {
  let e = oA(n);
  if (e != null && e !== t) {
    if (e === 'ResourceURL' && t === 'URL') return !0;
    throw new Error(`Required a safe ${t}, got a ${e} (see ${Z0})`)
  }
  return e === t
}
function oA(n) {
  return n instanceof Li && n.getTypeName() || null
}
function yx(n) {
  return new np(n)
}
function wx(n) {
  return new ip(n)
}
function xx(n) {
  return new rp(n)
}
function Cx(n) {
  return new op(n)
}
function Dx(n) {
  return new sp(n)
}
function sA(n) {
  let t = new lp(n);
  return aA() ? new ap(t) : t
}
var ap = class {
  inertDocumentHelper;
  constructor(t) {
    this.inertDocumentHelper = t
  }
  getInertBodyElement(t) {
    t = '<body><remove></remove>' + t;
    try {
      let e = new window.DOMParser().parseFromString(fu(t), 'text/html').body;
      return e === null ? this.inertDocumentHelper.getInertBodyElement(t) :
                          (e.firstChild?.remove(), e)
    } catch {
      return null
    }
  }
}
, lp = class {
  defaultDoc;
  inertDocument;
  constructor(t) {
    this.defaultDoc = t,
    this.inertDocument =
        this.defaultDoc.implementation.createHTMLDocument('sanitization-inert')
  }
  getInertBodyElement(t) {
    let e = this.inertDocument.createElement('template');
    return e.innerHTML = fu(t), e
  }
};
function aA() {
  try {
    return !!new window.DOMParser().parseFromString(fu(''), 'text/html')
  } catch {
    return !1
  }
}
var lA = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function pu(n) {
  return n = String(n), n.match(lA) ? n : 'unsafe:' + n
}
function Hi(n) {
  let t = {};
  for (let e of n.split(',')) t[e] = !0;
  return t
}
function ol(...n) {
  let t = {};
  for (let e of n)
    for (let i in e) e.hasOwnProperty(i) && (t[i] = !0);
  return t
}
var Ex = Hi('area,br,col,hr,img,wbr'),
    kx = Hi('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'), Sx = Hi('rp,rt'),
    cA = ol(Sx, kx),
    dA = ol(
        kx,
        Hi('address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul')),
    uA = ol(
        Sx,
        Hi('a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video')),
    D0 = ol(Ex, dA, uA, cA),
    Ix = Hi('background,cite,href,itemtype,longdesc,poster,src,xlink:href'),
    mA = Hi('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width'), hA = Hi('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'),
    fA = ol(Ix, mA, hA), pA = Hi('script,style,template'), cp = class {
  sanitizedSomething = !1;
  buf = [];
  sanitizeChildren(t) {
    let e = t.firstChild, i = !0, r = [];
    for (; e;) {
      if (e.nodeType === Node.ELEMENT_NODE  ? i = this.startElement(e) :
              e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) :
                                              this.sanitizedSomething = !0,
          i && e.firstChild) {
        r.push(e), e = bA(e);
        continue
      }
      for (; e;) {
        e.nodeType === Node.ELEMENT_NODE && this.endElement(e);
        let o = _A(e);
        if (o) {
          e = o;
          break
        }
        e = r.pop()
      }
    }
    return this.buf.join('')
  }
  startElement(t) {
    let e = E0(t).toLowerCase();
    if (!D0.hasOwnProperty(e))
      return this.sanitizedSomething = !0, !pA.hasOwnProperty(e);
    this.buf.push('<'), this.buf.push(e);
    let i = t.attributes;
    for (let r = 0; r < i.length; r++) {
      let o = i.item(r), s = o.name, a = s.toLowerCase();
      if (!fA.hasOwnProperty(a)) {
        this.sanitizedSomething = !0;
        continue
      }
      let l = o.value;
      Ix[a] && (l = pu(l)), this.buf.push(' ', s, '="', k0(l), '"')
    }
    return this.buf.push('>'), !0
  }
  endElement(t) {
    let e = E0(t).toLowerCase();
    D0.hasOwnProperty(e) && !Ex.hasOwnProperty(e) &&
        (this.buf.push('</'), this.buf.push(e), this.buf.push('>'))
  }
  chars(t) {
    this.buf.push(k0(t))
  }
};
function gA(n, t) {
  return (n.compareDocumentPosition(t) &
          Node.DOCUMENT_POSITION_CONTAINED_BY) !==
      Node.DOCUMENT_POSITION_CONTAINED_BY
}
function _A(n) {
  let t = n.nextSibling;
  if (t && n !== t.previousSibling) throw Mx(t);
  return t
}
function bA(n) {
  let t = n.firstChild;
  if (t && gA(n, t)) throw Mx(t);
  return t
}
function E0(n) {
  let t = n.nodeName;
  return typeof t == 'string' ? t : 'FORM'
}
function Mx(n) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${
      n.outerHTML}`)
}
var vA = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, yA = /([^\#-~ |!])/g;
function k0(n) {
  return n.replace(/&/g, '&amp;')
      .replace(
          vA,
          function(t) {
            let e = t.charCodeAt(0), i = t.charCodeAt(1);
            return '&#' + ((e - 55296) * 1024 + (i - 56320) + 65536) + ';'
          })
      .replace(
          yA,
          function(t) {
            return '&#' + t.charCodeAt(0) + ';'
          })
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
}
var fd;
function Tx(n, t) {
  let e = null;
  try {
    fd = fd || sA(n);
    let i = t ? String(t) : '';
    e = fd.getInertBodyElement(i);
    let r = 5, o = i;
    do {
      if (r === 0)
        throw new Error(
            'Failed to sanitize html because the input is unstable');
      r--, i = o, o = e.innerHTML, e = fd.getInertBodyElement(i)
    } while (i !== o);
    let a = new cp().sanitizeChildren(S0(e) || e);
    return fu(a)
  } finally {
    if (e) {
      let i = S0(e) || e;
      for (; i.firstChild;) i.firstChild.remove()
    }
  }
}
function S0(n) {
  return 'content' in n && wA(n) ? n.content : null
}
function wA(n) {
  return n.nodeType === Node.ELEMENT_NODE && n.nodeName === 'TEMPLATE'
}
var Et = function(n) {
  return n[n.NONE = 0] = 'NONE', n[n.HTML = 1] = 'HTML',
                    n[n.STYLE = 2] = 'STYLE', n[n.SCRIPT = 3] = 'SCRIPT',
                    n[n.URL = 4] = 'URL',
                    n[n.RESOURCE_URL = 5] = 'RESOURCE_URL', n
}(Et || {});
function yr(n) {
  let t = xA();
  return t ? t.sanitize(Et.URL, n) || '' : xo(n, 'URL') ? di(n) : pu(eu(n))
}
function xA() {
  let n = ve();
  return n && n[Pi].sanitizer
}
var CA = /^>|^->|<!--|-->|--!>|<!-$/g, DA = /(<|>)/g, EA = '\u200B$1\u200B';
function kA(n) {
  return n.replace(CA, t => t.replace(DA, EA))
}
function Rx(n) {
  return n instanceof Function ? n() : n
}
function SA(n, t, e) {
  let i = n.length;
  for (;;) {
    let r = n.indexOf(t, e);
    if (r === -1) return r;
    if (r === 0 || n.charCodeAt(r - 1) <= 32) {
      let o = t.length;
      if (r + o === i || n.charCodeAt(r + o) <= 32) return r
    }
    e = r + 1
  }
}
var Ax = 'ng-template';
function IA(n, t, e, i) {
  let r = 0;
  if (i) {
    for (; r < t.length && typeof t[r] == 'string'; r += 2)
      if (t[r] === 'class' && SA(t[r + 1].toLowerCase(), e, 0) !== -1) return !0
  } else if (hg(n))
    return !1;
  if (r = t.indexOf(1, r), r > -1) {
    let o;
    for (; ++r < t.length && typeof (o = t[r]) == 'string';)
      if (o.toLowerCase() === e) return !0
  }
  return !1
}
function hg(n) {
  return n.type === 4 && n.value !== Ax
}
function MA(n, t, e) {
  let i = n.type === 4 && !e ? Ax : n.value;
  return t === i
}
function TA(n, t, e) {
  let i = 4, r = n.attrs, o = r !== null ? OA(r) : 0, s = !1;
  for (let a = 0; a < t.length; a++) {
    let l = t[a];
    if (typeof l == 'number') {
      if (!s && !An(i) && !An(l)) return !1;
      if (s && An(l)) continue;
      s = !1, i = l | i & 1;
      continue
    }
    if (!s)
      if (i & 4) {
        if (i = 2 | i & 1,
            l !== '' && !MA(n, l, e) || l === '' && t.length === 1) {
          if (An(i)) return !1;
          s = !0
        }
      } else if (i & 8) {
        if (r === null || !IA(n, r, l, e)) {
          if (An(i)) return !1;
          s = !0
        }
      } else {
        let c = t[++a], d = RA(l, r, hg(n), e);
        if (d === -1) {
          if (An(i)) return !1;
          s = !0;
          continue
        }
        if (c !== '') {
          let m;
          if (d > o ? m = '' : m = r[d + 1].toLowerCase(), i & 2 && c !== m) {
            if (An(i)) return !1;
            s = !0
          }
        }
      }
  }
  return An(i) || s
}
function An(n) {
  return (n & 1) === 0
}
function RA(n, t, e, i) {
  if (t === null) return -1;
  let r = 0;
  if (i || !e) {
    let o = !1;
    for (; r < t.length;) {
      let s = t[r];
      if (s === n) return r;
      if (s === 3 || s === 6)
        o = !0;
      else if (s === 1 || s === 2) {
        let a = t[++r];
        for (; typeof a == 'string';) a = t[++r];
        continue
      } else {
        if (s === 4) break;
        if (s === 0) {
          r += 4;
          continue
        }
      }
      r += o ? 1 : 2
    }
    return -1
  } else
    return NA(t, n)
}
function Ox(n, t, e = !1) {
  for (let i = 0; i < t.length; i++)
    if (TA(n, t[i], e)) return !0;
  return !1
}
function AA(n) {
  let t = n.attrs;
  if (t != null) {
    let e = t.indexOf(5);
    if ((e & 1) === 0) return t[e + 1]
  }
  return null
}
function OA(n) {
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (Uw(e)) return t
  }
  return n.length
}
function NA(n, t) {
  let e = n.indexOf(4);
  if (e > -1)
    for (e++; e < n.length;) {
      let i = n[e];
      if (typeof i == 'number') return -1;
      if (i === t) return e;
      e++
    }
  return -1
}
function PA(n, t) {
  e: for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (n.length === i.length) {
      for (let r = 0; r < n.length; r++)
        if (n[r] !== i[r]) continue e;
      return !0
    }
  }
  return !1
}
function I0(n, t) {
  return n ? ':not(' + t.trim() + ')' : t
}
function FA(n) {
  let t = n[0], e = 1, i = 2, r = '', o = !1;
  for (; e < n.length;) {
    let s = n[e];
    if (typeof s == 'string')
      if (i & 2) {
        let a = n[++e];
        r += '[' + s + (a.length > 0 ? '="' + a + '"' : '') + ']'
      } else
        i&8 ? r += '.' + s : i & 4 && (r += ' ' + s);
    else
      r !== '' && !An(s) && (t += I0(o, r), r = ''), i = s, o = o || !An(i);
    e++
  }
  return r !== '' && (t += I0(o, r)), t
}
function LA(n) {
  return n.map(FA).join(',')
}
function VA(n) {
  let t = [], e = [], i = 1, r = 2;
  for (; i < n.length;) {
    let o = n[i];
    if (typeof o == 'string')
      r === 2 ? o !== '' && t.push(o, n[++i]) : r === 8 && e.push(o);
    else {
      if (!An(r)) break;
      r = o
    }
    i++
  }
  return e.length && t.push(1, ...e), t
}
var Ln = {};
function jA(n, t) {
  return n.createText(t)
}
function BA(n, t, e) {
  n.setValue(t, e)
}
function zA(n, t) {
  return n.createComment(kA(t))
}
function Nx(n, t, e) {
  return n.createElement(t, e)
}
function Vd(n, t, e, i, r) {
  n.insertBefore(t, e, i, r)
}
function Px(n, t, e) {
  n.appendChild(t, e)
}
function M0(n, t, e, i, r) {
  i !== null ? Vd(n, t, e, i, r) : Px(n, t, e)
}
function HA(n, t, e) {
  n.removeChild(null, t, e)
}
function UA(n, t, e) {
  n.setAttribute(t, 'style', e)
}
function $A(n, t, e) {
  e === '' ? n.removeAttribute(t, 'class') : n.setAttribute(t, 'class', e)
}
function Fx(n, t, e) {
  let {mergedAttrs: i, classes: r, styles: o} = e;
  i !== null && yR(n, t, i), r !== null && $A(n, t, r),
      o !== null && UA(n, t, o)
}
function fg(n, t, e, i, r, o, s, a, l, c, d) {
  let m = bt + i, p = m + r, h = WA(m, p), _ = typeof c == 'function' ? c() : c;
  return h[xe] = {
    type: n,
    blueprint: h,
    template: e,
    queries: null,
    viewQuery: a,
    declTNode: t,
    data: h.slice().fill(null, m),
    bindingStartIndex: m,
    expandoStartIndex: p,
    hostBindingOpCodes: null,
    firstCreatePass: !0,
    firstUpdatePass: !0,
    staticViewQueries: !1,
    staticContentQueries: !1,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof o == 'function' ? o() : o,
    pipeRegistry: typeof s == 'function' ? s() : s,
    firstChild: null,
    schemas: l,
    consts: _,
    incompleteFirstPass: !1,
    ssrId: d
  }
}
function WA(n, t) {
  let e = [];
  for (let i = 0; i < t; i++) e.push(i < n ? null : Ln);
  return e
}
function qA(n) {
  let t = n.tView;
  return t === null || t.incompleteFirstPass ?
      n.tView =
          fg(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs,
             n.viewQuery, n.schemas, n.consts, n.id) :
      t
}
function pg(n, t, e, i, r, o, s, a, l, c, d) {
  let m = t.blueprint.slice();
  return m[ji] = r, m[be] = i | 4 | 128 | 8 | 64 | 1024,
         (c !== null || n && n[be] & 2048) && (m[be] |= 2048), Sw(m),
         m[At] = m[Cs] = n, m[gt] = e, m[Pi] = s || n && n[Pi],
         m[nt] = a || n && n[nt], m[Wa] = l || n && n[Wa] || null, m[Xt] = o,
         m[au] = qR(), m[_s] = d, m[vw] = c, m[an] = t.type == 2 ? n[an] : m, m
}
function GA(n, t, e) {
  let i = ci(t, n), r = qA(e), o = n[Pi].rendererFactory,
      s =
          gg(n,
             pg(n, r, null, Lx(e), i, t, null, o.createRenderer(i, e), null,
                null, null));
  return n[t.index] = s
}
function Lx(n) {
  let t = 16;
  return n.signals ? t = 4096 : n.onPush && (t = 64), t
}
function Vx(n, t, e, i) {
  if (e === 0) return -1;
  let r = t.length;
  for (let o = 0; o < e; o++) t.push(i), n.blueprint.push(i), n.data.push(null);
  return r
}
function gg(n, t) {
  return n[qa] ? n[u0][Nn] = t : n[qa] = t, n[u0] = t, t
}
function b(n = 1) {
  jx(it(), ve(), _r() + n, !1)
}
function jx(n, t, e, i) {
  if (!i)
    if ((t[be] & 3) === 3) {
      let o = n.preOrderCheckHooks;
      o !== null && bd(t, o, e)
    } else {
      let o = n.preOrderHooks;
      o !== null && vd(t, o, 0, e)
    }
  ho(e)
}
var gu = function(n) {
  return n[n.None = 0] = 'None', n[n.SignalBased = 1] = 'SignalBased',
                    n[n.HasDecoratorInputTransform = 2] =
                        'HasDecoratorInputTransform',
                    n
}(gu || {});
function dp(n, t, e, i) {
  let r = Me(null);
  try {
    let [o, s, a] = n.inputs[e], l = null;
    (s & gu.SignalBased) !== 0 && (l = t[o][$t]),
        l !== null&& l.transformFn !== void 0 ?
        i = l.transformFn(i) :
        a !== null && (i = a.call(t, i)),
        n.setInput !== null ? n.setInput(t, l, i, e, o) : ww(t, l, o, i)
  } finally {
    Me(r)
  }
}
function Bx(n, t, e, i, r) {
  let o = _r(), s = i & 2;
  try {
    ho(-1), s && t.length > bt && jx(n, t, bt, !1), Qe(s ? 2 : 0, r), e(i, r)
  } finally {
    ho(o), Qe(s ? 3 : 1, r)
  }
}
function _u(n, t, e) {
  JA(n, t, e), (e.flags & 64) === 64 && e1(n, t, e)
}
function _g(n, t, e = ci) {
  let i = t.localNames;
  if (i !== null) {
    let r = t.index + 1;
    for (let o = 0; o < i.length; o += 2) {
      let s = i[o + 1], a = s === -1 ? e(t, n) : n[s];
      n[r++] = a
    }
  }
}
function QA(n, t, e, i) {
  let o = i.get(XR, px) || e === ai.ShadowDom, s = n.selectRootElement(t, o);
  return YA(s), s
}
function YA(n) {
  ZA(n)
}
var ZA = () => null;
function KA(n) {
  return n === 'class'   ? 'className' :
      n === 'for'        ? 'htmlFor' :
      n === 'formaction' ? 'formAction' :
      n === 'innerHtml'  ? 'innerHTML' :
      n === 'readonly'   ? 'readOnly' :
      n === 'tabindex'   ? 'tabIndex' :
                           n
}
function bg(n, t, e, i, r, o, s, a) {
  if (!a && yg(t, n, e, i, r)) {
    Ds(t) && XA(e, t.index);
    return
  }
  if (t.type & 3) {
    let l = ci(t, e);
    i = KA(i), r = s != null ? s(r, t.value || '', i) : r,
    o.setProperty(l, i, r)
  } else
    t.type&12
}
function XA(n, t) {
  let e = oi(t, n);
  e[be]&16 || (e[be] |= 64)
}
function JA(n, t, e) {
  let i = e.directiveStart, r = e.directiveEnd;
  Ds(e) && GA(t, e, n.data[i + e.componentOffset]),
      n.firstCreatePass || Nd(e, t);
  let o = e.initialInputs;
  for (let s = i; s < r; s++) {
    let a = n.data[s], l = Ga(t, n, s, e);
    if (Is(l, t), o !== null && r1(t, s - i, l, a, e, o), ii(a)) {
      let c = oi(e.index, t);
      c[gt] = Ga(t, n, s, e)
    }
  }
}
function e1(n, t, e) {
  let i = e.directiveStart, r = e.directiveEnd, o = e.index, s = dR();
  try {
    ho(o);
    for (let a = i; a < r; a++) {
      let l = n.data[a], c = t[a];
      Wf(a),
          (l.hostBindings !== null || l.hostVars !== 0 ||
           l.hostAttrs !== null) &&
          t1(l, c)
    }
  } finally {
    ho(-1), Wf(s)
  }
}
function t1(n, t) {
  n.hostBindings !== null && n.hostBindings(1, t)
}
function vg(n, t) {
  let e = n.directiveRegistry, i = null;
  if (e)
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      Ox(t, o.selectors, !1) && (i ??= [], ii(o) ? i.unshift(o) : i.push(o))
    }
  return i
}
function n1(n, t, e, i, r, o) {
  let s = ci(n, t);
  i1(t[nt], s, o, n.value, e, i, r)
}
function i1(n, t, e, i, r, o, s) {
  if (o == null)
    n.removeAttribute(t, r, e);
  else {
    let a = s == null ? eu(o) : s(o, i || '', r);
    n.setAttribute(t, r, a, e)
  }
}
function r1(n, t, e, i, r, o) {
  let s = o[t];
  if (s !== null)
    for (let a = 0; a < s.length; a += 2) {
      let l = s[a], c = s[a + 1];
      dp(i, e, l, c)
    }
}
function zx(n, t) {
  let e = n[Wa], i = e ? e.get(ln, null) : null;
  i && i.handleError(t)
}
function yg(n, t, e, i, r) {
  let o = n.inputs?.[i], s = n.hostDirectiveInputs?.[i], a = !1;
  if (s)
    for (let l = 0; l < s.length; l += 2) {
      let c = s[l], d = s[l + 1], m = t.data[c];
      dp(m, e[c], d, r), a = !0
    }
  if (o)
    for (let l of o) {
      let c = e[l], d = t.data[l];
      dp(d, c, i, r), a = !0
    }
  return a
}
function o1(n, t) {
  let e = oi(t, n), i = e[xe];
  s1(i, e);
  let r = e[ji];
  r !== null && e[_s] === null && (e[_s] = bx(r, e[Wa])), Qe(18),
      wg(i, e, e[gt]), Qe(19, e[gt])
}
function s1(n, t) {
  for (let e = t.length; e < n.blueprint.length; e++) t.push(n.blueprint[e])
}
function wg(n, t, e) {
  tg(t);
  try {
    let i = n.viewQuery;
    i !== null && tp(1, i, e);
    let r = n.template;
    r !== null && Bx(n, t, r, 1, e),
        n.firstCreatePass && (n.firstCreatePass = !1),
        t[Fi]?.finishViewCreation(n), n.staticContentQueries && vx(n, t),
        n.staticViewQueries && tp(2, n.viewQuery, e);
    let o = n.components;
    o !== null && a1(t, o)
  } catch (i) {
    throw n.firstCreatePass &&
        (n.incompleteFirstPass = !0, n.firstCreatePass = !1),
        i
  } finally {
    t[be] &= -5, ng()
  }
}
function a1(n, t) {
  for (let e = 0; e < t.length; e++) o1(n, t[e])
}
function sl(n, t, e, i) {
  let r = Me(null);
  try {
    let o = t.tView, a = n[be] & 4096 ? 4096 : 16,
        l =
            pg(n, o, e, a, null, t, null, null, i?.injector ?? null,
               i?.embeddedViewInjector ?? null, i?.dehydratedView ?? null),
        c = n[t.index];
    l[lo] = c;
    let d = n[Fi];
    return d !== null && (l[Fi] = d.createEmbeddedView(o)), wg(o, l, e), l
  } finally {
    Me(r)
  }
}
function ys(n, t) {
  return !t || t.firstChild === null || lx(n)
}
var l1;
function xg(n, t) {
  return l1(n, t)
}
var li = function(n) {
  return n[n.Important = 1] = 'Important', n[n.DashCase = 2] = 'DashCase', n
}(li || {});
function Cg(n) {
  return (n.flags & 32) === 32
}
function ms(n, t, e, i, r) {
  if (i != null) {
    let o, s = !1;
    Bi(i) ? o = i : hr(i) && (s = !0, i = i[ji]);
    let a = ri(i);
    n === 0 && e !== null ?
        r == null ? Px(t, e, a) : Vd(t, e, a, r || null, !0) :
        n === 1 && e !== null ? Vd(t, e, a, r || null, !0) :
        n === 2               ? HA(t, a, s) :
                                n === 3 && t.destroyNode(a),
        o != null && b1(t, n, o, e, r)
  }
}
function c1(n, t) {
  Hx(n, t), t[ji] = null, t[Xt] = null
}
function d1(n, t, e, i, r, o) {
  i[ji] = r, i[Xt] = t, yu(n, i, e, 1, r, o)
}
function Hx(n, t) {
  t[Pi].changeDetectionScheduler?.notify(9), yu(n, t, t[nt], 2, null, null)
}
function u1(n) {
  let t = n[qa];
  if (!t) return Sf(n[xe], n);
  for (; t;) {
    let e = null;
    if (hr(t))
      e = t[qa];
    else {
      let i = t[Rt];
      i && (e = i)
    }
    if (!e) {
      for (; t && !t[Nn] && t !== n;) hr(t) && Sf(t[xe], t), t = t[At];
      t === null && (t = n), hr(t) && Sf(t[xe], t), e = t && t[Nn]
    }
    t = e
  }
}
function Dg(n, t) {
  let e = n[bs], i = e.indexOf(t);
  e.splice(i, 1)
}
function bu(n, t) {
  if (tl(t)) return;
  let e = t[nt];
  e.destroyNode && yu(n, t, e, 3, null, null), u1(t)
}
function Sf(n, t) {
  if (tl(t)) return;
  let e = Me(null);
  try {
    t[be] &= -129, t[be] |= 256, t[_n] && Ta(t[_n]), h1(n, t), m1(n, t),
        t[xe].type === 1 && t[nt].destroy();
    let i = t[lo];
    if (i !== null && Bi(t[At])) {
      i !== t[At] && Dg(i, t);
      let r = t[Fi];
      r !== null && r.detachView(n)
    }
    Xf(t)
  } finally {
    Me(e)
  }
}
function m1(n, t) {
  let e = n.cleanup, i = t[Sd];
  if (e !== null)
    for (let s = 0; s < e.length - 1; s += 2)
      if (typeof e[s] == 'string') {
        let a = e[s + 3];
        a >= 0 ? i[a]() : i[-a].unsubscribe(), s += 2
      } else {
        let a = i[e[s + 1]];
        e[s].call(a)
      }
  i !== null && (t[Sd] = null);
  let r = t[mr];
  if (r !== null) {
    t[mr] = null;
    for (let s = 0; s < r.length; s++) {
      let a = r[s];
      a()
    }
  }
  let o = t[co];
  if (o !== null) {
    t[co] = null;
    for (let s of o) s.destroy()
  }
}
function h1(n, t) {
  let e;
  if (n != null && (e = n.destroyHooks) != null)
    for (let i = 0; i < e.length; i += 2) {
      let r = t[e[i]];
      if (!(r instanceof fo)) {
        let o = e[i + 1];
        if (Array.isArray(o))
          for (let s = 0; s < o.length; s += 2) {
            let a = r[o[s]], l = o[s + 1];
            Qe(4, a, l);
            try {
              l.call(a)
            } finally {
              Qe(5, a, l)
            }
          }
        else {
          Qe(4, r, o);
          try {
            o.call(r)
          } finally {
            Qe(5, r, o)
          }
        }
      }
    }
}
function Ux(n, t, e) {
  return f1(n, t.parent, e)
}
function f1(n, t, e) {
  let i = t;
  for (; i !== null && i.type & 168;) t = i, i = t.parent;
  if (i === null) return e[ji];
  if (Ds(i)) {
    let {encapsulation: r} = n.data[i.directiveStart + i.componentOffset];
    if (r === ai.None || r === ai.Emulated) return null
  }
  return ci(i, e)
}
function $x(n, t, e) {
  return g1(n, t, e)
}
function p1(n, t, e) {
  return n.type & 40 ? ci(n, e) : null
}
var g1 = p1, T0;
function vu(n, t, e, i) {
  let r = Ux(n, i, t), o = t[nt], s = i.parent || t[Xt], a = $x(s, i, t);
  if (r != null)
    if (Array.isArray(e))
      for (let l = 0; l < e.length; l++) M0(o, r, e[l], a, !1);
    else
      M0(o, r, e, a, !1);
  T0 !== void 0 && T0(o, i, t, e, r)
}
function za(n, t) {
  if (t !== null) {
    let e = t.type;
    if (e & 3) return ci(t, n);
    if (e & 4) return up(-1, n[t.index]);
    if (e & 8) {
      let i = t.child;
      if (i !== null) return za(n, i);
      {
        let r = n[t.index];
        return Bi(r) ? up(-1, r) : ri(r)
      }
    } else {
      if (e & 128) return za(n, t.next);
      if (e & 32) return xg(t, n)() || ri(n[t.index]);
      {
        let i = Wx(n, t);
        if (i !== null) {
          if (Array.isArray(i)) return i[0];
          let r = mo(n[an]);
          return za(r, i)
        } else
          return za(n, t.next)
      }
    }
  }
  return null
}
function Wx(n, t) {
  if (t !== null) {
    let i = n[an][Xt], r = t.projection;
    return i.projection[r]
  }
  return null
}
function up(n, t) {
  let e = Rt + n + 1;
  if (e < t.length) {
    let i = t[e], r = i[xe].firstChild;
    if (r !== null) return za(i, r)
  }
  return t[uo]
}
function Eg(n, t, e, i, r, o, s) {
  for (; e != null;) {
    if (e.type === 128) {
      e = e.next;
      continue
    }
    let a = i[e.index], l = e.type;
    if (s && t === 0 && (a && Is(ri(a), i), e.flags |= 2), !Cg(e))
      if (l & 8)
        Eg(n, t, e.child, i, r, o, !1), ms(t, n, r, a, o);
      else if (l & 32) {
        let c = xg(e, i), d;
        for (; d = c();) ms(t, n, r, d, o);
        ms(t, n, r, a, o)
      } else
        l&16 ? qx(n, t, i, e, r, o) : ms(t, n, r, a, o);
    e = s ? e.projectionNext : e.next
  }
}
function yu(n, t, e, i, r, o) {
  Eg(e, i, n.firstChild, t, r, o, !1)
}
function _1(n, t, e) {
  let i = t[nt], r = Ux(n, e, t), o = e.parent || t[Xt], s = $x(o, e, t);
  qx(i, 0, t, e, r, s)
}
function qx(n, t, e, i, r, o) {
  let s = e[an], l = s[Xt].projection[i.projection];
  if (Array.isArray(l))
    for (let c = 0; c < l.length; c++) {
      let d = l[c];
      ms(t, n, r, d, o)
    }
  else {
    let c = l, d = s[At];
    lx(i) && (c.flags |= 128), Eg(n, t, c, d, r, o, !0)
  }
}
function b1(n, t, e, i, r) {
  let o = e[uo], s = ri(e);
  o !== s && ms(t, n, i, o, r);
  for (let a = Rt; a < e.length; a++) {
    let l = e[a];
    yu(l[xe], l, n, t, i, o)
  }
}
function v1(n, t, e, i, r) {
  if (t)
    r ? n.addClass(e, i) : n.removeClass(e, i);
  else {
    let o = i.indexOf('-') === -1 ? void 0 : li.DashCase;
    r == null ? n.removeStyle(e, i, o) :
                (typeof r == 'string' && r.endsWith('!important') &&
                     (r = r.slice(0, -10), o |= li.Important),
                 n.setStyle(e, i, r, o))
  }
}
function jd(n, t, e, i, r = !1) {
  for (; e !== null;) {
    if (e.type === 128) {
      e = r ? e.projectionNext : e.next;
      continue
    }
    let o = t[e.index];
    o !== null && i.push(ri(o)), Bi(o) && y1(o, i);
    let s = e.type;
    if (s & 8)
      jd(n, t, e.child, i);
    else if (s & 32) {
      let a = xg(e, t), l;
      for (; l = a();) i.push(l)
    } else if (s & 16) {
      let a = Wx(t, e);
      if (Array.isArray(a))
        i.push(...a);
      else {
        let l = mo(t[an]);
        jd(l[xe], l, a, i, !0)
      }
    }
    e = r ? e.projectionNext : e.next
  }
  return i
}
function y1(n, t) {
  for (let e = Rt; e < n.length; e++) {
    let i = n[e], r = i[xe].firstChild;
    r !== null && jd(i[xe], i, r, t)
  }
  n[uo] !== n[ji] && t.push(n[uo])
}
function Gx(n) {
  if (n[hs] !== null) {
    for (let t of n[hs]) t.impl.addSequence(t);
    n[hs].length = 0
  }
}
var Qx = [];
function w1(n) {
  return n[_n] ?? x1(n)
}
function x1(n) {
  let t = Qx.pop() ?? Object.create(D1);
  return t.lView = n, t
}
function C1(n) {
  n.lView[_n] !== n && (n.lView = null, Qx.push(n))
}
var D1 = ae(y({}, Ko), {
  consumerIsAlwaysLive: !0,
  kind: 'template',
  consumerMarkedDirty: n => {Es(n.lView)},
  consumerOnSignalRead() {
    this.lView[_n] = this
  }
});
function E1(n) {
  let t = n[_n] ?? Object.create(k1);
  return t.lView = n, t
}
var k1 = ae(y({}, Ko), {
  consumerIsAlwaysLive: !0,
  kind: 'template',
  consumerMarkedDirty: n => {
    let t = mo(n.lView);
    for (; t && !Yx(t[xe]);) t = mo(t);
    t && Iw(t)
  },
  consumerOnSignalRead() {
    this.lView[_n] = this
  }
});
function Yx(n) {
  return n.type !== 2
}
function Zx(n) {
  if (n[co] === null) return;
  let t = !0;
  for (; t;) {
    let e = !1;
    for (let i of n[co])
      i.dirty &&
          (e = !0,
           i.zone === null || Zone.current === i.zone ?
               i.run() :
               i.zone.run(() => i.run()));
    t = e && !!(n[be] & 8192)
  }
}
var S1 = 100;
function Kx(n, t = !0, e = 0) {
  let r = n[Pi].rendererFactory, o = !1;
  o || r.begin?.();
  try {
    I1(n, e)
  } catch (s) {
    throw t && zx(n, s), s
  } finally {
    o || r.end?.()
  }
}
function I1(n, t) {
  let e = Nw();
  try {
    Td(!0), mp(n, t);
    let i = 0;
    for (; cu(n);) {
      if (i === S1) throw new S(103, !1);
      i++, mp(n, 1)
    }
  } finally {
    Td(e)
  }
}
function M1(n, t, e, i) {
  if (tl(t)) return;
  let r = t[be], o = !1, s = !1;
  tg(t);
  let a = !0, l = null, c = null;
  o ||
      (Yx(n)             ? (c = w1(t), l = Ma(c)) :
           vy() === null ? (a = !1, c = E1(t), l = Ma(c)) :
                           t[_n] && (Ta(t[_n]), t[_n] = null));
  try {
    Sw(t), aR(n.bindingStartIndex), e !== null && Bx(n, t, e, 2, i);
    let d = (r & 3) === 3;
    if (!o)
      if (d) {
        let h = n.preOrderCheckHooks;
        h !== null && bd(t, h, null)
      } else {
        let h = n.preOrderHooks;
        h !== null && vd(t, h, 0, null), Df(t, 0)
      }
    if (s || T1(t), Zx(t), Xx(t, 0), n.contentQueries !== null && vx(n, t), !o)
      if (d) {
        let h = n.contentCheckHooks;
        h !== null && bd(t, h)
      } else {
        let h = n.contentHooks;
        h !== null && vd(t, h, 1), Df(t, 1)
      }
    A1(n, t);
    let m = n.components;
    m !== null && eC(t, m, 0);
    let p = n.viewQuery;
    if (p !== null && tp(2, p, i), !o)
      if (d) {
        let h = n.viewCheckHooks;
        h !== null && bd(t, h)
      } else {
        let h = n.viewHooks;
        h !== null && vd(t, h, 2), Df(t, 2)
      }
    if (n.firstUpdatePass === !0 && (n.firstUpdatePass = !1), t[Cf]) {
      for (let h of t[Cf]) h();
      t[Cf] = null
    }
    o || (Gx(t), t[be] &= -73)
  } catch (d) {
    throw o || Es(t), d
  } finally {
    c !== null && (Fc(c, l), a && C1(c)), ng()
  }
}
function Xx(n, t) {
  for (let e = ux(n); e !== null; e = mx(e))
    for (let i = Rt; i < e.length; i++) {
      let r = e[i];
      Jx(r, t)
    }
}
function T1(n) {
  for (let t = ux(n); t !== null; t = mx(t)) {
    if (!(t[be] & 2)) continue;
    let e = t[bs];
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      Iw(r)
    }
  }
}
function R1(n, t, e) {
  Qe(18);
  let i = oi(t, n);
  Jx(i, e), Qe(19, i[gt])
}
function Jx(n, t) {
  Zp(n) && mp(n, t)
}
function mp(n, t) {
  let i = n[xe], r = n[be], o = n[_n], s = !!(t === 0 && r & 16);
  if (s ||= !!(r & 64 && t === 0), s ||= !!(r & 1024),
      s ||= !!(o?.dirty && Lc(o)), s ||= !1, o && (o.dirty = !1),
      n[be] &= -9217, s)
    M1(i, n, i.template, n[gt]);
  else if (r & 8192) {
    Zx(n), Xx(n, 1);
    let a = i.components;
    a !== null && eC(n, a, 1), Gx(n)
  }
}
function eC(n, t, e) {
  for (let i = 0; i < t.length; i++) R1(n, t[i], e)
}
function A1(n, t) {
  let e = n.hostBindingOpCodes;
  if (e !== null) try {
      for (let i = 0; i < e.length; i++) {
        let r = e[i];
        if (r < 0)
          ho(~r);
        else {
          let o = r, s = e[++i], a = e[++i];
          cR(s, o);
          let l = t[o];
          Qe(24, l), a(2, l), Qe(25, l)
        }
      }
    } finally {
      ho(-1)
    }
}
function kg(n, t) {
  let e = Nw() ? 64 : 1088;
  for (n[Pi].changeDetectionScheduler?.notify(t); n;) {
    n[be] |= e;
    let i = mo(n);
    if (Md(n) && !i) return n;
    n = i
  }
  return null
}
function tC(n, t, e, i) {
  return [n, !0, 0, t, null, i, null, e, null, null]
}
function nC(n, t) {
  let e = Rt + t;
  if (e < n.length) return n[e]
}
function al(n, t, e, i = !0) {
  let r = t[xe];
  if (O1(r, t, n, e), i) {
    let s = up(e, n), a = t[nt], l = a.parentNode(n[uo]);
    l !== null && d1(r, n[Xt], a, t, l, s)
  }
  let o = t[_s];
  o !== null && o.firstChild !== null && (o.firstChild = null)
}
function iC(n, t) {
  let e = Ya(n, t);
  return e !== void 0 && bu(e[xe], e), e
}
function Ya(n, t) {
  if (n.length <= Rt) return;
  let e = Rt + t, i = n[e];
  if (i) {
    let r = i[lo];
    r !== null && r !== n && Dg(r, i), t > 0 && (n[e - 1][Nn] = i[Nn]);
    let o = Ed(n, Rt + t);
    c1(i[xe], i);
    let s = o[Fi];
    s !== null && s.detachView(o[xe]), i[At] = null, i[Nn] = null, i[be] &= -129
  }
  return i
}
function O1(n, t, e, i) {
  let r = Rt + i, o = e.length;
  i > 0 && (e[r - 1][Nn] = t),
      i < o - Rt ? (t[Nn] = e[r], cw(e, Rt + i, t)) : (e.push(t), t[Nn] = null),
      t[At] = e;
  let s = t[lo];
  s !== null && e !== s && rC(s, t);
  let a = t[Fi];
  a !== null && a.insertView(n), Uf(t), t[be] |= 128
}
function rC(n, t) {
  let e = n[bs], i = t[At];
  if (hr(i))
    n[be] |= 2;
  else {
    let r = i[At][an];
    t[an] !== r && (n[be] |= 2)
  }
  e === null ? n[bs] = [t] : e.push(t)
}
var Za = class {
  _lView;
  _cdRefInjectingView;
  notifyErrorHandler;
  _appRef = null;
  _attachedToViewContainer = !1;
  get rootNodes() {
    let t = this._lView, e = t[xe];
    return jd(e, t, e.firstChild, [])
  }
  constructor(t, e, i = !0) {
    this._lView = t, this._cdRefInjectingView = e, this.notifyErrorHandler = i
  }
  get context() {
    return this._lView[gt]
  }
  set context(t) {
    this._lView[gt] = t
  }
  get destroyed() {
    return tl(this._lView)
  }
  destroy() {
    if (this._appRef)
      this._appRef.detachView(this);
    else if (this._attachedToViewContainer) {
      let t = this._lView[At];
      if (Bi(t)) {
        let e = t[Id], i = e ? e.indexOf(this) : -1;
        i > -1 && (Ya(t, i), Ed(e, i))
      }
      this._attachedToViewContainer = !1
    }
    bu(this._lView[xe], this._lView)
  }
  onDestroy(t) {
    Mw(this._lView, t)
  }
  markForCheck() {
    kg(this._cdRefInjectingView || this._lView, 4)
  }
  detach() {
    this._lView[be] &= -129
  }
  reattach() {
    Uf(this._lView), this._lView[be] |= 128
  }
  detectChanges() {
    this._lView[be] |= 1024, Kx(this._lView, this.notifyErrorHandler)
  }
  checkNoChanges() {}
  attachToViewContainerRef() {
    if (this._appRef) throw new S(902, !1);
    this._attachedToViewContainer = !0
  }
  detachFromAppRef() {
    this._appRef = null;
    let t = Md(this._lView), e = this._lView[lo];
    e !== null && !t && Dg(e, this._lView), Hx(this._lView[xe], this._lView)
  }
  attachToAppRef(t) {
    if (this._attachedToViewContainer) throw new S(902, !1);
    this._appRef = t;
    let e = Md(this._lView), i = this._lView[lo];
    i !== null && !e && rC(i, this._lView), Uf(this._lView)
  }
};
var qe = (() => {
  class n {
    static __NG_ELEMENT_ID__ = F1
  } return n
})(),
    N1 = qe, P1 = class extends N1 {
  _declarationLView;
  _declarationTContainer;
  elementRef;
  constructor(t, e, i) {
    super(), this._declarationLView = t, this._declarationTContainer = e,
             this.elementRef = i
  }
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null
  }
  createEmbeddedView(t, e) {
    return this.createEmbeddedViewImpl(t, e)
  }
  createEmbeddedViewImpl(t, e, i) {
    let r =
        sl(this._declarationLView, this._declarationTContainer, t,
           {embeddedViewInjector: e, dehydratedView: i});
    return new Za(r)
  }
};
function F1() {
  return wu(Nt(), ve())
}
function wu(n, t) {
  return n.type & 4 ? new P1(t, n, Ss(n, t)) : null
}
function ll(n, t, e, i, r) {
  let o = n.data[t];
  if (o === null)
    o = L1(n, t, e, i, r), lR() && (o.flags |= 32);
  else if (o.type & 64) {
    o.type = e, o.value = i, o.attrs = r;
    let s = oR();
    o.injectorIndex = s === null ? -1 : s.injectorIndex
  }
  return vo(o, !0), o
}
function L1(n, t, e, i, r) {
  let o = Ow(), s = Xp(), a = s ? o : o && o.parent,
      l = n.data[t] = j1(n, a, e, t, i, r);
  return V1(n, l, o, s), l
}
function V1(n, t, e, i) {
  n.firstChild === null && (n.firstChild = t),
      e !== null &&
      (i ? e.child == null && t.parent !== null && (e.child = t) :
           e.next === null && (e.next = t, t.prev = e))
}
function j1(n, t, e, i, r, o) {
  let s = t ? t.injectorIndex : -1, a = 0;
  return Aw() && (a |= 128), {
    type: e, index: i, insertBeforeIndex: null, injectorIndex: s,
        directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1,
        componentOffset: -1, propertyBindings: null, flags: a,
        providerIndexes: 0, value: r, attrs: o, mergedAttrs: null,
        localNames: null, initialInputs: null, inputs: null,
        hostDirectiveInputs: null, outputs: null, hostDirectiveOutputs: null,
        directiveToIndex: null, tView: null, next: null, prev: null,
        projectionNext: null, child: null, parent: t, projection: null,
        styles: null, stylesWithoutHost: null, residualStyles: void 0,
        classes: null, classesWithoutHost: null, residualClasses: void 0,
        classBindings: 0, styleBindings: 0
  }
}
var b7 = new RegExp(`^(\\d+)*(${KR}|${ZR})*(.*)`);
var B1 = () => null;
function ws(n, t) {
  return B1(n, t)
}
var z1 = class {}
, oC = class {}
, hp = class {
  resolveComponentFactory(t) {
    throw Error(`No component factory found for ${Gt(t)}.`)
  }
}
, xu = class {
  static NULL = new hp
}
, Ot = class {}
, rt = (() => {
    class n {
      destroyNode = null;
      static __NG_ELEMENT_ID__ = () => H1()
    } return n
  })();
function H1() {
  let n = ve(), t = Nt(), e = oi(t.index, n);
  return (hr(e) ? e : n)[nt]
}
var U1 = (() => {
  class n {
    static \u0275prov = C({token: n, providedIn: 'root', factory: () => null})
  } return n
})();
function fp(n, t, e) {
  let i = e ? n.styles : null, r = e ? n.classes : null, o = 0;
  if (t !== null)
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      if (typeof a == 'number')
        o = a;
      else if (o == 1)
        r = Pf(r, a);
      else if (o == 2) {
        let l = a, c = t[++s];
        i = Pf(i, l + ': ' + c + ';')
      }
    }
  e ? n.styles = i : n.stylesWithoutHost = i,
      e ? n.classes = r : n.classesWithoutHost = r
}
function z(n, t = ke.Default) {
  let e = ve();
  if (e === null) return A(n, t);
  let i = Nt();
  return Zw(i, e, Dt(n), t)
}
function sC() {
  let n = 'invalid';
  throw new Error(n)
}
function Sg(n, t, e, i, r) {
  let o = i === null ? null : {'': -1}, s = r(n, e);
  if (s !== null) {
    let a, l = null, c = null, d = W1(s);
    d === null ? a = s : [a, l, c] = d, Q1(n, t, e, a, o, l, c)
  }
  o !== null && i !== null && $1(e, i, o)
}
function $1(n, t, e) {
  let i = n.localNames = [];
  for (let r = 0; r < t.length; r += 2) {
    let o = e[t[r + 1]];
    if (o == null) throw new S(-301, !1);
    i.push(t[r], o)
  }
}
function W1(n) {
  let t = null, e = !1;
  for (let s = 0; s < n.length; s++) {
    let a = n[s];
    if (s === 0 && ii(a) && (t = a), a.findHostDirectiveDefs !== null) {
      e = !0;
      break
    }
  }
  if (!e) return null;
  let i = null, r = null, o = null;
  for (let s of n)
    s.findHostDirectiveDefs !== null &&
        (i ??= [], r ??= new Map, o ??= new Map, q1(s, i, o, r)),
        s === t && (i ??= [], i.push(s));
  return i !== null ? (i.push(...t === null ? n : n.slice(1)), [i, r, o]) : null
}
function q1(n, t, e, i) {
  let r = t.length;
  n.findHostDirectiveDefs(n, t, i), e.set(n, [r, t.length - 1])
}
function G1(n, t, e) {
  t.componentOffset = e, (n.components ??= []).push(t.index)
}
function Q1(n, t, e, i, r, o, s) {
  let a = i.length, l = !1;
  for (let p = 0; p < a; p++) {
    let h = i[p];
    !l && ii(h) && (l = !0, G1(n, e, p)), Qf(Nd(e, t), n, h.type)
  }
  eO(e, n.data.length, a);
  for (let p = 0; p < a; p++) {
    let h = i[p];
    h.providersResolver && h.providersResolver(h)
  }
  let c = !1, d = !1, m = Vx(n, t, a, null);
  a > 0 && (e.directiveToIndex = new Map);
  for (let p = 0; p < a; p++) {
    let h = i[p];
    if (e.mergedAttrs = vs(e.mergedAttrs, h.hostAttrs), Z1(n, e, t, m, h),
        J1(m, h, r), s !== null && s.has(h)) {
      let [v, k] = s.get(h);
      e.directiveToIndex.set(
          h.type, [m, v + e.directiveStart, k + e.directiveStart])
    } else
      (o === null || !o.has(h)) && e.directiveToIndex.set(h.type, m);
    h.contentQueries !== null && (e.flags |= 4),
        (h.hostBindings !== null || h.hostAttrs !== null || h.hostVars !== 0) &&
        (e.flags |= 64);
    let _ = h.type.prototype;
    !c && (_.ngOnChanges || _.ngOnInit || _.ngDoCheck) &&
        ((n.preOrderHooks ??= []).push(e.index), c = !0),
        !d && (_.ngOnChanges || _.ngDoCheck) &&
        ((n.preOrderCheckHooks ??= []).push(e.index), d = !0),
        m++
  }
  Y1(n, e, o)
}
function Y1(n, t, e) {
  for (let i = t.directiveStart; i < t.directiveEnd; i++) {
    let r = n.data[i];
    if (e === null || !e.has(r))
      R0(0, t, r, i), R0(1, t, r, i), O0(t, i, !1);
    else {
      let o = e.get(r);
      A0(0, t, o, i), A0(1, t, o, i), O0(t, i, !0)
    }
  }
}
function R0(n, t, e, i) {
  let r = n === 0 ? e.inputs : e.outputs;
  for (let o in r)
    if (r.hasOwnProperty(o)) {
      let s;
      n === 0 ? s = t.inputs ??= {} : s = t.outputs ??= {}, s[o] ??= [],
                s[o].push(i), aC(t, o)
    }
}
function A0(n, t, e, i) {
  let r = n === 0 ? e.inputs : e.outputs;
  for (let o in r)
    if (r.hasOwnProperty(o)) {
      let s = r[o], a;
      n === 0 ? a = t.hostDirectiveInputs ??= {} :
                a = t.hostDirectiveOutputs ??= {},
                a[s] ??= [], a[s].push(i, o), aC(t, s)
    }
}
function aC(n, t) {
  t === 'class' ? n.flags |= 8 : t === 'style' && (n.flags |= 16)
}
function O0(n, t, e) {
  let {attrs: i, inputs: r, hostDirectiveInputs: o} = n;
  if (i === null || !e && r === null || e && o === null || hg(n)) {
    n.initialInputs ??= [], n.initialInputs.push(null);
    return
  }
  let s = null, a = 0;
  for (; a < i.length;) {
    let l = i[a];
    if (l === 0) {
      a += 4;
      continue
    } else if (l === 5) {
      a += 2;
      continue
    } else if (typeof l == 'number')
      break;
    if (!e && r.hasOwnProperty(l)) {
      let c = r[l];
      for (let d of c)
        if (d === t) {
          s ??= [], s.push(l, i[a + 1]);
          break
        }
    } else if (e && o.hasOwnProperty(l)) {
      let c = o[l];
      for (let d = 0; d < c.length; d += 2)
        if (c[d] === t) {
          s ??= [], s.push(c[d + 1], i[a + 1]);
          break
        }
    }
    a += 2
  }
  n.initialInputs ??= [], n.initialInputs.push(s)
}
function Z1(n, t, e, i, r) {
  n.data[i] = r;
  let o = r.factory || (r.factory = ao(r.type, !0)), s = new fo(o, ii(r), z);
  n.blueprint[i] = s, e[i] = s, K1(n, t, i, Vx(n, e, r.hostVars, Ln), r)
}
function K1(n, t, e, i, r) {
  let o = r.hostBindings;
  if (o) {
    let s = n.hostBindingOpCodes;
    s === null && (s = n.hostBindingOpCodes = []);
    let a = ~t.index;
    X1(s) != a && s.push(a), s.push(e, i, o)
  }
}
function X1(n) {
  let t = n.length;
  for (; t > 0;) {
    let e = n[--t];
    if (typeof e == 'number' && e < 0) return e
  }
  return 0
}
function J1(n, t, e) {
  if (e) {
    if (t.exportAs)
      for (let i = 0; i < t.exportAs.length; i++) e[t.exportAs[i]] = n;
    ii(t) && (e[''] = n)
  }
}
function eO(n, t, e) {
  n.flags |= 1, n.directiveStart = t, n.directiveEnd = t + e,
                n.providerIndexes = t
}
function lC(n, t, e, i, r, o, s, a) {
  let l = t.consts, c = pr(l, s), d = ll(t, n, 2, i, c);
  return o && Sg(t, e, d, pr(l, a), r),
         d.mergedAttrs = vs(d.mergedAttrs, d.attrs),
         d.attrs !== null && fp(d, d.attrs, !1),
         d.mergedAttrs !== null && fp(d, d.mergedAttrs, !0),
         t.queries !== null && t.queries.elementStart(t, d), d
}
function cC(n, t) {
  ig(n, t), Gp(t) && n.queries.elementEnd(t)
}
var Bd = class extends xu {
  ngModule;
  constructor(t) {
    super(), this.ngModule = t
  }
  resolveComponentFactory(t) {
    let e = fr(t);
    return new go(e, this.ngModule)
  }
};
function tO(n) {
  return Object.keys(n).map(t => {
    let [e, i, r] = n[t], o = {
      propName: e,
      templateName: t,
      isSignal: (i & gu.SignalBased) !== 0
    };
    return r && (o.transform = r), o
  })
}
function nO(n) {
  return Object.keys(n).map(t => ({propName: n[t], templateName: t}))
}
function iO(n, t, e) {
  let i = t instanceof _t ? t : t?.injector;
  return i && n.getStandaloneInjector !== null &&
             (i = n.getStandaloneInjector(i) || i),
         i ? new qf(e, i) : e
}
function rO(n) {
  let t = n.get(Ot, null);
  if (t === null) throw new S(407, !1);
  let e = n.get(U1, null), i = n.get(po, null);
  return {
    rendererFactory: t, sanitizer: e, changeDetectionScheduler: i
  }
}
function oO(n, t) {
  let e = (n.selectors[0][0] || 'div').toLowerCase();
  return Nx(t, e, e === 'svg' ? Ew : e === 'math' ? QT : null)
}
var go = class extends oC {
  componentDef;
  ngModule;
  selector;
  componentType;
  ngContentSelectors;
  isBoundToModule;
  cachedInputs = null;
  cachedOutputs = null;
  get inputs() {
    return this.cachedInputs ??= tO(this.componentDef.inputs), this.cachedInputs
  }
  get outputs() {
    return this.cachedOutputs ??= nO(this.componentDef.outputs),
           this.cachedOutputs
  }
  constructor(t, e) {
    super(), this.componentDef = t, this.ngModule = e,
             this.componentType = t.type, this.selector = LA(t.selectors),
             this.ngContentSelectors = t.ngContentSelectors ?? [],
             this.isBoundToModule = !!e
  }
  create(t, e, i, r) {
    Qe(22);
    let o = Me(null);
    try {
      let s = this.componentDef,
          a = i ? ['ng-version', '19.2.3'] : VA(this.componentDef.selectors[0]),
          l = fg(0, null, null, 1, 0, null, null, null, null, [a], null),
          c = iO(s, r || this.ngModule, t), d = rO(c),
          m = d.rendererFactory.createRenderer(null, s),
          p = i ? QA(m, i, s.encapsulation, c) : oO(s, m),
          h =
              pg(null, l, null, 512 | Lx(s), null, null, d, m, c, null,
                 bx(p, c, !0));
      h[bt] = p, tg(h);
      let _ = null;
      try {
        let v = lC(bt, l, h, '#host', () => [this.componentDef], !0, 0);
        p && (Fx(m, p, v), Is(p, h)), _u(l, h, v), mg(l, v, h), cC(l, v),
            e !== void 0 && sO(v, this.ngContentSelectors, e),
            _ = oi(v.index, h), h[gt] = _[gt], wg(l, h, null)
      } catch (v) {
        throw _ !== null && Xf(_), Xf(h), v
      } finally {
        Qe(23), ng()
      }
      return new pp(this.componentType, h)
    } finally {
      Me(o)
    }
  }
}
, pp = class extends z1 {
  _rootLView;
  instance;
  hostView;
  changeDetectorRef;
  componentType;
  location;
  previousInputValues = null;
  _tNode;
  constructor(t, e) {
    super(), this._rootLView = e, this._tNode = Qp(e[xe], bt),
             this.location = Ss(this._tNode, e),
             this.instance = oi(this._tNode.index, e)[gt],
             this.hostView = this.changeDetectorRef = new Za(e, void 0, !1),
             this.componentType = t
  }
  setInput(t, e) {
    let i = this._tNode;
    if (this.previousInputValues ??= new Map,
        this.previousInputValues.has(t) &&
            Object.is(this.previousInputValues.get(t), e))
      return;
    let r = this._rootLView, o = yg(i, r[xe], r, t, e);
    this.previousInputValues.set(t, e);
    let s = oi(i.index, r);
    kg(s, 1)
  }
  get injector() {
    return new so(this._tNode, this._rootLView)
  }
  destroy() {
    this.hostView.destroy()
  }
  onDestroy(t) {
    this.hostView.onDestroy(t)
  }
};
function sO(n, t, e) {
  let i = n.projection = [];
  for (let r = 0; r < t.length; r++) {
    let o = e[r];
    i.push(o != null && o.length ? Array.from(o) : null)
  }
}
var Ge = (() => {
  class n {
    static __NG_ELEMENT_ID__ = aO
  } return n
})();
function aO() {
  let n = Nt();
  return uC(n, ve())
}
var lO = Ge, dC = class extends lO {
  _lContainer;
  _hostTNode;
  _hostLView;
  constructor(t, e, i) {
    super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i
  }
  get element() {
    return Ss(this._hostTNode, this._hostLView)
  }
  get injector() {
    return new so(this._hostTNode, this._hostLView)
  }
  get parentInjector() {
    let t = rg(this._hostTNode, this._hostLView);
    if ($w(t)) {
      let e = Ad(t, this._hostLView), i = Rd(t), r = e[xe].data[i + 8];
      return new so(r, e)
    } else
      return new so(null, this._hostLView)
  }
  clear() {
    for (; this.length > 0;) this.remove(this.length - 1)
  }
  get(t) {
    let e = N0(this._lContainer);
    return e !== null && e[t] || null
  }
  get length() {
    return this._lContainer.length - Rt
  }
  createEmbeddedView(t, e, i) {
    let r, o;
    typeof i == 'number' ? r = i : i != null && (r = i.index, o = i.injector);
    let s = ws(this._lContainer, t.ssrId),
        a = t.createEmbeddedViewImpl(e || {}, o, s);
    return this.insertImpl(a, r, ys(this._hostTNode, s)), a
  }
  createComponent(t, e, i, r, o) {
    let s = t && !$T(t), a;
    if (s)
      a = e;
    else {
      let _ = e || {};
      a = _.index, i = _.injector, r = _.projectableNodes,
      o = _.environmentInjector || _.ngModuleRef
    }
    let l = s ? t : new go(fr(t)), c = i || this.parentInjector;
    if (!o && l.ngModule == null) {
      let v = (s ? c : this.parentInjector).get(_t, null);
      v && (o = v)
    }
    let d = fr(l.componentType ?? {}), m = ws(this._lContainer, d?.id ?? null),
        p = m?.firstChild ?? null, h = l.create(c, r, p, o);
    return this.insertImpl(h.hostView, a, ys(this._hostTNode, m)), h
  }
  insert(t, e) {
    return this.insertImpl(t, e, !0)
  }
  insertImpl(t, e, i) {
    let r = t._lView;
    if (ZT(r)) {
      let a = this.indexOf(t);
      if (a !== -1)
        this.detach(a);
      else {
        let l = r[At], c = new dC(l, l[Xt], l[At]);
        c.detach(c.indexOf(t))
      }
    }
    let o = this._adjustIndex(e), s = this._lContainer;
    return al(s, r, o, i), t.attachToViewContainerRef(), cw(If(s), o, t), t
  }
  move(t, e) {
    return this.insert(t, e)
  }
  indexOf(t) {
    let e = N0(this._lContainer);
    return e !== null ? e.indexOf(t) : -1
  }
  remove(t) {
    let e = this._adjustIndex(t, -1), i = Ya(this._lContainer, e);
    i && (Ed(If(this._lContainer), e), bu(i[xe], i))
  }
  detach(t) {
    let e = this._adjustIndex(t, -1), i = Ya(this._lContainer, e);
    return i && Ed(If(this._lContainer), e) != null ? new Za(i) : null
  }
  _adjustIndex(t, e = 0) {
    return t ?? this.length + e
  }
};
function N0(n) {
  return n[Id]
}
function If(n) {
  return n[Id] || (n[Id] = [])
}
function uC(n, t) {
  let e, i = t[n.index];
  return Bi(i) ? e = i : (e = tC(i, t, null, n), t[n.index] = e, gg(t, e)),
                 dO(e, t, n, i), new dC(e, n, t)
}
function cO(n, t) {
  let e = n[nt], i = e.createComment(''), r = ci(t, n), o = e.parentNode(r);
  return Vd(e, o, i, e.nextSibling(r), !1), i
}
var dO = hO, uO = () => !1;
function mO(n, t, e) {
  return uO(n, t, e)
}
function hO(n, t, e, i) {
  if (n[uo]) return;
  let r;
  e.type&8 ? r = ri(i) : r = cO(t, e), n[uo] = r
}
var gp = class n {
  queryList;
  matches = null;
  constructor(t) {
    this.queryList = t
  }
  clone() {
    return new n(this.queryList)
  }
  setDirty() {
    this.queryList.setDirty()
  }
}
, _p = class n {
  queries;
  constructor(t = []) {
    this.queries = t
  }
  createEmbeddedView(t) {
    let e = t.queries;
    if (e !== null) {
      let i = t.contentQueries !== null ? t.contentQueries[0] : e.length,
          r = [];
      for (let o = 0; o < i; o++) {
        let s = e.getByIndex(o), a = this.queries[s.indexInDeclarationView];
        r.push(a.clone())
      }
      return new n(r)
    }
    return null
  }
  insertView(t) {
    this.dirtyQueriesWithMatches(t)
  }
  detachView(t) {
    this.dirtyQueriesWithMatches(t)
  }
  finishViewCreation(t) {
    this.dirtyQueriesWithMatches(t)
  }
  dirtyQueriesWithMatches(t) {
    for (let e = 0; e < this.queries.length; e++)
      Mg(t, e).matches !== null && this.queries[e].setDirty()
  }
}
, zd = class {
  flags;
  read;
  predicate;
  constructor(t, e, i = null) {
    this.flags = e, this.read = i,
    typeof t == 'string' ? this.predicate = vO(t) : this.predicate = t
  }
}
, bp = class n {
  queries;
  constructor(t = []) {
    this.queries = t
  }
  elementStart(t, e) {
    for (let i = 0; i < this.queries.length; i++)
      this.queries[i].elementStart(t, e)
  }
  elementEnd(t) {
    for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(t)
  }
  embeddedTView(t) {
    let e = null;
    for (let i = 0; i < this.length; i++) {
      let r = e !== null ? e.length : 0,
          o = this.getByIndex(i).embeddedTView(t, r);
      o && (o.indexInDeclarationView = i, e !== null ? e.push(o) : e = [o])
    }
    return e !== null ? new n(e) : null
  }
  template(t, e) {
    for (let i = 0; i < this.queries.length; i++) this.queries[i].template(t, e)
  }
  getByIndex(t) {
    return this.queries[t]
  }
  get length() {
    return this.queries.length
  }
  track(t) {
    this.queries.push(t)
  }
}
, vp = class n {
  metadata;
  matches = null;
  indexInDeclarationView = -1;
  crossesNgTemplate = !1;
  _declarationNodeIndex;
  _appliesToNextNode = !0;
  constructor(t, e = -1) {
    this.metadata = t, this._declarationNodeIndex = e
  }
  elementStart(t, e) {
    this.isApplyingToNode(e) && this.matchTNode(t, e)
  }
  elementEnd(t) {
    this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1)
  }
  template(t, e) {
    this.elementStart(t, e)
  }
  embeddedTView(t, e) {
    return this.isApplyingToNode(t) ?
        (this.crossesNgTemplate = !0, this.addMatch(-t.index, e),
         new n(this.metadata)) :
        null
  }
  isApplyingToNode(t) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      let e = this._declarationNodeIndex, i = t.parent;
      for (; i !== null && i.type & 8 && i.index !== e;) i = i.parent;
      return e === (i !== null ? i.index : -1)
    }
    return this._appliesToNextNode
  }
  matchTNode(t, e) {
    let i = this.metadata.predicate;
    if (Array.isArray(i))
      for (let r = 0; r < i.length; r++) {
        let o = i[r];
        this.matchTNodeWithReadOption(t, e, fO(e, o)),
            this.matchTNodeWithReadOption(t, e, yd(e, t, o, !1, !1))
      }
    else
      i === qe ? e.type&4 && this.matchTNodeWithReadOption(t, e, -1) :
                 this.matchTNodeWithReadOption(t, e, yd(e, t, i, !1, !1))
  }
  matchTNodeWithReadOption(t, e, i) {
    if (i !== null) {
      let r = this.metadata.read;
      if (r !== null)
        if (r === L || r === Ge || r === qe && e.type & 4)
          this.addMatch(e.index, -2);
        else {
          let o = yd(e, t, r, !1, !1);
          o !== null && this.addMatch(e.index, o)
        }
      else
        this.addMatch(e.index, i)
    }
  }
  addMatch(t, e) {
    this.matches === null ? this.matches = [t, e] : this.matches.push(t, e)
  }
};
function fO(n, t) {
  let e = n.localNames;
  if (e !== null) {
    for (let i = 0; i < e.length; i += 2)
      if (e[i] === t) return e[i + 1]
  }
  return null
}
function pO(n, t) {
  return n.type & 11 ? Ss(n, t) : n.type & 4 ? wu(n, t) : null
}
function gO(n, t, e, i) {
  return e === -1 ? pO(t, n) : e === -2 ? _O(n, t, i) : Ga(n, n[xe], e, t)
}
function _O(n, t, e) {
  if (e === L) return Ss(t, n);
  if (e === qe) return wu(t, n);
  if (e === Ge) return uC(t, n)
}
function mC(n, t, e, i) {
  let r = t[Fi].queries[i];
  if (r.matches === null) {
    let o = n.data, s = e.matches, a = [];
    for (let l = 0; s !== null && l < s.length; l += 2) {
      let c = s[l];
      if (c < 0)
        a.push(null);
      else {
        let d = o[c];
        a.push(gO(t, d, s[l + 1], e.metadata.read))
      }
    }
    r.matches = a
  }
  return r.matches
}
function yp(n, t, e, i) {
  let r = n.queries.getByIndex(e), o = r.matches;
  if (o !== null) {
    let s = mC(n, t, r, e);
    for (let a = 0; a < o.length; a += 2) {
      let l = o[a];
      if (l > 0)
        i.push(s[a / 2]);
      else {
        let c = o[a + 1], d = t[-l];
        for (let m = Rt; m < d.length; m++) {
          let p = d[m];
          p[lo] === p[At] && yp(p[xe], p, c, i)
        }
        if (d[bs] !== null) {
          let m = d[bs];
          for (let p = 0; p < m.length; p++) {
            let h = m[p];
            yp(h[xe], h, c, i)
          }
        }
      }
    }
  }
  return i
}
function Ig(n, t) {
  return n[Fi].queries[t].queryList
}
function hC(n, t, e) {
  let i = new si((e & 4) === 4);
  return JT(n, t, i, i.destroy), (t[Fi] ??= new _p).queries.push(new gp(i)) - 1
}
function bO(n, t, e) {
  let i = it();
  return i.firstCreatePass &&
             (pC(i, new zd(n, t, e), -1),
              (t & 2) === 2 && (i.staticViewQueries = !0)),
         hC(i, ve(), t)
}
function fC(n, t, e, i) {
  let r = it();
  if (r.firstCreatePass) {
    let o = Nt();
    pC(r, new zd(t, e, i), o.index), yO(r, n),
        (e & 2) === 2 && (r.staticContentQueries = !0)
  }
  return hC(r, ve(), e)
}
function vO(n) {
  return n.split(',').map(t => t.trim())
}
function pC(n, t, e) {
  n.queries === null && (n.queries = new bp), n.queries.track(new vp(t, e))
}
function yO(n, t) {
  let e = n.contentQueries || (n.contentQueries = []),
      i = e.length ? e[e.length - 1] : -1;
  t !== i && e.push(n.queries.length - 1, t)
}
function Mg(n, t) {
  return n.queries.getByIndex(t)
}
function gC(n, t) {
  let e = n[xe], i = Mg(e, t);
  return i.crossesNgTemplate ? yp(e, n, t, []) : mC(e, n, i, t)
}
function _C(n, t, e) {
  let i, r = nf(() => {
           i._dirtyCounter();
           let o = DO(i, n);
           if (t && o === void 0) throw new S(-951, !1);
           return o
         });
  return i = r[$t], i._dirtyCounter = Jt(0), i._flatValue = void 0, r
}
function wO(n) {
  return _C(!0, !1, n)
}
function xO(n) {
  return _C(!0, !0, n)
}
function CO(n, t) {
  let e = n[$t];
  e._lView = ve(), e._queryIndex = t, e._queryList = Ig(e._lView, t),
  e._queryList.onDirty(() => e._dirtyCounter.update(i => i + 1))
}
function DO(n, t) {
  let e = n._lView, i = n._queryIndex;
  if (e === void 0 || i === void 0 || e[be] & 4) return t ? void 0 : jt;
  let r = Ig(e, i), o = gC(e, i);
  return r.reset(o, sx),
         t ? r.first :
             r._changesDetected || n._flatValue === void 0 ?
             n._flatValue = r.toArray() :
             n._flatValue
}
function P0(n, t) {
  return wO(t)
}
function EO(n, t) {
  return xO(t)
}
var bC = (P0.required = EO, P0);
function kO(n) {
  let t = [], e = new Map;
  function i(r) {
    let o = e.get(r);
    if (!o) {
      let s = n(r);
      e.set(r, o = s.then(TO))
    }
    return o
  }
  return Hd.forEach((r, o) => {
    let s = [];
    r.templateUrl && s.push(i(r.templateUrl).then(c => {r.template = c}));
    let a = typeof r.styles == 'string' ? [r.styles] : r.styles || [];
    if (r.styles = a, r.styleUrl && r.styleUrls?.length)
      throw new Error(
          '@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple');
    if (r.styleUrls?.length) {
      let c = r.styles.length, d = r.styleUrls;
      r.styleUrls.forEach((m, p) => {
        a.push(''),
        s.push(i(m).then(h => {
          a[c + p] = h,
          d.splice(d.indexOf(m), 1),
          d.length == 0 && (r.styleUrls = void 0)
        }))
      })
    } else
      r.styleUrl &&
          s.push(i(r.styleUrl).then(c => {a.push(c), r.styleUrl = void 0}));
    let l = Promise.all(s).then(() => RO(o));
    t.push(l)
  }),
         IO(), Promise.all(t).then(() => {})
}
var Hd = new Map, SO = new Set;
function IO() {
  let n = Hd;
  return Hd = new Map, n
}
function MO() {
  return Hd.size === 0
}
function TO(n) {
  return typeof n == 'string' ? n : n.text()
}
function RO(n) {
  SO.delete(n)
}
var Vi = class {}
, Tg = class {};
var Ud = class extends Vi {
  ngModuleType;
  _parent;
  _bootstrapComponents = [];
  _r3Injector;
  instance;
  destroyCbs = [];
  componentFactoryResolver = new Bd(this);
  constructor(t, e, i, r = !0) {
    super(), this.ngModuleType = t, this._parent = e;
    let o = mw(t);
    this._bootstrapComponents = Rx(o.bootstrap),
    this._r3Injector =
        Jw(t, e,
           [
             {provide: Vi, useValue: this},
             {provide: xu, useValue: this.componentFactoryResolver}, ...i
           ],
           Gt(t), new Set(['environment'])),
    r && this.resolveInjectorInitializers()
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers(),
        this.instance = this._r3Injector.get(this.ngModuleType)
  }
  get injector() {
    return this._r3Injector
  }
  destroy() {
    let t = this._r3Injector;
    !t.destroyed && t.destroy(), this.destroyCbs.forEach(e => e()),
        this.destroyCbs = null
  }
  onDestroy(t) {
    this.destroyCbs.push(t)
  }
}
, $d = class extends Tg {
  moduleType;
  constructor(t) {
    super(), this.moduleType = t
  }
  create(t) {
    return new Ud(this.moduleType, t, [])
  }
};
function AO(n, t, e) {
  return new Ud(n, t, e, !1)
}
var wp = class extends Vi {
  injector;
  componentFactoryResolver = new Bd(this);
  instance = null;
  constructor(t) {
    super();
    let e = new $a(
        [
          ...t.providers, {provide: Vi, useValue: this},
          {provide: xu, useValue: this.componentFactoryResolver}
        ],
        t.parent || ou(), t.debugName, new Set(['environment']));
    this.injector = e,
    t.runEnvironmentInitializers && e.resolveInjectorInitializers()
  }
  destroy() {
    this.injector.destroy()
  }
  onDestroy(t) {
    this.injector.onDestroy(t)
  }
};
function Cu(n, t, e = null) {
  return new wp({
           providers: n,
           parent: t,
           debugName: e,
           runEnvironmentInitializers: !0
         })
      .injector
}
var OO = (() => {
  class n {
    _injector;
    cachedInjectors = new Map;
    constructor(e) {
      this._injector = e
    }
    getOrCreateStandaloneInjector(e) {
      if (!e.standalone) return null;
      if (!this.cachedInjectors.has(e)) {
        let i = fw(!1, e.type),
            r = i.length > 0 ?
            Cu([i], this._injector, `Standalone[${e.type.name}]`) :
            null;
        this.cachedInjectors.set(e, r)
      }
      return this.cachedInjectors.get(e)
    }
    ngOnDestroy() {
      try {
        for (let e of this.cachedInjectors.values()) e !== null && e.destroy()
      } finally {
        this.cachedInjectors.clear()
      }
    }
    static \u0275prov =
        C({token: n, providedIn: 'environment', factory: () => new n(A(_t))})
  } return n
})();
function O(n) {
  return Xa(() => {
    let t = vC(n), e = ae(y({}, t), {
                     decls: n.decls,
                     vars: n.vars,
                     template: n.template,
                     consts: n.consts || null,
                     ngContentSelectors: n.ngContentSelectors,
                     onPush: n.changeDetection === cx.OnPush,
                     directiveDefs: null,
                     pipeDefs: null,
                     dependencies: t.standalone && n.dependencies || null,
                     getStandaloneInjector: t.standalone ?
                         r => r.get(OO).getOrCreateStandaloneInjector(e) :
                         null,
                     getExternalStyles: null,
                     signals: n.signals ?? !1,
                     data: n.data || {},
                     encapsulation: n.encapsulation || ai.Emulated,
                     styles: n.styles || jt,
                     _: null,
                     schemas: n.schemas || null,
                     tView: null,
                     id: ''
                   });
    t.standalone && vr('NgStandalone'), yC(e);
    let i = n.dependencies;
    return e.directiveDefs = F0(i, !1), e.pipeDefs = F0(i, !0), e.id = VO(e), e
  })
}
function NO(n) {
  return fr(n) || hw(n)
}
function PO(n) {
  return n !== null
}
function j(n) {
  return Xa(() => ({
              type: n.type,
              bootstrap: n.bootstrap || jt,
              declarations: n.declarations || jt,
              imports: n.imports || jt,
              exports: n.exports || jt,
              transitiveCompileScopes: null,
              schemas: n.schemas || null,
              id: n.id || null
            }))
}
function FO(n, t) {
  if (n == null) return ni;
  let e = {};
  for (let i in n)
    if (n.hasOwnProperty(i)) {
      let r = n[i], o, s, a, l;
      Array.isArray(r) ? (a = r[0], o = r[1], s = r[2] ?? o, l = r[3] || null) :
                         (o = r, s = r, a = gu.None, l = null),
          e[o] = [i, a, l], t[o] = s
    }
  return e
}
function LO(n) {
  if (n == null) return ni;
  let t = {};
  for (let e in n) n.hasOwnProperty(e) && (t[n[e]] = e);
  return t
}
function T(n) {
  return Xa(() => {
    let t = vC(n);
    return yC(t), t
  })
}
function Du(n) {
  return {
    type: n.type, name: n.name, factory: null, pure: n.pure !== !1,
        standalone: n.standalone ?? !0,
        onDestroy: n.type.prototype.ngOnDestroy || null
  }
}
function vC(n) {
  let t = {};
  return {
    type: n.type, providersResolver: null, factory: null,
        hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0,
        hostAttrs: n.hostAttrs || null,
        contentQueries: n.contentQueries || null, declaredInputs: t,
        inputConfig: n.inputs || ni, exportAs: n.exportAs || null,
        standalone: n.standalone ?? !0, signals: n.signals === !0,
        selectors: n.selectors || jt, viewQuery: n.viewQuery || null,
        features: n.features || null, setInput: null,
        findHostDirectiveDefs: null, hostDirectives: null,
        inputs: FO(n.inputs, t), outputs: LO(n.outputs), debugInfo: null
  }
}
function yC(n) {
  n.features?.forEach(t => t(n))
}
function F0(n, t) {
  if (!n) return null;
  let e = t ? AT : NO;
  return () => (typeof n == 'function' ? n() : n).map(i => e(i)).filter(PO)
}
function VO(n) {
  let t = 0, e = typeof n.consts == 'function' ? '' : n.consts, i = [
    n.selectors, n.ngContentSelectors, n.hostVars, n.hostAttrs, e, n.vars,
    n.decls, n.encapsulation, n.standalone, n.signals, n.exportAs,
    JSON.stringify(n.inputs), JSON.stringify(n.outputs),
    Object.getOwnPropertyNames(n.type.prototype), !!n.contentQueries,
    !!n.viewQuery
  ];
  for (let o of i.join('|')) t = Math.imul(31, t) + o.charCodeAt(0) << 0;
  return t += 2147483648, 'c' + t
}
function jO(n) {
  return Object.getPrototypeOf(n.prototype).constructor
}
function te(n) {
  let t = jO(n.type), e = !0, i = [n];
  for (; t;) {
    let r;
    if (ii(n))
      r = t.\u0275cmp || t.\u0275dir;
    else {
      if (t.\u0275cmp) throw new S(903, !1);
      r = t.\u0275dir
    }
    if (r) {
      if (e) {
        i.push(r);
        let s = n;
        s.inputs = Mf(n.inputs), s.declaredInputs = Mf(n.declaredInputs),
        s.outputs = Mf(n.outputs);
        let a = r.hostBindings;
        a && $O(n, a);
        let l = r.viewQuery, c = r.contentQueries;
        if (l && HO(n, l), c && UO(n, c), BO(n, r), dT(n.outputs, r.outputs),
            ii(r) && r.data.animation) {
          let d = n.data;
          d.animation = (d.animation || []).concat(r.data.animation)
        }
      }
      let o = r.features;
      if (o)
        for (let s = 0; s < o.length; s++) {
          let a = o[s];
          a && a.ngInherit && a(n), a === te && (e = !1)
        }
    }
    t = Object.getPrototypeOf(t)
  }
  zO(i)
}
function BO(n, t) {
  for (let e in t.inputs) {
    if (!t.inputs.hasOwnProperty(e) || n.inputs.hasOwnProperty(e)) continue;
    let i = t.inputs[e];
    i !== void 0 && (n.inputs[e] = i, n.declaredInputs[e] = t.declaredInputs[e])
  }
}
function zO(n) {
  let t = 0, e = null;
  for (let i = n.length - 1; i >= 0; i--) {
    let r = n[i];
    r.hostVars = t += r.hostVars,
    r.hostAttrs = vs(r.hostAttrs, e = vs(e, r.hostAttrs))
  }
}
function Mf(n) {
  return n === ni ? {} : n === jt ? [] : n
}
function HO(n, t) {
  let e = n.viewQuery;
  e ? n.viewQuery = (i, r) => {
    t(i, r), e(i, r)
  } : n.viewQuery = t
}
function UO(n, t) {
  let e = n.contentQueries;
  e ? n.contentQueries = (i, r, o) => {
    t(i, r, o), e(i, r, o)
  } : n.contentQueries = t
}
function $O(n, t) {
  let e = n.hostBindings;
  e ? n.hostBindings = (i, r) => {
    t(i, r), e(i, r)
  } : n.hostBindings = t
}
function wC(n) {
  let t = e => {
    let i = Array.isArray(n);
    e.hostDirectives === null ?
        (e.findHostDirectiveDefs = xC, e.hostDirectives = i ? n.map(xp) : [n]) :
        i ? e.hostDirectives.unshift(...n.map(xp)) :
            e.hostDirectives.unshift(n)
  };
  return t.ngInherit = !0, t
}
function xC(n, t, e) {
  if (n.hostDirectives !== null)
    for (let i of n.hostDirectives)
      if (typeof i == 'function') {
        let r = i();
        for (let o of r) L0(xp(o), t, e)
      } else
        L0(i, t, e)
}
function L0(n, t, e) {
  let i = hw(n.directive);
  WO(i.declaredInputs, n.inputs), xC(i, t, e), e.set(i, n), t.push(i)
}
function xp(n) {
  return typeof n == 'function' ?
      {directive: Dt(n), inputs: ni, outputs: ni} :
      {directive: Dt(n.directive), inputs: V0(n.inputs), outputs: V0(n.outputs)}
}
function V0(n) {
  if (n === void 0 || n.length === 0) return ni;
  let t = {};
  for (let e = 0; e < n.length; e += 2) t[n[e]] = n[e + 1];
  return t
}
function WO(n, t) {
  for (let e in t)
    if (t.hasOwnProperty(e)) {
      let i = t[e], r = n[e];
      n[i] = r
    }
}
function CC(n) {
  return Rg(n) ?
      Array.isArray(n) || !(n instanceof Map) && Symbol.iterator in n :
      !1
}
function qO(n, t) {
  if (Array.isArray(n))
    for (let e = 0; e < n.length; e++) t(n[e]);
  else {
    let e = n[Symbol.iterator](), i;
    for (; !(i = e.next()).done;) t(i.value)
  }
}
function Rg(n) {
  return n !== null && (typeof n == 'function' || typeof n == 'object')
}
function Ag(n, t, e) {
  return n[t] = e
}
function GO(n, t) {
  return n[t]
}
function bn(n, t, e) {
  let i = n[t];
  return Object.is(i, e) ? !1 : (n[t] = e, !0)
}
function QO(n, t, e, i) {
  let r = bn(n, t, e);
  return bn(n, t + 1, i) || r
}
function YO(n, t, e, i, r, o, s, a, l) {
  let c = t.consts, d = ll(t, n, 4, s || null, a || null);
  Kp() && Sg(t, e, d, pr(c, l), vg), d.mergedAttrs = vs(d.mergedAttrs, d.attrs),
                                     ig(t, d);
  let m = d.tView =
      fg(2, d, i, r, o, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c,
         null);
  return t.queries !== null &&
             (t.queries.template(t, d), m.queries = t.queries.embeddedTView(d)),
         d
}
function Wd(n, t, e, i, r, o, s, a, l, c) {
  let d = e + bt,
      m = t.firstCreatePass ? YO(d, t, n, i, r, o, s, a, l) : t.data[d];
  vo(m, !1);
  let p = ZO(t, n, m, e);
  mu() && vu(t, n, p, m), Is(p, n);
  let h = tC(p, n, p, m);
  return n[d] = h, gg(n, h), mO(h, m, n), lu(m) && _u(t, n, m),
         l != null && _g(n, m, c), m
}
function R(n, t, e, i, r, o, s, a) {
  let l = ve(), c = it(), d = pr(c.consts, o);
  return Wd(l, c, n, t, e, i, r, d, s, a), R
}
var ZO = KO;
function KO(n, t, e, i) {
  return hu(!0), t[nt].createComment('')
}
var Og = (() => {
  class n {
    log(e) {
      console.log(e)
    }
    warn(e) {
      console.warn(e)
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov =
        C({token: n, factory: n.\u0275fac, providedIn: 'platform'})
  } return n
})();
var Ng = new w(''), cl = new w(''),
    Eu = (() => {
      class n {
        _ngZone;
        registry;
        _isZoneStable = !0;
        _callbacks = [];
        taskTrackingZone = null;
        constructor(e, i, r) {
          this._ngZone = e, this.registry = i, Pg || (XO(r), r.addToWindow(i)),
          this._watchAngularEvents(),
          e.run(
              () => {
                  this.taskTrackingZone = typeof Zone > 'u' ?
                      null :
                      Zone.current.get('TaskTrackingZone')})
        }
        _watchAngularEvents() {
          this._ngZone.onUnstable.subscribe({
            next: () => {
              this._isZoneStable = !1
            }
          }),
              this._ngZone.runOutsideAngular(
                  () => {this._ngZone.onStable.subscribe({
                    next: () => {
                      U.assertNotInAngularZone(), queueMicrotask(() => {
                        this._isZoneStable = !0,
                        this._runCallbacksIfReady()
                      })
                    }
                  })})
        }
        isStable() {
          return this._isZoneStable && !this._ngZone.hasPendingMacrotasks
        }
        _runCallbacksIfReady() {
          if (this.isStable())
            queueMicrotask(() => {
              for (; this._callbacks.length !== 0;) {
                let e = this._callbacks.pop();
                clearTimeout(e.timeoutId), e.doneCb()
              }
            });
          else {
            let e = this.getPendingTasks();
            this._callbacks = this._callbacks.filter(
                i => i.updateCb && i.updateCb(e) ?
                    (clearTimeout(i.timeoutId), !1) :
                    !0)
          }
        }
        getPendingTasks() {
          return this.taskTrackingZone ?
              this.taskTrackingZone.macroTasks.map(
                  e => ({
                    source: e.source,
                    creationLocation: e.creationLocation,
                    data: e.data
                  })) :
              []
        }
        addCallback(e, i, r) {
          let o = -1;
          i && i > 0 &&
              (o = setTimeout(
                   () => {
                     this._callbacks =
                         this._callbacks.filter(s => s.timeoutId !== o),
                     e()
                   },
                   i)),
              this._callbacks.push({doneCb: e, timeoutId: o, updateCb: r})
        }
        whenStable(e, i, r) {
          if (r && !this.taskTrackingZone)
            throw new Error(
                'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
          this.addCallback(e, i, r), this._runCallbacksIfReady()
        }
        registerApplication(e) {
          this.registry.registerApplication(e, this)
        }
        unregisterApplication(e) {
          this.registry.unregisterApplication(e)
        }
        findProviders(e, i, r) {
          return []
        }
        static \u0275fac = function(i) {
          return new (i || n)(A(U), A(ku), A(cl))
        };
        static \u0275prov = C({token: n, factory: n.\u0275fac})
      } return n
    })(),
    ku = (() => {
      class n {
        _applications = new Map;
        registerApplication(e, i) {
          this._applications.set(e, i)
        }
        unregisterApplication(e) {
          this._applications.delete(e)
        }
        unregisterAllApplications() {
          this._applications.clear()
        }
        getTestability(e) {
          return this._applications.get(e) || null
        }
        getAllTestabilities() {
          return Array.from(this._applications.values())
        }
        getAllRootElements() {
          return Array.from(this._applications.keys())
        }
        findTestabilityInTree(e, i = !0) {
          return Pg?.findTestabilityInTree(this, e, i) ?? null
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'platform'})
      } return n
    })();
function XO(n) {
  Pg = n
}
var Pg, DC = (() => {
          class n {
            static \u0275prov =
                C({token: n, providedIn: 'root', factory: () => new Cp})
          } return n
        })(),
        Cp = class {
  queuedEffectCount = 0;
  queues = new Map;
  schedule(t) {
    this.enqueue(t)
  }
  remove(t) {
    let e = t.zone, i = this.queues.get(e);
    i.has(t) && (i.delete(t), this.queuedEffectCount--)
  }
  enqueue(t) {
    let e = t.zone;
    this.queues.has(e) || this.queues.set(e, new Set);
    let i = this.queues.get(e);
    i.has(t) || (this.queuedEffectCount++, i.add(t))
  }
  flush() {
    for (; this.queuedEffectCount > 0;)
      for (let [t, e] of this.queues)
        t === null ? this.flushQueue(e) : t.run(() => this.flushQueue(e))
  }
  flushQueue(t) {
    for (let e of t) t.delete(e), this.queuedEffectCount--, e.run()
  }
};
function wr(n) {
  return !!n && typeof n.then == 'function'
}
function Fg(n) {
  return !!n && typeof n.subscribe == 'function'
}
var Su = new w('');
var EC = (() => {
  class n {
    resolve;
    reject;
    initialized = !1;
    done = !1;
    donePromise = new Promise((e, i) => {this.resolve = e, this.reject = i});
    appInits = u(Su, {optional: !0}) ?? [];
    injector = u(he);
    constructor() {}
    runInitializers() {
      if (this.initialized) return;
      let e = [];
      for (let r of this.appInits) {
        let o = Kt(this.injector, r);
        if (wr(o))
          e.push(o);
        else if (Fg(o)) {
          let s = new Promise((a, l) => {o.subscribe({complete: a, error: l})});
          e.push(s)
        }
      }
      let i = () => {
        this.done = !0, this.resolve()
      };
      Promise.all(e).then(() => {i()}).catch(r => {this.reject(r)}),
          e.length === 0 && i(), this.initialized = !0
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})(),
    Iu = new w('');
function JO() {
  Iy(() => {throw new S(600, !1)})
}
function eN(n) {
  return n.isBoundToModule
}
var tN = 10;
function kC(n, t) {
  return Array.isArray(t) ? t.reduce(kC, n) : y(y({}, n), t)
}
var Yt = (() => {
  class n {
    _runningTick = !1;
    _destroyed = !1;
    _destroyListeners = [];
    _views = [];
    internalErrorHandler = u(BR);
    afterRenderManager = u(gx);
    zonelessEnabled = u(sg);
    rootEffectScheduler = u(DC);
    dirtyFlags = 0;
    tracingSnapshot = null;
    externalTestViews = new Set;
    afterTick = new I;
    get allViews() {
      return [...this.externalTestViews.keys(), ...this._views]
    }
    get destroyed() {
      return this._destroyed
    }
    componentTypes = [];
    components = [];
    isStable = u(zi).hasPendingTasks.pipe(Q(e => !e));
    constructor() {
      u(Ts, {optional: !0})
    }
    whenStable() {
      let e;
      return new Promise(i => {e = this.isStable.subscribe({
                           next: r => {
                             r && i()
                           }
                         })})
          .finally(() => {e.unsubscribe()})
    }
    _injector = u(_t);
    _rendererFactory = null;
    get injector() {
      return this._injector
    }
    bootstrap(e, i) {
      Qe(10);
      let r = e instanceof oC;
      if (!this._injector.get(EC).done) {
        let p = '';
        throw new S(405, p)
      }
      let s;
      r ? s = e : s = this._injector.get(xu).resolveComponentFactory(e),
          this.componentTypes.push(s.componentType);
      let a = eN(s) ? void 0 : this._injector.get(Vi), l = i || s.selector,
          c = s.create(he.NULL, [], l, a), d = c.location.nativeElement,
          m = c.injector.get(Ng, null);
      return m?.registerApplication(d), c.onDestroy(() => {
        this.detachView(c.hostView),
        wd(this.components, c),
        m?.unregisterApplication(d)
      }),
             this._loadComponent(c), Qe(11, c), c
    }
    tick() {
      this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick()
    }
    _tick() {
      Qe(12),
          this.tracingSnapshot !== null ?
          this.tracingSnapshot.run(dg.CHANGE_DETECTION, this.tickImpl) :
          this.tickImpl()
    }
    tickImpl = () => {
      if (this._runningTick) throw new S(101, !1);
      let e = Me(null);
      try {
        this._runningTick = !0, this.synchronize()
      } catch (i) {
        this.internalErrorHandler(i)
      } finally {
        this._runningTick = !1, this.tracingSnapshot?.dispose(),
        this.tracingSnapshot = null, Me(e), this.afterTick.next(), Qe(13)
      }
    };
    synchronize() {
      this._rendererFactory === null && !this._injector.destroyed &&
          (this._rendererFactory =
               this._injector.get(Ot, null, {optional: !0}));
      let e = 0;
      for (; this.dirtyFlags !== 0 && e++ < tN;)
        Qe(14), this.synchronizeOnce(), Qe(15)
    }
    synchronizeOnce() {
      if (this.dirtyFlags & 16 &&
              (this.dirtyFlags &= -17, this.rootEffectScheduler.flush()),
          this.dirtyFlags & 7) {
        let e = !!(this.dirtyFlags & 1);
        this.dirtyFlags &= -8, this.dirtyFlags |= 8;
        for (let {_lView: i, notifyErrorHandler: r} of this.allViews)
          nN(i, r, e, this.zonelessEnabled);
        if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(),
            this.dirtyFlags & 23)
          return
      } else
        this._rendererFactory?.begin?.(), this._rendererFactory?.end?.();
      this.dirtyFlags&8 &&
          (this.dirtyFlags &= -9, this.afterRenderManager.execute()),
          this.syncDirtyFlagsWithViews()
    }
    syncDirtyFlagsWithViews() {
      if (this.allViews.some(({_lView: e}) => cu(e))) {
        this.dirtyFlags |= 2;
        return
      } else
        this.dirtyFlags &= -8
    }
    attachView(e) {
      let i = e;
      this._views.push(i), i.attachToAppRef(this)
    }
    detachView(e) {
      let i = e;
      wd(this._views, i), i.detachFromAppRef()
    }
    _loadComponent(e) {
      this.attachView(e.hostView), this.tick(), this.components.push(e),
          this._injector.get(Iu, []).forEach(r => r(e))
    }
    ngOnDestroy() {
      if (!this._destroyed) try {
          this._destroyListeners.forEach(e => e()),
              this._views.slice().forEach(e => e.destroy())
        } finally {
          this._destroyed = !0, this._views = [], this._destroyListeners = []
        }
    }
    onDestroy(e) {
      return this._destroyListeners.push(e), () => wd(this._destroyListeners, e)
    }
    destroy() {
      if (this._destroyed) throw new S(406, !1);
      let e = this._injector;
      e.destroy && !e.destroyed && e.destroy()
    }
    get viewCount() {
      return this._views.length
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function wd(n, t) {
  let e = n.indexOf(t);
  e > -1 && n.splice(e, 1)
}
function nN(n, t, e, i) {
  if (!e && !cu(n)) return;
  Kx(n, t, e && !i ? 0 : 1)
}
function J(n, t, e, i) {
  let r = ve(), o = yo();
  if (bn(r, o, t)) {
    let s = it(), a = uu();
    n1(a, r, n, t, e, i)
  }
  return J
}
function SC(n, t, e, i) {
  return bn(n, yo(), e) ? t + eu(e) + i : Ln
}
function pd(n, t) {
  return n << 17 | t << 2
}
function _o(n) {
  return n >> 17 & 32767
}
function iN(n) {
  return (n & 2) == 2
}
function rN(n, t) {
  return n & 131071 | t << 17
}
function Dp(n) {
  return n | 2
}
function xs(n) {
  return (n & 131068) >> 2
}
function Tf(n, t) {
  return n & -131069 | t << 2
}
function oN(n) {
  return (n & 1) === 1
}
function Ep(n) {
  return n | 1
}
function sN(n, t, e, i, r, o) {
  let s = o ? t.classBindings : t.styleBindings, a = _o(s), l = xs(s);
  n[i] = e;
  let c = !1, d;
  if (Array.isArray(e)) {
    let m = e;
    d = m[1], (d === null || el(m, d) > 0) && (c = !0)
  } else
    d = e;
  if (r)
    if (l !== 0) {
      let p = _o(n[a + 1]);
      n[i + 1] = pd(p, a), p !== 0 && (n[p + 1] = Tf(n[p + 1], i)),
            n[a + 1] = rN(n[a + 1], i)
    } else
      n[i + 1] = pd(a, 0), a !== 0 && (n[a + 1] = Tf(n[a + 1], i)), a = i;
  else
    n[i + 1] = pd(l, 0), a === 0 ? a = i : n[l + 1] = Tf(n[l + 1], i), l = i;
  c && (n[i + 1] = Dp(n[i + 1])), j0(n, d, i, !0), j0(n, d, i, !1),
      aN(t, d, n, i, o), s = pd(a, l),
                         o ? t.classBindings = s : t.styleBindings = s
}
function aN(n, t, e, i, r) {
  let o = r ? n.residualClasses : n.residualStyles;
  o != null && typeof t == 'string' && el(o, t) >= 0 &&
      (e[i + 1] = Ep(e[i + 1]))
}
function j0(n, t, e, i) {
  let r = n[e + 1], o = t === null, s = i ? _o(r) : xs(r), a = !1;
  for (; s !== 0 && (a === !1 || o);) {
    let l = n[s], c = n[s + 1];
    lN(l, t) && (a = !0, n[s + 1] = i ? Ep(c) : Dp(c)), s = i ? _o(c) : xs(c)
  }
  a && (n[e + 1] = i ? Dp(r) : Ep(r))
}
function lN(n, t) {
  return n === null || t == null || (Array.isArray(n) ? n[1] : n) === t ? !0 :
      Array.isArray(n) && typeof t == 'string' ? el(n, t) >= 0 :
                                                 !1
}
var On = {textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0};
function cN(n) {
  return n.substring(On.key, On.keyEnd)
}
function dN(n) {
  return uN(n), IC(n, MC(n, 0, On.textEnd))
}
function IC(n, t) {
  let e = On.textEnd;
  return e === t ? -1 : (t = On.keyEnd = mN(n, On.key = t, e), MC(n, t, e))
}
function uN(n) {
  On.key = 0, On.keyEnd = 0, On.value = 0, On.valueEnd = 0,
  On.textEnd = n.length
}
function MC(n, t, e) {
  for (; t < e && n.charCodeAt(t) <= 32;) t++;
  return t
}
function mN(n, t, e) {
  for (; t < e && n.charCodeAt(t) > 32;) t++;
  return t
}
function x(n, t, e) {
  let i = ve(), r = yo();
  if (bn(i, r, t)) {
    let o = it(), s = uu();
    bg(o, s, i, n, t, i[nt], e, !1)
  }
  return x
}
function kp(n, t, e, i, r) {
  yg(t, n, e, r ? 'class' : 'style', i)
}
function Pt(n, t, e) {
  return RC(n, t, e, !1), Pt
}
function Y(n, t) {
  return RC(n, t, null, !0), Y
}
function kt(n) {
  AC(bN, TC, n, !0)
}
function TC(n, t) {
  for (let e = dN(t); e >= 0; e = IC(t, e)) nu(n, cN(t), !0)
}
function RC(n, t, e, i) {
  let r = ve(), o = it(), s = Pw(2);
  if (o.firstUpdatePass && NC(o, n, s, i), t !== Ln && bn(r, s, t)) {
    let a = o.data[_r()];
    PC(o, a, r, r[nt], n, r[s + 1] = yN(t, e), i, s)
  }
}
function AC(n, t, e, i) {
  let r = it(), o = Pw(2);
  r.firstUpdatePass && NC(r, null, o, i);
  let s = ve();
  if (e !== Ln && bn(s, o, e)) {
    let a = r.data[_r()];
    if (FC(a, i) && !OC(r, o)) {
      let l = i ? a.classesWithoutHost : a.stylesWithoutHost;
      l !== null && (e = Pf(l, e || '')), kp(r, a, s, e, i)
    } else
      vN(r, a, s, s[nt], s[o + 1], s[o + 1] = _N(n, t, e), i, o)
  }
}
function OC(n, t) {
  return t >= n.expandoStartIndex
}
function NC(n, t, e, i) {
  let r = n.data;
  if (r[e + 1] === null) {
    let o = r[_r()], s = OC(n, e);
    FC(o, i) && t === null && !s && (t = !1), t = hN(r, o, t, i),
                                              sN(r, o, t, e, s, i)
  }
}
function hN(n, t, e, i) {
  let r = uR(n), o = i ? t.residualClasses : t.residualStyles;
  if (r === null)
    (i ? t.classBindings : t.styleBindings) === 0 &&
        (e = Rf(null, n, t, e, i), e = Ka(e, t.attrs, i), o = null);
  else {
    let s = t.directiveStylingLast;
    if (s === -1 || n[s] !== r)
      if (e = Rf(r, n, t, e, i), o === null) {
        let l = fN(n, t, i);
        l !== void 0 && Array.isArray(l) &&
            (l = Rf(null, n, t, l[1], i), l = Ka(l, t.attrs, i), pN(n, t, i, l))
      } else
        o = gN(n, t, i)
  }
  return o !== void 0 && (i ? t.residualClasses = o : t.residualStyles = o), e
}
function fN(n, t, e) {
  let i = e ? t.classBindings : t.styleBindings;
  if (xs(i) !== 0) return n[_o(i)]
}
function pN(n, t, e, i) {
  let r = e ? t.classBindings : t.styleBindings;
  n[_o(r)] = i
}
function gN(n, t, e) {
  let i, r = t.directiveEnd;
  for (let o = 1 + t.directiveStylingLast; o < r; o++) {
    let s = n[o].hostAttrs;
    i = Ka(i, s, e)
  }
  return Ka(i, t.attrs, e)
}
function Rf(n, t, e, i, r) {
  let o = null, s = e.directiveEnd, a = e.directiveStylingLast;
  for (a === -1 ? a = e.directiveStart : a++;
       a < s && (o = t[a], i = Ka(i, o.hostAttrs, r), o !== n);)
    a++;
  return n !== null && (e.directiveStylingLast = a), i
}
function Ka(n, t, e) {
  let i = e ? 1 : 2, r = -1;
  if (t !== null)
    for (let o = 0; o < t.length; o++) {
      let s = t[o];
      typeof s == 'number' ? r = s :
                             r === i &&
              (Array.isArray(n) || (n = n === void 0 ? [] : ['', n]),
               nu(n, s, e ? !0 : t[++o]))
    }
  return n === void 0 ? null : n
}
function _N(n, t, e) {
  if (e == null || e === '') return jt;
  let i = [], r = di(e);
  if (Array.isArray(r))
    for (let o = 0; o < r.length; o++) n(i, r[o], !0);
  else if (typeof r == 'object')
    for (let o in r) r.hasOwnProperty(o) && n(i, o, r[o]);
  else
    typeof r == 'string' && t(i, r);
  return i
}
function bN(n, t, e) {
  let i = String(t);
  i !== '' && !i.includes(' ') && nu(n, i, e)
}
function vN(n, t, e, i, r, o, s, a) {
  r === Ln && (r = jt);
  let l = 0, c = 0, d = 0 < r.length ? r[0] : null,
      m = 0 < o.length ? o[0] : null;
  for (; d !== null || m !== null;) {
    let p = l < r.length ? r[l + 1] : void 0,
        h = c < o.length ? o[c + 1] : void 0, _ = null, v;
    d === m ? (l += 2, c += 2, p !== h && (_ = m, v = h)) :
        m === null || d !== null && d < m ? (l += 2, _ = d) :
                                            (c += 2, _ = m, v = h),
        _ !== null && PC(n, t, e, i, _, v, s, a),
        d = l < r.length ? r[l] : null, m = c < o.length ? o[c] : null
  }
}
function PC(n, t, e, i, r, o, s, a) {
  if (!(t.type & 3)) return;
  let l = n.data, c = l[a + 1], d = oN(c) ? B0(l, t, e, r, xs(c), s) : void 0;
  if (!qd(d)) {
    qd(o) || iN(c) && (o = B0(l, null, e, r, a, s));
    let m = kw(_r(), e);
    v1(i, s, m, r, o)
  }
}
function B0(n, t, e, i, r, o) {
  let s = t === null, a;
  for (; r > 0;) {
    let l = n[r], c = Array.isArray(l), d = c ? l[1] : l, m = d === null,
        p = e[r + 1];
    p === Ln && (p = m ? jt : void 0);
    let h = m ? wf(p, i) : d === i ? p : void 0;
    if (c && !qd(h) && (h = wf(l, i)), qd(h) && (a = h, s)) return a;
    let _ = n[r + 1];
    r = s ? _o(_) : xs(_)
  }
  if (t !== null) {
    let l = o ? t.residualClasses : t.residualStyles;
    l != null && (a = wf(l, i))
  }
  return a
}
function qd(n) {
  return n !== void 0
}
function yN(n, t) {
  return n == null || n === '' ||
             (typeof t == 'string' ? n = n + t :
                                     typeof n == 'object' && (n = Gt(di(n)))),
         n
}
function FC(n, t) {
  return (n.flags & (t ? 8 : 16)) !== 0
}
function LC(n, t, e) {
  let i = ve(), r = SC(i, n, t, e);
  AC(nu, TC, r, !0)
}
var Sp = class {
  destroy(t) {}
  updateValue(t, e) {}
  swap(t, e) {
    let i = Math.min(t, e), r = Math.max(t, e), o = this.detach(r);
    if (r - i > 1) {
      let s = this.detach(i);
      this.attach(i, o), this.attach(r, s)
    } else
      this.attach(i, o)
  }
  move(t, e) {
    this.attach(e, this.detach(t))
  }
};
function Af(n, t, e, i, r) {
  return n === e && Object.is(t, i) ? 1 : Object.is(r(n, t), r(e, i)) ? -1 : 0
}
function wN(n, t, e) {
  let i, r, o = 0, s = n.length - 1, a = void 0;
  if (Array.isArray(t)) {
    let l = t.length - 1;
    for (; o <= s && o <= l;) {
      let c = n.at(o), d = t[o], m = Af(o, c, o, d, e);
      if (m !== 0) {
        m < 0 && n.updateValue(o, d), o++;
        continue
      }
      let p = n.at(s), h = t[l], _ = Af(s, p, l, h, e);
      if (_ !== 0) {
        _ < 0 && n.updateValue(s, h), s--, l--;
        continue
      }
      let v = e(o, c), k = e(s, p), F = e(o, d);
      if (Object.is(F, k)) {
        let se = e(l, h);
        Object.is(se, v) ? (n.swap(o, s), n.updateValue(s, h), l--, s--) :
                           n.move(s, o),
            n.updateValue(o, d), o++;
        continue
      }
      if (i ??= new Gd, r ??= H0(n, o, s, e), Ip(n, i, o, F))
        n.updateValue(o, d), o++, s++;
      else if (r.has(F))
        i.set(v, n.detach(o)), s--;
      else {
        let se = n.create(o, t[o]);
        n.attach(o, se), o++, s++
      }
    }
    for (; o <= l;) z0(n, i, e, o, t[o]), o++
  } else if (t != null) {
    let l = t[Symbol.iterator](), c = l.next();
    for (; !c.done && o <= s;) {
      let d = n.at(o), m = c.value, p = Af(o, d, o, m, e);
      if (p !== 0)
        p < 0 && n.updateValue(o, m), o++, c = l.next();
      else {
        i ??= new Gd, r ??= H0(n, o, s, e);
        let h = e(o, m);
        if (Ip(n, i, o, h))
          n.updateValue(o, m), o++, s++, c = l.next();
        else if (!r.has(h))
          n.attach(o, n.create(o, m)), o++, s++, c = l.next();
        else {
          let _ = e(o, d);
          i.set(_, n.detach(o)), s--
        }
      }
    }
    for (; !c.done;) z0(n, i, e, n.length, c.value), c = l.next()
  }
  for (; o <= s;) n.destroy(n.detach(s--));
  i?.forEach(l => {n.destroy(l)})
}
function Ip(n, t, e, i) {
  return t !== void 0 && t.has(i) ? (n.attach(e, t.get(i)), t.delete(i), !0) :
                                    !1
}
function z0(n, t, e, i, r) {
  if (Ip(n, t, i, e(i, r)))
    n.updateValue(i, r);
  else {
    let o = n.create(i, r);
    n.attach(i, o)
  }
}
function H0(n, t, e, i) {
  let r = new Set;
  for (let o = t; o <= e; o++) r.add(i(o, n.at(o)));
  return r
}
var Gd = class {
  kvMap = new Map;
  _vMap = void 0;
  has(t) {
    return this.kvMap.has(t)
  }
  delete(t) {
    if (!this.has(t)) return !1;
    let e = this.kvMap.get(t);
    return this._vMap !== void 0 && this._vMap.has(e) ?
               (this.kvMap.set(t, this._vMap.get(e)), this._vMap.delete(e)) :
               this.kvMap.delete(t),
           !0
  }
  get(t) {
    return this.kvMap.get(t)
  }
  set(t, e) {
    if (this.kvMap.has(t)) {
      let i = this.kvMap.get(t);
      this._vMap === void 0 && (this._vMap = new Map);
      let r = this._vMap;
      for (; r.has(i);) i = r.get(i);
      r.set(i, e)
    } else
      this.kvMap.set(t, e)
  }
  forEach(t) {
    for (let [e, i] of this.kvMap)
      if (t(i, e), this._vMap !== void 0) {
        let r = this._vMap;
        for (; r.has(i);) i = r.get(i), t(i, e)
      }
  }
};
function de(n, t) {
  vr('NgControlFlow');
  let e = ve(), i = yo(), r = e[i] !== Ln ? e[i] : -1,
      o = r !== -1 ? Qd(e, bt + r) : void 0, s = 0;
  if (bn(e, i, n)) {
    let a = Me(null);
    try {
      if (o !== void 0 && iC(o, s), n !== -1) {
        let l = bt + n, c = Qd(e, l), d = Ap(e[xe], l),
            m = ws(c, d.tView.ssrId), p = sl(e, d, t, {dehydratedView: m});
        al(c, p, s, ys(d, m))
      }
    } finally {
      Me(a)
    }
  } else if (o !== void 0) {
    let a = nC(o, s);
    a !== void 0 && (a[gt] = t)
  }
}
var Mp = class {
  lContainer;
  $implicit;
  $index;
  constructor(t, e, i) {
    this.lContainer = t, this.$implicit = e, this.$index = i
  }
  get $count() {
    return this.lContainer.length - Rt
  }
};
function Co(n, t) {
  return t
}
var Tp = class {
  hasEmptyBlock;
  trackByFn;
  liveCollection;
  constructor(t, e, i) {
    this.hasEmptyBlock = t, this.trackByFn = e, this.liveCollection = i
  }
};
function Do(n, t, e, i, r, o, s, a, l, c, d, m, p) {
  vr('NgControlFlow');
  let h = ve(), _ = it(), v = l !== void 0, k = ve(),
      F = a ? s.bind(k[an][gt]) : s, se = new Tp(v, F);
  k[bt + n] = se, Wd(h, _, n + 1, t, e, i, r, pr(_.consts, o)),
         v && Wd(h, _, n + 2, l, c, d, m, pr(_.consts, p))
}
var Rp = class extends Sp {
  lContainer;
  hostLView;
  templateTNode;
  operationsCounter = void 0;
  needsIndexUpdate = !1;
  constructor(t, e, i) {
    super(), this.lContainer = t, this.hostLView = e, this.templateTNode = i
  }
  get length() {
    return this.lContainer.length - Rt
  }
  at(t) {
    return this.getLView(t)[gt].$implicit
  }
  attach(t, e) {
    let i = e[_s];
    this.needsIndexUpdate ||= t !== this.length,
    al(this.lContainer, e, t, ys(this.templateTNode, i))
  }
  detach(t) {
    return this.needsIndexUpdate ||= t !== this.length - 1,
           xN(this.lContainer, t)
  }
  create(t, e) {
    let i = ws(this.lContainer, this.templateTNode.tView.ssrId),
        r =
            sl(this.hostLView, this.templateTNode,
               new Mp(this.lContainer, e, t), {dehydratedView: i});
    return this.operationsCounter?.recordCreate(), r
  }
  destroy(t) {
    bu(t[xe], t), this.operationsCounter?.recordDestroy()
  }
  updateValue(t, e) {
    this.getLView(t)[gt].$implicit = e
  }
  reset() {
    this.needsIndexUpdate = !1, this.operationsCounter?.reset()
  }
  updateIndexes() {
    if (this.needsIndexUpdate)
      for (let t = 0; t < this.length; t++) this.getLView(t)[gt].$index = t
  }
  getLView(t) {
    return CN(this.lContainer, t)
  }
};
function Eo(n) {
  let t = Me(null), e = _r();
  try {
    let i = ve(), r = i[xe], o = i[e], s = e + 1, a = Qd(i, s);
    if (o.liveCollection === void 0) {
      let c = Ap(r, s);
      o.liveCollection = new Rp(a, i, c)
    } else
      o.liveCollection.reset();
    let l = o.liveCollection;
    if (wN(l, n, o.trackByFn), l.updateIndexes(), o.hasEmptyBlock) {
      let c = yo(), d = l.length === 0;
      if (bn(i, c, d)) {
        let m = e + 2, p = Qd(i, m);
        if (d) {
          let h = Ap(r, m), _ = ws(p, h.tView.ssrId),
              v = sl(i, h, void 0, {dehydratedView: _});
          al(p, v, 0, ys(h, _))
        } else
          iC(p, 0)
      }
    }
  } finally {
    Me(t)
  }
}
function Qd(n, t) {
  return n[t]
}
function xN(n, t) {
  return Ya(n, t)
}
function CN(n, t) {
  return nC(n, t)
}
function Ap(n, t) {
  return Qp(n, t)
}
function f(n, t, e, i) {
  let r = ve(), o = it(), s = bt + n, a = r[nt],
      l = o.firstCreatePass ? lC(s, o, r, t, vg, Kp(), e, i) : o.data[s],
      c = DN(o, r, l, a, t, n);
  r[s] = c;
  let d = lu(l);
  return vo(l, !0), Fx(a, c, l), !Cg(l) && mu() && vu(o, r, c, l),
         (eR() === 0 || d) && Is(c, r), tR(), d && (_u(o, r, l), mg(o, l, r)),
         i !== null && _g(r, l), f
}
function g() {
  let n = Nt();
  Xp() ? Jp() : (n = n.parent, vo(n, !1));
  let t = n;
  iR(t) && rR(), nR();
  let e = it();
  return e.firstCreatePass && cC(e, t),
         t.classesWithoutHost != null && bR(t) &&
             kp(e, t, ve(), t.classesWithoutHost, !0),
         t.stylesWithoutHost != null && vR(t) &&
             kp(e, t, ve(), t.stylesWithoutHost, !1),
         g
}
function B(n, t, e, i) {
  return f(n, t, e, i), g(), B
}
var DN = (n, t, e, i, r, o) => (hu(!0), Nx(i, r, pR()));
function EN(n, t, e, i, r) {
  let o = t.consts, s = pr(o, i), a = ll(t, n, 8, 'ng-container', s);
  s !== null && fp(a, s, !0);
  let l = pr(o, r);
  return Kp() && Sg(t, e, a, l, vg),
         a.mergedAttrs = vs(a.mergedAttrs, a.attrs),
         t.queries !== null && t.queries.elementStart(t, a), a
}
function Vn(n, t, e) {
  let i = ve(), r = it(), o = n + bt,
      s = r.firstCreatePass ? EN(o, r, i, t, e) : r.data[o];
  vo(s, !0);
  let a = kN(r, i, s, n);
  return i[o] = a, mu() && vu(r, i, a, s), Is(a, i),
         lu(s) && (_u(r, i, s), mg(r, s, i)), e != null && _g(i, s), Vn
}
function jn() {
  let n = Nt(), t = it();
  return Xp() ? Jp() : (n = n.parent, vo(n, !1)),
         t.firstCreatePass && (ig(t, n), Gp(n) && t.queries.elementEnd(n)), jn
}
function vt(n, t, e) {
  return Vn(n, t, e), jn(), vt
}
var kN = (n, t, e, i) => (hu(!0), zA(t[nt], ''));
function ee() {
  return ve()
}
function en(n, t, e) {
  let i = ve(), r = yo();
  if (bn(i, r, t)) {
    let o = it(), s = uu();
    bg(o, s, i, n, t, i[nt], e, !0)
  }
  return en
}
var Yd = 'en-US';
var SN = Yd;
function IN(n) {
  typeof n == 'string' && (SN = n.toLowerCase().replace(/_/g, '-'))
}
var MN = (n, t, e) => {};
function M(n, t, e, i) {
  let r = ve(), o = it(), s = Nt();
  return VC(o, r, r[nt], s, n, t, i), M
}
function TN(n, t, e, i) {
  let r = n.cleanup;
  if (r != null)
    for (let o = 0; o < r.length - 1; o += 2) {
      let s = r[o];
      if (s === e && r[o + 1] === i) {
        let a = t[Sd], l = r[o + 2];
        return a.length > l ? a[l] : null
      }
      typeof s == 'string' && (o += 2)
    }
  return null
}
function VC(n, t, e, i, r, o, s) {
  let a = lu(i), c = n.firstCreatePass ? Rw(n) : null, d = t[gt], m = Tw(t),
      p = !0;
  if (i.type & 3 || s) {
    let h = ci(i, t), _ = s ? s(h) : h, v = m.length,
        k = s ? se => s(ri(se[i.index])) : i.index, F = null;
    if (!s && a && (F = TN(n, t, r, i.index)), F !== null) {
      let se = F.__ngLastListenerFn__ || F;
      se.__ngNextListenerFn__ = o, F.__ngLastListenerFn__ = o, p = !1
    } else {
      o = W0(i, t, d, o), MN(_, r, o);
      let se = e.listen(_, r, o);
      m.push(o, se), c && c.push(r, k, v, v + 1)
    }
  } else
    o = W0(i, t, d, o);
  if (p) {
    let h = i.outputs?.[r], _ = i.hostDirectiveOutputs?.[r];
    if (_ && _.length)
      for (let v = 0; v < _.length; v += 2) {
        let k = _[v], F = _[v + 1];
        U0(i, n, t, k, F, r, o, m, c)
      }
    if (h && h.length)
      for (let v of h) U0(i, n, t, v, r, r, o, m, c)
  }
}
function U0(n, t, e, i, r, o, s, a, l) {
  let c = e[i], m = t.data[i].outputs[r], h = c[m].subscribe(s), _ = a.length;
  a.push(s, h), l && l.push(o, n.index, _, -(_ + 1))
}
function $0(n, t, e, i) {
  let r = Me(null);
  try {
    return Qe(6, t, e), e(i) !== !1
  } catch (o) {
    return zx(n, o), !1
  } finally {
    Qe(7, t, e), Me(r)
  }
}
function W0(n, t, e, i) {
  return function r(o) {
    if (o === Function) return i;
    let s = Ds(n) ? oi(n.index, t) : t;
    kg(s, 5);
    let a = $0(t, e, i, o), l = r.__ngNextListenerFn__;
    for (; l;) a = $0(t, e, l, o) && a, l = l.__ngNextListenerFn__;
    return a
  }
}
function D(n = 1) {
  return hR(n)
}
function RN(n, t) {
  let e = null, i = AA(n);
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    if (o === '*') {
      e = r;
      continue
    }
    if (i === null ? Ox(n, o, !0) : PA(i, o)) return r
  }
  return e
}
function Se(n) {
  let t = ve()[an][Xt];
  if (!t.projection) {
    let e = n ? n.length : 1, i = t.projection = MT(e, null), r = i.slice(),
        o = t.child;
    for (; o !== null;) {
      if (o.type !== 128) {
        let s = n ? RN(o, n) : 0;
        s !== null && (r[s] ? r[s].projectionNext = o : i[s] = o, r[s] = o)
      }
      o = o.next
    }
  }
}
function Z(n, t = 0, e, i, r, o) {
  let s = ve(), a = it(), l = i ? n + 1 : null;
  l !== null && Wd(s, a, l, i, r, o, null, e);
  let c = ll(a, bt + n, 16, null, e || null);
  c.projection === null && (c.projection = t), Jp();
  let m = !s[_s] || Aw();
  s[an][Xt].projection[c.projection] === null && l !== null ?
      AN(s, a, l) :
      m && !Cg(c) && _1(a, s, c)
}
function AN(n, t, e) {
  let i = bt + e, r = t.data[i], o = n[i], s = ws(o, r.tView.ssrId),
      a = sl(n, r, void 0, {dehydratedView: s});
  al(o, a, 0, ys(r, s))
}
function Oe(n, t, e, i) {
  fC(n, t, e, i)
}
function oe(n, t, e) {
  bO(n, t, e)
}
function $(n) {
  let t = ve(), e = it(), i = eg();
  du(i + 1);
  let r = Mg(e, i);
  if (n.dirty && YT(t) === ((r.metadata.flags & 2) === 2)) {
    if (r.matches === null)
      n.reset([]);
    else {
      let o = gC(t, i);
      n.reset(o, sx), n.notifyOnChanges()
    }
    return !0
  }
  return !1
}
function W() {
  return Ig(ve(), eg())
}
function jC(n, t, e, i, r) {
  CO(t, fC(n, e, i, r))
}
function BC(n = 1) {
  du(eg() + n)
}
function ON(n, t, e, i) {
  e >= n.data.length && (n.data[e] = null, n.blueprint[e] = null), t[e] = i
}
function yt(n) {
  let t = sR();
  return Yp(t, bt + n)
}
function E(n, t = '') {
  let e = ve(), i = it(), r = n + bt,
      o = i.firstCreatePass ? ll(i, r, 1, t, null) : i.data[r],
      s = NN(i, e, o, t, n);
  e[r] = s, mu() && vu(i, e, s, o), vo(o, !1)
}
var NN = (n, t, e, i, r) => (hu(!0), jA(t[nt], i));
function Re(n) {
  return at('', n, ''), Re
}
function at(n, t, e) {
  let i = ve(), r = SC(i, n, t, e);
  return r !== Ln && PN(i, _r(), r), at
}
function PN(n, t, e) {
  let i = kw(t, n);
  BA(n[nt], i, e)
}
function Ui(n, t, e) {
  ax(t) && (t = t());
  let i = ve(), r = yo();
  if (bn(i, r, t)) {
    let o = it(), s = uu();
    bg(o, s, i, n, t, i[nt], e, !1)
  }
  return Ui
}
function xr(n, t) {
  let e = ax(n);
  return e && n.set(t), e
}
function $i(n, t) {
  let e = ve(), i = it(), r = Nt();
  return VC(i, e, e[nt], r, n, t), $i
}
function FN(n, t, e) {
  let i = it();
  if (i.firstCreatePass) {
    let r = ii(n);
    Op(e, i.data, i.blueprint, r, !0), Op(t, i.data, i.blueprint, r, !1)
  }
}
function Op(n, t, e, i, r) {
  if (n = Dt(n), Array.isArray(n))
    for (let o = 0; o < n.length; o++) Op(n[o], t, e, i, r);
  else {
    let o = it(), s = ve(), a = Nt(), l = gs(n) ? n : Dt(n.provide), c = _w(n),
        d = a.providerIndexes & 1048575, m = a.directiveStart,
        p = a.providerIndexes >> 20;
    if (gs(n) || !n.multi) {
      let h = new fo(c, r, z), _ = Nf(l, t, r ? d : d + p, m);
      _ === -1 ? (Qf(Nd(a, s), o, l), Of(o, n, t.length), t.push(l),
                  a.directiveStart++, a.directiveEnd++,
                  r && (a.providerIndexes += 1048576), e.push(h), s.push(h)) :
                 (e[_] = h, s[_] = h)
    } else {
      let h = Nf(l, t, d + p, m), _ = Nf(l, t, d, d + p), v = h >= 0 && e[h],
          k = _ >= 0 && e[_];
      if (r && !k || !r && !v) {
        Qf(Nd(a, s), o, l);
        let F = jN(r ? VN : LN, e.length, r, i, c);
        !r && k && (e[_].providerFactory = F), Of(o, n, t.length, 0), t.push(l),
            a.directiveStart++, a.directiveEnd++,
            r && (a.providerIndexes += 1048576), e.push(F), s.push(F)
      } else {
        let F = zC(e[r ? _ : h], c, !r && i);
        Of(o, n, h > -1 ? h : _, F)
      }
      !r && i && k && e[_].componentProviders++
    }
  }
}
function Of(n, t, e, i) {
  let r = gs(t), o = LT(t);
  if (r || o) {
    let l = (o ? Dt(t.useClass) : t).prototype.ngOnDestroy;
    if (l) {
      let c = n.destroyHooks || (n.destroyHooks = []);
      if (!r && t.multi) {
        let d = c.indexOf(e);
        d === -1 ? c.push(e, [i, l]) : c[d + 1].push(i, l)
      } else
        c.push(e, l)
    }
  }
}
function zC(n, t, e) {
  return e && n.componentProviders++, n.multi.push(t) - 1
}
function Nf(n, t, e, i) {
  for (let r = e; r < i; r++)
    if (t[r] === n) return r;
  return -1
}
function LN(n, t, e, i) {
  return Np(this.multi, [])
}
function VN(n, t, e, i) {
  let r = this.multi, o;
  if (this.providerFactory) {
    let s = this.providerFactory.componentProviders,
        a = Ga(e, e[xe], this.providerFactory.index, i);
    o = a.slice(0, s), Np(r, o);
    for (let l = s; l < a.length; l++) o.push(a[l])
  } else
    o = [], Np(r, o);
  return o
}
function Np(n, t) {
  for (let e = 0; e < n.length; e++) {
    let i = n[e];
    t.push(i())
  }
  return t
}
function jN(n, t, e, i, r) {
  let o = new fo(n, e, z);
  return o.multi = [], o.index = t, o.componentProviders = 0, zC(o, r, i && !e),
         o
}
function ye(n, t = []) {
  return e => {
    e.providersResolver = (i, r) => FN(i, r ? r(n) : n, t)
  }
}
function HC(n, t, e) {
  let i = nl() + n, r = ve();
  return r[i] === Ln ? Ag(r, i, e ? t.call(e) : t()) : GO(r, i)
}
function ko(n, t, e, i) {
  return $C(ve(), nl(), n, t, e, i)
}
function Rs(n, t, e, i, r) {
  return WC(ve(), nl(), n, t, e, i, r)
}
function UC(n, t) {
  let e = n[t];
  return e === Ln ? void 0 : e
}
function $C(n, t, e, i, r, o) {
  let s = t + e;
  return bn(n, s, r) ? Ag(n, s + 1, o ? i.call(o, r) : i(r)) : UC(n, s + 1)
}
function WC(n, t, e, i, r, o, s) {
  let a = t + e;
  return QO(n, a, r, o) ? Ag(n, a + 2, s ? i.call(s, r, o) : i(r, o)) :
                          UC(n, a + 2)
}
function Cr(n, t) {
  let e = it(), i, r = n + bt;
  e.firstCreatePass ?
      (i = BN(t, e.pipeRegistry), e.data[r] = i,
       i.onDestroy && (e.destroyHooks ??= []).push(r, i.onDestroy)) :
      i = e.data[r];
  let o = i.factory || (i.factory = ao(i.type, !0)), s, a = qt(z);
  try {
    let l = Od(!1), c = o();
    return Od(l), ON(e, ve(), r, c), c
  } finally {
    qt(a)
  }
}
function BN(n, t) {
  if (t)
    for (let e = t.length - 1; e >= 0; e--) {
      let i = t[e];
      if (n === i.name) return i
    }
}
function As(n, t, e) {
  let i = n + bt, r = ve(), o = Yp(r, i);
  return GC(r, i) ? $C(r, nl(), t, o.transform, e, o) : o.transform(e)
}
function qC(n, t, e, i) {
  let r = n + bt, o = ve(), s = Yp(o, r);
  return GC(o, r) ? WC(o, nl(), t, s.transform, e, i, s) : s.transform(e, i)
}
function GC(n, t) {
  return n[xe].data[t].pure
}
function dl(n, t) {
  return wu(n, t)
}
var gd = null;
function zN(n) {
  gd !== null &&
          (n.defaultEncapsulation !== gd.defaultEncapsulation ||
           n.preserveWhitespaces !== gd.preserveWhitespaces) ||
      (gd = n)
}
var gr = class {
  full;
  major;
  minor;
  patch;
  constructor(t) {
    this.full = t;
    let e = t.split('.');
    this.major = e[0], this.minor = e[1], this.patch = e.slice(2).join('.')
  }
}
, Lg = new gr('19.2.3'), Pp = class {
  ngModuleFactory;
  componentFactories;
  constructor(t, e) {
    this.ngModuleFactory = t, this.componentFactories = e
  }
}
, Mu = (() => {
    class n {
      compileModuleSync(e) {
        return new $d(e)
      }
      compileModuleAsync(e) {
        return Promise.resolve(this.compileModuleSync(e))
      }
      compileModuleAndAllComponentsSync(e) {
        let i = this.compileModuleSync(e), r = mw(e),
            o = Rx(r.declarations).reduce((s, a) => {
              let l = fr(a);
              return l && s.push(new go(l)), s
            }, []);
        return new Pp(i, o)
      }
      compileModuleAndAllComponentsAsync(e) {
        return Promise.resolve(this.compileModuleAndAllComponentsSync(e))
      }
      clearCache() {}
      clearCacheFor(e) {}
      getModuleId(e) {}
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  HN = new w('');
function UN(n, t, e) {
  let i = new $d(e);
  return Promise.resolve(i)
}
function q0(n) {
  for (let t = n.length - 1; t >= 0; t--)
    if (n[t] !== void 0) return n[t]
}
var $N = (() => {
  class n {
    zone = u(U);
    changeDetectionScheduler = u(po);
    applicationRef = u(Yt);
    _onMicrotaskEmptySubscription;
    initialize() {
      this._onMicrotaskEmptySubscription ||
          (this._onMicrotaskEmptySubscription =
               this.zone.onMicrotaskEmpty.subscribe({
                 next: () => {
                   this.changeDetectionScheduler.runningTick ||
                       this.zone.run(() => {this.applicationRef.tick()})
                 }
               }))
    }
    ngOnDestroy() {
      this._onMicrotaskEmptySubscription?.unsubscribe()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function WN(
    {ngZoneFactory: n, ignoreChangesOutsideZone: t, scheduleInRootZone: e}) {
  return n ??= () => new U(ae(y({}, QC()), {scheduleInRootZone: e})), [
    {provide: U, useFactory: n}, {
      provide: ps,
      multi: !0,
      useFactory: () => {
        let i = u($N, {optional: !0});
        return () => i.initialize()
      }
    },
    {
      provide: ps,
      multi: !0,
      useFactory: () => {
        let i = u(qN);
        return () => {
          i.initialize()
        }
      }
    },
    t === !0 ? {provide: tx, useValue: !0} : [],
    {provide: nx, useValue: e ?? ex}
  ]
}
function QC(n) {
  return {
    enableLongStackTrace: !1,
        shouldCoalesceEventChangeDetection: n?.eventCoalescing ?? !1,
        shouldCoalesceRunChangeDetection: n?.runCoalescing ?? !1
  }
}
var qN = (() => {
  class n {
    subscription = new ge;
    initialized = !1;
    zone = u(U);
    pendingTasks = u(zi);
    initialize() {
      if (this.initialized) return;
      this.initialized = !0;
      let e = null;
      !this.zone.isStable && !this.zone.hasPendingMacrotasks &&
          !this.zone.hasPendingMicrotasks && (e = this.pendingTasks.add()),
          this.zone.runOutsideAngular(
              () => {this.subscription.add(this.zone.onStable.subscribe(() => {
                U.assertNotInAngularZone(),
                queueMicrotask(
                    () => {
                        e !== null && !this.zone.hasPendingMacrotasks &&
                        !this.zone.hasPendingMicrotasks &&
                        (this.pendingTasks.remove(e), e = null)})
              }))}),
          this.subscription.add(this.zone.onUnstable.subscribe(
              () => {U.assertInAngularZone(), e ??= this.pendingTasks.add()}))
    }
    ngOnDestroy() {
      this.subscription.unsubscribe()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
var GN = (() => {
  class n {
    appRef = u(Yt);
    taskService = u(zi);
    ngZone = u(U);
    zonelessEnabled = u(sg);
    tracing = u(Ts, {optional: !0});
    disableScheduling = u(tx, {optional: !0}) ?? !1;
    zoneIsDefined = typeof Zone < 'u' && !!Zone.root.run;
    schedulerTickApplyArgs = [{data: {__scheduler_tick__: !0}}];
    subscriptions = new ge;
    angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(Fd) : null;
    scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined &&
        (u(nx, {optional: !0}) ?? !1);
    cancelScheduledCallback = null;
    useMicrotaskScheduler = !1;
    runningTick = !1;
    pendingRenderTaskId = null;
    constructor() {
      this.subscriptions.add(this.appRef.afterTick.subscribe(
          () => {this.runningTick || this.cleanup()})),
          this.subscriptions.add(this.ngZone.onUnstable.subscribe(
              () => {this.runningTick || this.cleanup()})),
          this.disableScheduling ||= !this.zonelessEnabled &&
          (this.ngZone instanceof Ld || !this.zoneIsDefined)
    }
    notify(e) {
      if (!this.zonelessEnabled && e === 5) return;
      let i = !1;
      switch (e) {
        case 0: {
          this.appRef.dirtyFlags |= 2;
          break
        }
        case 3:
        case 2:
        case 4:
        case 5:
        case 1: {
          this.appRef.dirtyFlags |= 4;
          break
        }
        case 6: {
          this.appRef.dirtyFlags |= 2, i = !0;
          break
        }
        case 12: {
          this.appRef.dirtyFlags |= 16, i = !0;
          break
        }
        case 13: {
          this.appRef.dirtyFlags |= 2, i = !0;
          break
        }
        case 11: {
          i = !0;
          break
        }
        case 9:
        case 8:
        case 7:
        case 10:
        default:
          this.appRef.dirtyFlags |= 8
      }
      if (this.appRef.tracingSnapshot =
              this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null,
          !this.shouldScheduleTick(i))
        return;
      let r = this.useMicrotaskScheduler ? b0 : ix;
      this.pendingRenderTaskId = this.taskService.add(),
      this.scheduleInRootZone ?
          this.cancelScheduledCallback =
              Zone.root.run(() => r(() => this.tick())) :
          this.cancelScheduledCallback =
              this.ngZone.runOutsideAngular(() => r(() => this.tick()))
    }
    shouldScheduleTick(e) {
      return !(
          this.disableScheduling && !e || this.appRef.destroyed ||
          this.pendingRenderTaskId !== null || this.runningTick ||
          this.appRef._runningTick ||
          !this.zonelessEnabled && this.zoneIsDefined &&
              Zone.current.get(Fd + this.angularZoneId))
    }
    tick() {
      if (this.runningTick || this.appRef.destroyed) return;
      if (this.appRef.dirtyFlags === 0) {
        this.cleanup();
        return
      }
      !this.zonelessEnabled && this.appRef.dirtyFlags&7 &&
          (this.appRef.dirtyFlags |= 1);
      let e = this.taskService.add();
      try {
        this.ngZone.run(
            () => {this.runningTick = !0, this.appRef._tick()}, void 0,
            this.schedulerTickApplyArgs)
      } catch (i) {
        throw this.taskService.remove(e), i
      } finally {
        this.cleanup()
      }
      this.useMicrotaskScheduler = !0,
      b0(() => {this.useMicrotaskScheduler = !1, this.taskService.remove(e)})
    }
    ngOnDestroy() {
      this.subscriptions.unsubscribe(), this.cleanup()
    }
    cleanup() {
      if (this.runningTick = !1, this.cancelScheduledCallback?.(),
          this.cancelScheduledCallback = null,
          this.pendingRenderTaskId !== null) {
        let e = this.pendingRenderTaskId;
        this.pendingRenderTaskId = null, this.taskService.remove(e)
      }
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function QN() {
  return typeof $localize < 'u' && $localize.locale || Yd
}
var Tu = new w('', {
  providedIn: 'root',
  factory: () => u(Tu, ke.Optional | ke.SkipSelf) || QN()
});
var Zd = new w(''), YN = new w('');
function ja(n) {
  return !n.moduleRef
}
function ZN(n) {
  let t = ja(n) ? n.r3Injector : n.moduleRef.injector, e = t.get(U);
  return e.run(() => {
    ja(n) ? n.r3Injector.resolveInjectorInitializers() :
            n.moduleRef.resolveInjectorInitializers();
    let i = t.get(ln, null), r;
    if (e.runOutsideAngular(() => {r = e.onError.subscribe({
                              next: o => {
                                i.handleError(o)
                              }
                            })}),
        ja(n)) {
      let o = () => t.destroy(), s = n.platformInjector.get(Zd);
      s.add(o), t.onDestroy(() => {r.unsubscribe(), s.delete(o)})
    } else {
      let o = () => n.moduleRef.destroy(), s = n.platformInjector.get(Zd);
      s.add(o), n.moduleRef.onDestroy(() => {
        wd(n.allPlatformModules, n.moduleRef),
        r.unsubscribe(),
        s.delete(o)
      })
    }
    return XN(i, e, () => {
      let o = t.get(EC);
      return o.runInitializers(), o.donePromise.then(() => {
        let s = t.get(Tu, Yd);
        if (IN(s || Yd), !t.get(YN, !0))
          return ja(n) ? t.get(Yt) :
                         (n.allPlatformModules.push(n.moduleRef), n.moduleRef);
        if (ja(n)) {
          let l = t.get(Yt);
          return n.rootComponent !== void 0 && l.bootstrap(n.rootComponent), l
        } else
          return KN(n.moduleRef, n.allPlatformModules), n.moduleRef
      })
    })
  })
}
function KN(n, t) {
  let e = n.injector.get(Yt);
  if (n._bootstrapComponents.length > 0)
    n._bootstrapComponents.forEach(i => e.bootstrap(i));
  else if (n.instance.ngDoBootstrap)
    n.instance.ngDoBootstrap(e);
  else
    throw new S(-403, !1);
  t.push(n)
}
function XN(n, t, e) {
  try {
    let i = e();
    return wr(i) ?
        i.catch(r => {throw t.runOutsideAngular(() => n.handleError(r)), r}) :
        i
  } catch (i) {
    throw t.runOutsideAngular(() => n.handleError(i)), i
  }
}
var YC = (() => {
  class n {
    _injector;
    _modules = [];
    _destroyListeners = [];
    _destroyed = !1;
    constructor(e) {
      this._injector = e
    }
    bootstrapModuleFactory(e, i) {
      let r = i?.scheduleInRootZone,
          o = () =>
              jR(i?.ngZone,
                 ae(y({}, QC({
                        eventCoalescing: i?.ngZoneEventCoalescing,
                        runCoalescing: i?.ngZoneRunCoalescing
                      })),
                    {scheduleInRootZone: r})),
          s = i?.ignoreChangesOutsideZone,
          a =
              [
                WN({ngZoneFactory: o, ignoreChangesOutsideZone: s}),
                {provide: po, useExisting: GN}
              ],
          l = AO(e.moduleType, this.injector, a);
      return ZN({
        moduleRef: l,
        allPlatformModules: this._modules,
        platformInjector: this.injector
      })
    }
    bootstrapModule(e, i = []) {
      let r = kC({}, i);
      return UN(this.injector, r, e)
          .then(o => this.bootstrapModuleFactory(o, r))
    }
    onDestroy(e) {
      this._destroyListeners.push(e)
    }
    get injector() {
      return this._injector
    }
    destroy() {
      if (this._destroyed) throw new S(404, !1);
      this._modules.slice().forEach(i => i.destroy()),
          this._destroyListeners.forEach(i => i());
      let e = this._injector.get(Zd, null);
      e && (e.forEach(i => i()), e.clear()), this._destroyed = !0
    }
    get destroyed() {
      return this._destroyed
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(he))
    };
    static \u0275prov =
        C({token: n, factory: n.\u0275fac, providedIn: 'platform'})
  } return n
})(),
    Ua = null, ZC = new w('');
function JN(n) {
  if (Ua && !Ua.get(ZC, !1)) throw new S(400, !1);
  JO(), Ua = n;
  let t = n.get(YC);
  return nP(n), t
}
function Vg(n, t, e = []) {
  let i = `Platform: ${t}`, r = new w(i);
  return (o = []) => {
    let s = KC();
    if (!s || s.injector.get(ZC, !1)) {
      let a = [...e, ...o, {provide: r, useValue: !0}];
      n ? n(a) : JN(eP(a, i))
    }
    return tP(r)
  }
}
function eP(n = [], t) {
  return he.create({
    name: t,
    providers: [
      {provide: ru, useValue: 'platform'},
      {provide: Zd, useValue: new Set([() => Ua = null])}, ...n
    ]
  })
}
function tP(n) {
  let t = KC();
  if (!t) throw new S(401, !1);
  return t
}
function KC() {
  return Ua?.get(YC) ?? null
}
function nP(n) {
  let t = n.get(cg, null);
  Kt(n, () => {t?.forEach(e => e())})
}
var Ae = (() => {
  class n {
    static __NG_ELEMENT_ID__ = iP
  } return n
})();
function iP(n) {
  return rP(Nt(), ve(), (n & 16) === 16)
}
function rP(n, t, e) {
  if (Ds(n) && !e) {
    let i = oi(n.index, t);
    return new Za(i, i)
  } else if (n.type & 175) {
    let i = t[an];
    return new Za(i, t)
  }
  return null
}
var Fp = class {
  constructor() {}
  supports(t) {
    return CC(t)
  }
  create(t) {
    return new Lp(t)
  }
}
, oP = (n, t) => t, Lp = class {
  length = 0;
  collection;
  _linkedRecords = null;
  _unlinkedRecords = null;
  _previousItHead = null;
  _itHead = null;
  _itTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _movesHead = null;
  _movesTail = null;
  _removalsHead = null;
  _removalsTail = null;
  _identityChangesHead = null;
  _identityChangesTail = null;
  _trackByFn;
  constructor(t) {
    this._trackByFn = t || oP
  }
  forEachItem(t) {
    let e;
    for (e = this._itHead; e !== null; e = e._next) t(e)
  }
  forEachOperation(t) {
    let e = this._itHead, i = this._removalsHead, r = 0, o = null;
    for (; e || i;) {
      let s = !i || e && e.currentIndex < G0(i, r, o) ? e : i, a = G0(s, r, o),
          l = s.currentIndex;
      if (s === i)
        r--, i = i._nextRemoved;
      else if (e = e._next, s.previousIndex == null)
        r++;
      else {
        o || (o = []);
        let c = a - r, d = l - r;
        if (c != d) {
          for (let p = 0; p < c; p++) {
            let h = p < o.length ? o[p] : o[p] = 0, _ = h + p;
            d <= _ && _ < c && (o[p] = h + 1)
          }
          let m = s.previousIndex;
          o[m] = d - c
        }
      }
      a !== l && t(s, a, l)
    }
  }
  forEachPreviousItem(t) {
    let e;
    for (e = this._previousItHead; e !== null; e = e._nextPrevious) t(e)
  }
  forEachAddedItem(t) {
    let e;
    for (e = this._additionsHead; e !== null; e = e._nextAdded) t(e)
  }
  forEachMovedItem(t) {
    let e;
    for (e = this._movesHead; e !== null; e = e._nextMoved) t(e)
  }
  forEachRemovedItem(t) {
    let e;
    for (e = this._removalsHead; e !== null; e = e._nextRemoved) t(e)
  }
  forEachIdentityChange(t) {
    let e;
    for (e = this._identityChangesHead; e !== null; e = e._nextIdentityChange)
      t(e)
  }
  diff(t) {
    if (t == null && (t = []), !CC(t)) throw new S(900, !1);
    return this.check(t) ? this : null
  }
  onDestroy() {}
  check(t) {
    this._reset();
    let e = this._itHead, i = !1, r, o, s;
    if (Array.isArray(t)) {
      this.length = t.length;
      for (let a = 0; a < this.length; a++)
        o = t[a], s = this._trackByFn(a, o),
        e === null || !Object.is(e.trackById, s) ?
            (e = this._mismatch(e, o, s, a), i = !0) :
            (i && (e = this._verifyReinsertion(e, o, s, a)),
             Object.is(e.item, o) || this._addIdentityChange(e, o)),
        e = e._next
    } else
      r = 0, qO(t, a => {
        s = this._trackByFn(r, a),
        e === null || !Object.is(e.trackById, s) ?
            (e = this._mismatch(e, a, s, r), i = !0) :
            (i && (e = this._verifyReinsertion(e, a, s, r)),
             Object.is(e.item, a) || this._addIdentityChange(e, a)),
        e = e._next,
        r++
      }),
      this.length = r;
    return this._truncate(e), this.collection = t, this.isDirty
  }
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null ||
        this._removalsHead !== null || this._identityChangesHead !== null
  }
  _reset() {
    if (this.isDirty) {
      let t;
      for (t = this._previousItHead = this._itHead; t !== null; t = t._next)
        t._nextPrevious = t._next;
      for (t = this._additionsHead; t !== null; t = t._nextAdded)
        t.previousIndex = t.currentIndex;
      for (this._additionsHead = this._additionsTail = null,
          t = this._movesHead;
           t !== null; t = t._nextMoved)
        t.previousIndex = t.currentIndex;
      this._movesHead = this._movesTail = null,
      this._removalsHead = this._removalsTail = null,
      this._identityChangesHead = this._identityChangesTail = null
    }
  }
  _mismatch(t, e, i, r) {
    let o;
    return t === null ? o = this._itTail : (o = t._prev, this._remove(t)),
                        t = this._unlinkedRecords === null ?
               null :
               this._unlinkedRecords.get(i, null),
                        t !== null ?
               (Object.is(t.item, e) || this._addIdentityChange(t, e),
                this._reinsertAfter(t, o, r)) :
               (t = this._linkedRecords === null ?
                    null :
                    this._linkedRecords.get(i, r),
                t !== null ?
                    (Object.is(t.item, e) || this._addIdentityChange(t, e),
                     this._moveAfter(t, o, r)) :
                    t = this._addAfter(new Vp(e, i), o, r)),
                        t
  }
  _verifyReinsertion(t, e, i, r) {
    let o = this._unlinkedRecords === null ? null :
                                             this._unlinkedRecords.get(i, null);
    return o !== null ? t = this._reinsertAfter(o, t._prev, r) :
                        t.currentIndex != r &&
                   (t.currentIndex = r, this._addToMoves(t, r)),
                        t
  }
  _truncate(t) {
    for (; t !== null;) {
      let e = t._next;
      this._addToRemovals(this._unlink(t)), t = e
    }
    this._unlinkedRecords !== null && this._unlinkedRecords.clear(),
        this._additionsTail !== null && (this._additionsTail._nextAdded = null),
        this._movesTail !== null && (this._movesTail._nextMoved = null),
        this._itTail !== null && (this._itTail._next = null),
        this._removalsTail !== null && (this._removalsTail._nextRemoved = null),
        this._identityChangesTail !== null &&
        (this._identityChangesTail._nextIdentityChange = null)
  }
  _reinsertAfter(t, e, i) {
    this._unlinkedRecords !== null && this._unlinkedRecords.remove(t);
    let r = t._prevRemoved, o = t._nextRemoved;
    return r === null ? this._removalsHead = o : r._nextRemoved = o,
                        o === null ? this._removalsTail = r :
                                     o._prevRemoved = r,
                        this._insertAfter(t, e, i), this._addToMoves(t, i), t
  }
  _moveAfter(t, e, i) {
    return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i),
           t
  }
  _addAfter(t, e, i) {
    return this._insertAfter(t, e, i),
           this._additionsTail === null ?
               this._additionsTail = this._additionsHead = t :
               this._additionsTail = this._additionsTail._nextAdded = t,
               t
  }
  _insertAfter(t, e, i) {
    let r = e === null ? this._itHead : e._next;
    return t._next = r, t._prev = e,
           r === null ? this._itTail = t : r._prev = t,
           e === null ? this._itHead = t : e._next = t,
           this._linkedRecords === null && (this._linkedRecords = new Kd),
           this._linkedRecords.put(t), t.currentIndex = i, t
  }
  _remove(t) {
    return this._addToRemovals(this._unlink(t))
  }
  _unlink(t) {
    this._linkedRecords !== null && this._linkedRecords.remove(t);
    let e = t._prev, i = t._next;
    return e === null ? this._itHead = i : e._next = i,
                        i === null ? this._itTail = e : i._prev = e, t
  }
  _addToMoves(t, e) {
    return t.previousIndex === e ||
               (this._movesTail === null ?
                    this._movesTail = this._movesHead = t :
                    this._movesTail = this._movesTail._nextMoved = t),
           t
  }
  _addToRemovals(t) {
    return this._unlinkedRecords === null && (this._unlinkedRecords = new Kd),
           this._unlinkedRecords.put(t), t.currentIndex = null,
                                         t._nextRemoved = null,
                                         this._removalsTail === null ?
               (this._removalsTail = this._removalsHead = t,
                t._prevRemoved = null) :
               (t._prevRemoved = this._removalsTail,
                this._removalsTail = this._removalsTail._nextRemoved = t),
                                         t
  }
  _addIdentityChange(t, e) {
    return t.item = e,
           this._identityChangesTail === null ?
               this._identityChangesTail = this._identityChangesHead = t :
               this._identityChangesTail =
                   this._identityChangesTail._nextIdentityChange = t,
           t
  }
}
, Vp = class {
  item;
  trackById;
  currentIndex = null;
  previousIndex = null;
  _nextPrevious = null;
  _prev = null;
  _next = null;
  _prevDup = null;
  _nextDup = null;
  _prevRemoved = null;
  _nextRemoved = null;
  _nextAdded = null;
  _nextMoved = null;
  _nextIdentityChange = null;
  constructor(t, e) {
    this.item = t, this.trackById = e
  }
}
, jp = class {
  _head = null;
  _tail = null;
  add(t) {
    this._head === null ?
        (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) :
        (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null,
         this._tail = t)
  }
  get(t, e) {
    let i;
    for (i = this._head; i !== null; i = i._nextDup)
      if ((e === null || e <= i.currentIndex) && Object.is(i.trackById, t))
        return i;
    return null
  }
  remove(t) {
    let e = t._prevDup, i = t._nextDup;
    return e === null ? this._head = i : e._nextDup = i,
                        i === null ? this._tail = e : i._prevDup = e,
                        this._head === null
  }
}
, Kd = class {
  map = new Map;
  put(t) {
    let e = t.trackById, i = this.map.get(e);
    i || (i = new jp, this.map.set(e, i)), i.add(t)
  }
  get(t, e) {
    let i = t, r = this.map.get(i);
    return r ? r.get(t, e) : null
  }
  remove(t) {
    let e = t.trackById;
    return this.map.get(e).remove(t) && this.map.delete(e), t
  }
  get isEmpty() {
    return this.map.size === 0
  }
  clear() {
    this.map.clear()
  }
};
function G0(n, t, e) {
  let i = n.previousIndex;
  if (i === null) return i;
  let r = 0;
  return e && i < e.length && (r = e[i]), i + t + r
}
var Bp = class {
  constructor() {}
  supports(t) {
    return t instanceof Map || Rg(t)
  }
  create() {
    return new zp
  }
}
, zp = class {
  _records = new Map;
  _mapHead = null;
  _appendAfter = null;
  _previousMapHead = null;
  _changesHead = null;
  _changesTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _removalsHead = null;
  _removalsTail = null;
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null ||
        this._removalsHead !== null
  }
  forEachItem(t) {
    let e;
    for (e = this._mapHead; e !== null; e = e._next) t(e)
  }
  forEachPreviousItem(t) {
    let e;
    for (e = this._previousMapHead; e !== null; e = e._nextPrevious) t(e)
  }
  forEachChangedItem(t) {
    let e;
    for (e = this._changesHead; e !== null; e = e._nextChanged) t(e)
  }
  forEachAddedItem(t) {
    let e;
    for (e = this._additionsHead; e !== null; e = e._nextAdded) t(e)
  }
  forEachRemovedItem(t) {
    let e;
    for (e = this._removalsHead; e !== null; e = e._nextRemoved) t(e)
  }
  diff(t) {
    if (!t)
      t = new Map;
    else if (!(t instanceof Map || Rg(t)))
      throw new S(900, !1);
    return this.check(t) ? this : null
  }
  onDestroy() {}
  check(t) {
    this._reset();
    let e = this._mapHead;
    if (this._appendAfter = null, this._forEach(t, (i, r) => {
          if (e && e.key === r)
            this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next;
          else {
            let o = this._getOrCreateRecordForKey(r, i);
            e = this._insertBeforeOrAppend(e, o)
          }
        }), e) {
      e._prev && (e._prev._next = null), this._removalsHead = e;
      for (let i = e; i !== null; i = i._nextRemoved)
        i === this._mapHead && (this._mapHead = null),
            this._records.delete(i.key),
            i._nextRemoved = i._next, i.previousValue = i.currentValue,
            i.currentValue = null, i._prev = null, i._next = null
    }
    return this._changesTail && (this._changesTail._nextChanged = null),
           this._additionsTail && (this._additionsTail._nextAdded = null),
           this.isDirty
  }
  _insertBeforeOrAppend(t, e) {
    if (t) {
      let i = t._prev;
      return e._next = t, e._prev = i, t._prev = e, i && (i._next = e),
             t === this._mapHead && (this._mapHead = e), this._appendAfter = t,
             t
    }
    return this._appendAfter ?
               (this._appendAfter._next = e, e._prev = this._appendAfter) :
               this._mapHead = e,
               this._appendAfter = e, null
  }
  _getOrCreateRecordForKey(t, e) {
    if (this._records.has(t)) {
      let r = this._records.get(t);
      this._maybeAddToChanges(r, e);
      let o = r._prev, s = r._next;
      return o && (o._next = s), s && (s._prev = o), r._next = null,
                                                     r._prev = null, r
    }
    let i = new Hp(t);
    return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i),
                                    i
  }
  _reset() {
    if (this.isDirty) {
      let t;
      for (this._previousMapHead = this._mapHead, t = this._previousMapHead;
           t !== null; t = t._next)
        t._nextPrevious = t._next;
      for (t = this._changesHead; t !== null; t = t._nextChanged)
        t.previousValue = t.currentValue;
      for (t = this._additionsHead; t != null; t = t._nextAdded)
        t.previousValue = t.currentValue;
      this._changesHead = this._changesTail = null,
      this._additionsHead = this._additionsTail = null,
      this._removalsHead = null
    }
  }
  _maybeAddToChanges(t, e) {
    Object.is(e, t.currentValue) ||
        (t.previousValue = t.currentValue, t.currentValue = e,
         this._addToChanges(t))
  }
  _addToAdditions(t) {
    this._additionsHead === null ?
        this._additionsHead = this._additionsTail = t :
        (this._additionsTail._nextAdded = t, this._additionsTail = t)
  }
  _addToChanges(t) {
    this._changesHead === null ?
        this._changesHead = this._changesTail = t :
        (this._changesTail._nextChanged = t, this._changesTail = t)
  }
  _forEach(t, e) {
    t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i))
  }
}
, Hp = class {
  key;
  previousValue = null;
  currentValue = null;
  _nextPrevious = null;
  _next = null;
  _prev = null;
  _nextAdded = null;
  _nextRemoved = null;
  _nextChanged = null;
  constructor(t) {
    this.key = t
  }
};
function Q0() {
  return new ui([new Fp])
}
var ui = (() => {
  class n {
    factories;
    static \u0275prov = C({token: n, providedIn: 'root', factory: Q0});
    constructor(e) {
      this.factories = e
    }
    static create(e, i) {
      if (i != null) {
        let r = i.factories.slice();
        e = e.concat(r)
      }
      return new n(e)
    }
    static extend(e) {
      return {
        provide: n, useFactory: i => n.create(e, i || Q0()),
                                deps: [[n, new Ja, new bo]]
      }
    }
    find(e) {
      let i = this.factories.find(r => r.supports(e));
      if (i != null) return i;
      throw new S(901, !1)
    }
  } return n
})();
function Y0() {
  return new Ru([new Bp])
}
var Ru = (() => {
  class n {
    static \u0275prov = C({token: n, providedIn: 'root', factory: Y0});
    factories;
    constructor(e) {
      this.factories = e
    }
    static create(e, i) {
      if (i) {
        let r = i.factories.slice();
        e = e.concat(r)
      }
      return new n(e)
    }
    static extend(e) {
      return {
        provide: n, useFactory: i => n.create(e, i || Y0()),
                                deps: [[n, new Ja, new bo]]
      }
    }
    find(e) {
      let i = this.factories.find(r => r.supports(e));
      if (i) return i;
      throw new S(901, !1)
    }
  } return n
})();
var XC = Vg(null, 'core', []), JC = (() => {
                                 class n {
                                   constructor(e) {}
                                   static \u0275fac = function(i) {
                                     return new (i || n)(A(Yt))
                                   };
                                   static \u0275mod = j({type: n});
                                   static \u0275inj = V({})
                                 } return n
                               })();
function q(n) {
  return typeof n == 'boolean' ? n : n != null && n !== 'false'
}
function st(n, t = NaN) {
  return !isNaN(parseFloat(n)) && !isNaN(Number(n)) ? Number(n) : t
}
function tn(n) {
  return Ry(n)
}
function mi(n, t) {
  return nf(n, t?.equal)
}
var Up = class {
  [$t];
  constructor(t) {
    this[$t] = t
  }
  destroy() {
    this[$t].destroy()
  }
};
function ul(n, t) {
  !t?.injector && su(ul);
  let e = t?.injector ?? u(he), i = t?.manualCleanup !== !0 ? e.get(ks) : null,
      r, o = e.get(ug, null, {optional: !0}), s = e.get(po);
  return o !== null && !t?.forceRoot ?
             (r = lP(o.view, s, n),
              i instanceof Pd && i._lView === o.view && (i = null)) :
             r = cP(n, e.get(DC), s),
             r.injector = e,
             i !== null && (r.onDestroyFn = i.onDestroy(() => r.destroy())),
             new Up(r)
}
var eD = ae(y({}, Ko), {
  consumerIsAlwaysLive: !0,
  consumerAllowSignalWrites: !0,
  dirty: !0,
  hasRun: !1,
  cleanupFns: void 0,
  zone: null,
  kind: 'effect',
  onDestroyFn: Qa,
  run() {
    if (this.dirty = !1, this.hasRun && !Lc(this)) return;
    this.hasRun = !0;
    let n = i => (this.cleanupFns ??= []).push(i), t = Ma(this), e = Td(!1);
    try {
      this.maybeCleanup(), this.fn(n)
    } finally {
      Td(e), Fc(this, t)
    }
  },
  maybeCleanup() {
    if (this.cleanupFns?.length) try {
        for (; this.cleanupFns.length;) this.cleanupFns.pop()()
      } finally {
        this.cleanupFns = []
      }
  }
}),
    sP = ae(y({}, eD), {
      consumerMarkedDirty() {
        this.scheduler.schedule(this), this.notifier.notify(12)
      },
      destroy() {
        Ta(this), this.onDestroyFn(), this.maybeCleanup(),
            this.scheduler.remove(this)
      }
    }),
    aP = ae(y({}, eD), {
      consumerMarkedDirty() {
        this.view[be] |= 8192, Es(this.view), this.notifier.notify(13)
      },
      destroy() {
        Ta(this), this.onDestroyFn(), this.maybeCleanup(),
            this.view[co]?.delete(this)
      }
    });
function lP(n, t, e) {
  let i = Object.create(aP);
  return i.view = n, i.zone = typeof Zone < 'u' ? Zone.current : null,
         i.notifier = t, i.fn = e, n[co] ??= new Set, n[co].add(i),
         i.consumerMarkedDirty(i), i
}
function cP(n, t, e) {
  let i = Object.create(sP);
  return i.fn = n, i.scheduler = t, i.notifier = e,
         i.zone = typeof Zone < 'u' ? Zone.current : null,
         i.scheduler.schedule(i), i.notifier.notify(12), i
}
function Au(n, t) {
  let e = fr(n), i = t.elementInjector || ou();
  return new go(e).create(
      i, t.projectableNodes, t.hostElement, t.environmentInjector)
}
function tD(n) {
  let t = fr(n);
  if (!t) return null;
  let e = new go(t);
  return {
    get selector() {
      return e.selector
    }
    , get type() {
      return e.componentType
    }
    , get inputs() {
      return e.inputs
    }
    , get outputs() {
      return e.outputs
    }
    , get ngContentSelectors() {
      return e.ngContentSelectors
    }
    , get isStandalone() {
      return t.standalone
    }
    , get isSignal() {
      return t.signals
    }
  }
}
var lD = null;
function hi() {
  return lD
}
function cD(n) {
  lD ??= n
}
var Ou = class {};
var ce = new w(''),
    Wg = (() => {
      class n {
        historyGo(e) {
          throw new Error('')
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: () => u(dP), providedIn: 'platform'})
      } return n
    })(),
    dD = new w(''),
    dP = (() => {
      class n extends Wg {
        _location;
        _history;
        _doc = u(ce);
        constructor() {
          super(), this._location = window.location,
                   this._history = window.history
        }
        getBaseHrefFromDOM() {
          return hi().getBaseHref(this._doc)
        }
        onPopState(e) {
          let i = hi().getGlobalEventTarget(this._doc, 'window');
          return i.addEventListener('popstate', e, !1),
                 () => i.removeEventListener('popstate', e)
        }
        onHashChange(e) {
          let i = hi().getGlobalEventTarget(this._doc, 'window');
          return i.addEventListener('hashchange', e, !1),
                 () => i.removeEventListener('hashchange', e)
        }
        get href() {
          return this._location.href
        }
        get protocol() {
          return this._location.protocol
        }
        get hostname() {
          return this._location.hostname
        }
        get port() {
          return this._location.port
        }
        get pathname() {
          return this._location.pathname
        }
        get search() {
          return this._location.search
        }
        get hash() {
          return this._location.hash
        }
        set pathname(e) {
          this._location.pathname = e
        }
        pushState(e, i, r) {
          this._history.pushState(e, i, r)
        }
        replaceState(e, i, r) {
          this._history.replaceState(e, i, r)
        }
        forward() {
          this._history.forward()
        }
        back() {
          this._history.back()
        }
        historyGo(e = 0) {
          this._history.go(e)
        }
        getState() {
          return this._history.state
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: () => new n, providedIn: 'platform'})
      } return n
    })();
function qg(n, t) {
  return n ? t ? n.endsWith('/') ? t.startsWith('/') ? n + t.slice(1) : n + t :
              t.startsWith('/')  ? n + t :
                                   `${n}/${t}` :
                  n :
              t
}
function nD(n) {
  let t = n.search(/#|\?|$/);
  return n[t - 1] === '/' ? n.slice(0, t - 1) + n.slice(t) : n
}
function Wi(n) {
  return n && n[0] !== '?' ? `?${n}` : n
}
var So = (() => {
  class n {
    historyGo(e) {
      throw new Error('')
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: () => u(Gg), providedIn: 'root'})
  } return n
})(),
    uD = new w(''),
    Gg = (() => {
      class n extends So {
        _platformLocation;
        _baseHref;
        _removeListenerFns = [];
        constructor(e, i) {
          super(), this._platformLocation = e,
                   this._baseHref = i ??
              this._platformLocation.getBaseHrefFromDOM() ??
              u(ce).location?.origin ?? ''
        }
        ngOnDestroy() {
          for (; this._removeListenerFns.length;)
            this._removeListenerFns.pop()()
        }
        onPopState(e) {
          this._removeListenerFns.push(
              this._platformLocation.onPopState(e),
              this._platformLocation.onHashChange(e))
        }
        getBaseHref() {
          return this._baseHref
        }
        prepareExternalUrl(e) {
          return qg(this._baseHref, e)
        }
        path(e = !1) {
          let i = this._platformLocation.pathname +
              Wi(this._platformLocation.search),
              r = this._platformLocation.hash;
          return r && e ? `${i}${r}` : i
        }
        pushState(e, i, r, o) {
          let s = this.prepareExternalUrl(r + Wi(o));
          this._platformLocation.pushState(e, i, s)
        }
        replaceState(e, i, r, o) {
          let s = this.prepareExternalUrl(r + Wi(o));
          this._platformLocation.replaceState(e, i, s)
        }
        forward() {
          this._platformLocation.forward()
        }
        back() {
          this._platformLocation.back()
        }
        getState() {
          return this._platformLocation.getState()
        }
        historyGo(e = 0) {
          this._platformLocation.historyGo?.(e)
        }
        static \u0275fac = function(i) {
          return new (i || n)(A(Wg), A(uD, 8))
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    mD = (() => {
      class n extends So {
        _platformLocation;
        _baseHref = '';
        _removeListenerFns = [];
        constructor(e, i) {
          super(), this._platformLocation = e, i != null && (this._baseHref = i)
        }
        ngOnDestroy() {
          for (; this._removeListenerFns.length;)
            this._removeListenerFns.pop()()
        }
        onPopState(e) {
          this._removeListenerFns.push(
              this._platformLocation.onPopState(e),
              this._platformLocation.onHashChange(e))
        }
        getBaseHref() {
          return this._baseHref
        }
        path(e = !1) {
          let i = this._platformLocation.hash ?? '#';
          return i.length > 0 ? i.substring(1) : i
        }
        prepareExternalUrl(e) {
          let i = qg(this._baseHref, e);
          return i.length > 0 ? '#' + i : i
        }
        pushState(e, i, r, o) {
          let s = this.prepareExternalUrl(r + Wi(o)) ||
              this._platformLocation.pathname;
          this._platformLocation.pushState(e, i, s)
        }
        replaceState(e, i, r, o) {
          let s = this.prepareExternalUrl(r + Wi(o)) ||
              this._platformLocation.pathname;
          this._platformLocation.replaceState(e, i, s)
        }
        forward() {
          this._platformLocation.forward()
        }
        back() {
          this._platformLocation.back()
        }
        getState() {
          return this._platformLocation.getState()
        }
        historyGo(e = 0) {
          this._platformLocation.historyGo?.(e)
        }
        static \u0275fac = function(i) {
          return new (i || n)(A(Wg), A(uD, 8))
        };
        static \u0275prov = C({token: n, factory: n.\u0275fac})
      } return n
    })(),
    Dr = (() => {
      class n {
        _subject = new I;
        _basePath;
        _locationStrategy;
        _urlChangeListeners = [];
        _urlChangeSubscription = null;
        constructor(e) {
          this._locationStrategy = e;
          let i = this._locationStrategy.getBaseHref();
          this._basePath = hP(nD(iD(i))),
          this._locationStrategy.onPopState(
              r => {this._subject.next(
                  {url: this.path(!0), pop: !0, state: r.state, type: r.type})})
        }
        ngOnDestroy() {
          this._urlChangeSubscription?.unsubscribe(),
              this._urlChangeListeners = []
        }
        path(e = !1) {
          return this.normalize(this._locationStrategy.path(e))
        }
        getState() {
          return this._locationStrategy.getState()
        }
        isCurrentPathEqualTo(e, i = '') {
          return this.path() == this.normalize(e + Wi(i))
        }
        normalize(e) {
          return n.stripTrailingSlash(mP(this._basePath, iD(e)))
        }
        prepareExternalUrl(e) {
          return e && e[0] !== '/' && (e = '/' + e),
                 this._locationStrategy.prepareExternalUrl(e)
        }
        go(e, i = '', r = null) {
          this._locationStrategy.pushState(r, '', e, i),
              this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(e + Wi(i)), r)
        }
        replaceState(e, i = '', r = null) {
          this._locationStrategy.replaceState(r, '', e, i),
              this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(e + Wi(i)), r)
        }
        forward() {
          this._locationStrategy.forward()
        }
        back() {
          this._locationStrategy.back()
        }
        historyGo(e = 0) {
          this._locationStrategy.historyGo?.(e)
        }
        onUrlChange(e) {
          return this._urlChangeListeners.push(e),
                 this._urlChangeSubscription ??= this.subscribe(
                     i => {this._notifyUrlChangeListeners(i.url, i.state)}),
                 () => {
                   let i = this._urlChangeListeners.indexOf(e);
                   this._urlChangeListeners.splice(i, 1),
                       this._urlChangeListeners.length === 0 &&
                       (this._urlChangeSubscription?.unsubscribe(),
                        this._urlChangeSubscription = null)
                 }
        }
        _notifyUrlChangeListeners(e = '', i) {
          this._urlChangeListeners.forEach(r => r(e, i))
        }
        subscribe(e, i, r) {
          return this._subject.subscribe(
              {next: e, error: i ?? void 0, complete: r ?? void 0})
        }
        static normalizeQueryParams = Wi;
        static joinWithSlash = qg;
        static stripTrailingSlash = nD;
        static \u0275fac = function(i) {
          return new (i || n)(A(So))
        };
        static \u0275prov =
            C({token: n, factory: () => uP(), providedIn: 'root'})
      } return n
    })();
function uP() {
  return new Dr(A(So))
}
function mP(n, t) {
  if (!n || !t.startsWith(n)) return t;
  let e = t.substring(n.length);
  return e === '' || ['/', ';', '?', '#'].includes(e[0]) ? e : t
}
function iD(n) {
  return n.replace(/\/index.html$/, '')
}
function hP(n) {
  if (new RegExp('^(https?:)?//').test(n)) {
    let [, e] = n.split(/\/\/[^\/]+/);
    return e
  }
  return n
}
function Nu(n, t) {
  t = encodeURIComponent(t);
  for (let e of n.split(';')) {
    let i = e.indexOf('='),
        [r, o] = i == -1 ? [e, ''] : [e.slice(0, i), e.slice(i + 1)];
    if (r.trim() === t) return decodeURIComponent(o)
  }
  return null
}
var jg = /\s+/, rD = [],
    vn = (() => {
      class n {
        _ngEl;
        _renderer;
        initialClasses = rD;
        rawClass;
        stateMap = new Map;
        constructor(e, i) {
          this._ngEl = e, this._renderer = i
        }
        set klass(e) {
          this.initialClasses = e != null ? e.trim().split(jg) : rD
        }
        set ngClass(e) {
          this.rawClass = typeof e == 'string' ? e.trim().split(jg) : e
        }
        ngDoCheck() {
          for (let i of this.initialClasses) this._updateState(i, !0);
          let e = this.rawClass;
          if (Array.isArray(e) || e instanceof Set)
            for (let i of e) this._updateState(i, !0);
          else if (e != null)
            for (let i of Object.keys(e)) this._updateState(i, !!e[i]);
          this._applyStateDiff()
        }
        _updateState(e, i) {
          let r = this.stateMap.get(e);
          r !== void 0 ?
              (r.enabled !== i && (r.changed = !0, r.enabled = i),
               r.touched = !0) :
              this.stateMap.set(e, {enabled: i, changed: !0, touched: !0})
        }
        _applyStateDiff() {
          for (let e of this.stateMap) {
            let i = e[0], r = e[1];
            r.changed ? (this._toggleClass(i, r.enabled), r.changed = !1) :
                        r.touched ||
                    (r.enabled && this._toggleClass(i, !1),
                     this.stateMap.delete(i)),
                r.touched = !1
          }
        }
        _toggleClass(e, i) {
          e = e.trim(),
          e.length > 0 &&
              e.split(jg).forEach(
                  r => {
                      i ? this._renderer.addClass(this._ngEl.nativeElement, r) :
                          this._renderer.removeClass(
                              this._ngEl.nativeElement, r)})
        }
        static \u0275fac = function(i) {
          return new (i || n)(z(L), z(rt))
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'ngClass', '']],
          inputs: {klass: [0, 'class', 'klass'], ngClass: 'ngClass'}
        })
      } return n
    })();
var Bg = class {
  $implicit;
  ngForOf;
  index;
  count;
  constructor(t, e, i, r) {
    this.$implicit = t, this.ngForOf = e, this.index = i, this.count = r
  }
  get first() {
    return this.index === 0
  }
  get last() {
    return this.index === this.count - 1
  }
  get even() {
    return this.index % 2 === 0
  }
  get odd() {
    return !this.even
  }
}
, yn = (() => {
    class n {
      _viewContainer;
      _template;
      _differs;
      set ngForOf(e) {
        this._ngForOf = e, this._ngForOfDirty = !0
      }
      set ngForTrackBy(e) {
        this._trackByFn = e
      }
      get ngForTrackBy() {
        return this._trackByFn
      }
      _ngForOf = null;
      _ngForOfDirty = !0;
      _differ = null;
      _trackByFn;
      constructor(e, i, r) {
        this._viewContainer = e, this._template = i, this._differs = r
      }
      set ngForTemplate(e) {
        e && (this._template = e)
      }
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = !1;
          let e = this._ngForOf;
          !this._differ && e &&
              (this._differ = this._differs.find(e).create(this.ngForTrackBy))
        }
        if (this._differ) {
          let e = this._differ.diff(this._ngForOf);
          e && this._applyChanges(e)
        }
      }
      _applyChanges(e) {
        let i = this._viewContainer;
        e.forEachOperation((r, o, s) => {
          if (r.previousIndex == null)
            i.createEmbeddedView(
                this._template, new Bg(r.item, this._ngForOf, -1, -1),
                s === null ? void 0 : s);
          else if (s == null)
            i.remove(o === null ? void 0 : o);
          else if (o !== null) {
            let a = i.get(o);
            i.move(a, s), oD(a, r)
          }
        });
        for (let r = 0, o = i.length; r < o; r++) {
          let a = i.get(r).context;
          a.index = r, a.count = o, a.ngForOf = this._ngForOf
        }
        e.forEachIdentityChange(r => {
          let o = i.get(r.currentIndex);
          oD(o, r)
        })
      }
      static ngTemplateContextGuard(e, i) {
        return !0
      }
      static \u0275fac = function(i) {
        return new (i || n)(z(Ge), z(qe), z(ui))
      };
      static \u0275dir = T({
        type: n,
        selectors: [['', 'ngFor', '', 'ngForOf', '']],
        inputs: {
          ngForOf: 'ngForOf',
          ngForTrackBy: 'ngForTrackBy',
          ngForTemplate: 'ngForTemplate'
        }
      })
    } return n
  })();
function oD(n, t) {
  n.context.$implicit = t.item
}
var fi = (() => {
  class n {
    _viewContainer;
    _context = new zg;
    _thenTemplateRef = null;
    _elseTemplateRef = null;
    _thenViewRef = null;
    _elseViewRef = null;
    constructor(e, i) {
      this._viewContainer = e, this._thenTemplateRef = i
    }
    set ngIf(e) {
      this._context.$implicit = this._context.ngIf = e, this._updateView()
    }
    set ngIfThen(e) {
      sD(e, !1), this._thenTemplateRef = e, this._thenViewRef = null,
                 this._updateView()
    }
    set ngIfElse(e) {
      sD(e, !1), this._elseTemplateRef = e, this._elseViewRef = null,
                 this._updateView()
    }
    _updateView() {
      this._context.$implicit ? this._thenViewRef ||
              (this._viewContainer.clear(), this._elseViewRef = null,
               this._thenTemplateRef &&
                   (this._thenViewRef = this._viewContainer.createEmbeddedView(
                        this._thenTemplateRef, this._context))) :
                                this._elseViewRef ||
              (this._viewContainer.clear(), this._thenViewRef = null,
               this._elseTemplateRef &&
                   (this._elseViewRef = this._viewContainer.createEmbeddedView(
                        this._elseTemplateRef, this._context)))
    }
    static ngIfUseIfTypeGuard;
    static ngTemplateGuard_ngIf;
    static ngTemplateContextGuard(e, i) {
      return !0
    }
    static \u0275fac = function(i) {
      return new (i || n)(z(Ge), z(qe))
    };
    static \u0275dir = T({
      type: n,
      selectors: [['', 'ngIf', '']],
      inputs: {ngIf: 'ngIf', ngIfThen: 'ngIfThen', ngIfElse: 'ngIfElse'}
    })
  } return n
})(),
    zg = class {
  $implicit = null;
  ngIf = null
};
function sD(n, t) {
  if (n && !n.createEmbeddedView) throw new S(2020, !1)
}
var hD = (() => {
  class n {
    _ngEl;
    _differs;
    _renderer;
    _ngStyle = null;
    _differ = null;
    constructor(e, i, r) {
      this._ngEl = e, this._differs = i, this._renderer = r
    }
    set ngStyle(e) {
      this._ngStyle = e,
      !this._differ && e && (this._differ = this._differs.find(e).create())
    }
    ngDoCheck() {
      if (this._differ) {
        let e = this._differ.diff(this._ngStyle);
        e && this._applyChanges(e)
      }
    }
    _setStyle(e, i) {
      let [r, o] = e.split('.'),
              s = r.indexOf('-') === -1 ? void 0 : li.DashCase;
      i != null ? this._renderer.setStyle(
                      this._ngEl.nativeElement, r, o ? `${i}${o}` : i, s) :
                  this._renderer.removeStyle(this._ngEl.nativeElement, r, s)
    }
    _applyChanges(e) {
      e.forEachRemovedItem(i => this._setStyle(i.key, null)),
          e.forEachAddedItem(i => this._setStyle(i.key, i.currentValue)),
          e.forEachChangedItem(i => this._setStyle(i.key, i.currentValue))
    }
    static \u0275fac = function(i) {
      return new (i || n)(z(L), z(Ru), z(rt))
    };
    static \u0275dir = T({
      type: n,
      selectors: [['', 'ngStyle', '']],
      inputs: {ngStyle: 'ngStyle'}
    })
  } return n
})(),
    Pu = (() => {
      class n {
        _viewContainerRef;
        _viewRef = null;
        ngTemplateOutletContext = null;
        ngTemplateOutlet = null;
        ngTemplateOutletInjector = null;
        constructor(e) {
          this._viewContainerRef = e
        }
        ngOnChanges(e) {
          if (this._shouldRecreateView(e)) {
            let i = this._viewContainerRef;
            if (this._viewRef && i.remove(i.indexOf(this._viewRef)),
                !this.ngTemplateOutlet) {
              this._viewRef = null;
              return
            }
            let r = this._createContextForwardProxy();
            this._viewRef = i.createEmbeddedView(
                this.ngTemplateOutlet, r,
                {injector: this.ngTemplateOutletInjector ?? void 0})
          }
        }
        _shouldRecreateView(e) {
          return !!e.ngTemplateOutlet || !!e.ngTemplateOutletInjector
        }
        _createContextForwardProxy() {
          return new Proxy({}, {
            set: (e, i, r) => this.ngTemplateOutletContext ?
                Reflect.set(this.ngTemplateOutletContext, i, r) :
                !1,
            get: (e, i, r) => {
              if (this.ngTemplateOutletContext)
                return Reflect.get(this.ngTemplateOutletContext, i, r)
            }
          })
        }
        static \u0275fac = function(i) {
          return new (i || n)(z(Ge))
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'ngTemplateOutlet', '']],
          inputs: {
            ngTemplateOutletContext: 'ngTemplateOutletContext',
            ngTemplateOutlet: 'ngTemplateOutlet',
            ngTemplateOutletInjector: 'ngTemplateOutletInjector'
          },
          features: [Pe]
        })
      } return n
    })();
function fP(n, t) {
  return new S(2100, !1)
}
var Hg = class {
  createSubscription(t, e) {
    return tn(() => t.subscribe({
      next: e,
      error: i => {
        throw i
      }
    }))
  }
  dispose(t) {
    tn(() => t.unsubscribe())
  }
}
, Ug = class {
  createSubscription(t, e) {
    return t.then(e, i => {throw i})
  }
  dispose(t) {}
}
, pP = new Ug, gP = new Hg,
  Fu = (() => {
    class n {
      _ref;
      _latestValue = null;
      markForCheckOnValueUpdate = !0;
      _subscription = null;
      _obj = null;
      _strategy = null;
      constructor(e) {
        this._ref = e
      }
      ngOnDestroy() {
        this._subscription && this._dispose(), this._ref = null
      }
      transform(e) {
        if (!this._obj) {
          if (e) try {
              this.markForCheckOnValueUpdate = !1, this._subscribe(e)
            } finally {
              this.markForCheckOnValueUpdate = !0
            }
          return this._latestValue
        }
        return e !== this._obj ? (this._dispose(), this.transform(e)) :
                                 this._latestValue
      }
      _subscribe(e) {
        this._obj = e, this._strategy = this._selectStrategy(e),
        this._subscription = this._strategy.createSubscription(
            e, i => this._updateLatestValue(e, i))
      }
      _selectStrategy(e) {
        if (wr(e)) return pP;
        if (Fg(e)) return gP;
        throw fP(n, e)
      }
      _dispose() {
        this._strategy.dispose(this._subscription), this._latestValue = null,
                                                    this._subscription = null,
                                                    this._obj = null
      }
      _updateLatestValue(e, i) {
        e === this._obj &&
            (this._latestValue = i,
             this.markForCheckOnValueUpdate && this._ref?.markForCheck())
      }
      static \u0275fac = function(i) {
        return new (i || n)(z(Ae, 16))
      };
      static \u0275pipe = Du({name: 'async', type: n, pure: !1})
    } return n
  })();
function _P(n, t) {
  return {
    key: n, value: t
  }
}
var fD = (() => {
  class n {
    differs;
    constructor(e) {
      this.differs = e
    }
    differ;
    keyValues = [];
    compareFn = aD;
    transform(e, i = aD) {
      if (!e || !(e instanceof Map) && typeof e != 'object') return null;
      this.differ ??= this.differs.find(e).create();
      let r = this.differ.diff(e), o = i !== this.compareFn;
      return r &&
                 (this.keyValues = [],
                  r.forEachItem(
                      s => {this.keyValues.push(_P(s.key, s.currentValue))})),
             (r || o) && (i && this.keyValues.sort(i), this.compareFn = i),
             this.keyValues
    }
    static \u0275fac = function(i) {
      return new (i || n)(z(Ru, 16))
    };
    static \u0275pipe = Du({name: 'keyvalue', type: n, pure: !1})
  } return n
})();
function aD(n, t) {
  let e = n.key, i = t.key;
  if (e === i) return 0;
  if (e == null) return 1;
  if (i == null) return -1;
  if (typeof e == 'string' && typeof i == 'string') return e < i ? -1 : 1;
  if (typeof e == 'number' && typeof i == 'number') return e - i;
  if (typeof e == 'boolean' && typeof i == 'boolean') return e < i ? -1 : 1;
  let r = String(e), o = String(i);
  return r == o ? 0 : r < o ? -1 : 1
}
var Er = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})(),
    Qg = 'browser', bP = 'server';
function qi(n) {
  return n === Qg
}
function Yg(n) {
  return n === bP
}
var pD = (() => {
  class n {
    static \u0275prov =
        C({token: n, providedIn: 'root', factory: () => new $g(u(ce), window)})
  } return n
})(),
    $g = class {
  document;
  window;
  offset = () => [0, 0];
  constructor(t, e) {
    this.document = t, this.window = e
  }
  setOffset(t) {
    Array.isArray(t) ? this.offset = () => t : this.offset = t
  }
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY]
  }
  scrollToPosition(t) {
    this.window.scrollTo(t[0], t[1])
  }
  scrollToAnchor(t) {
    let e = vP(this.document, t);
    e && (this.scrollToElement(e), e.focus())
  }
  setHistoryScrollRestoration(t) {
    this.window.history.scrollRestoration = t
  }
  scrollToElement(t) {
    let e = t.getBoundingClientRect(), i = e.left + this.window.pageXOffset,
        r = e.top + this.window.pageYOffset, o = this.offset();
    this.window.scrollTo(i - o[0], r - o[1])
  }
};
function vP(n, t) {
  let e = n.getElementById(t) || n.getElementsByName(t)[0];
  if (e) return e;
  if (typeof n.createTreeWalker == 'function' && n.body &&
      typeof n.body.attachShadow == 'function') {
    let i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT),
        r = i.currentNode;
    for (; r;) {
      let o = r.shadowRoot;
      if (o) {
        let s = o.getElementById(t) || o.querySelector(`[name="${t}"]`);
        if (s) return s
      }
      r = i.nextNode()
    }
  }
  return null
}
var Os = class {};
var hl = class {}
, Vu = class {}
, Io = class n {
  headers;
  normalizedNames = new Map;
  lazyInit;
  lazyUpdate = null;
  constructor(t) {
    t ? typeof t == 'string' ?
        this.lazyInit =
                () => {
                  this.headers = new Map, t.split(`
`).forEach(e => {
                    let i = e.indexOf(':');
                    if (i > 0) {
                      let r = e.slice(0, i), o = e.slice(i + 1).trim();
                      this.addHeaderEntry(r, o)
                    }
                  })
                } :
            typeof Headers < 'u' && t instanceof Headers ?
        (this.headers = new Map,
         t.forEach((e, i) => {this.addHeaderEntry(i, e)})) :
        this.lazyInit =
                () => {
                  this.headers = new Map,
                  Object.entries(t).forEach(
                      ([e, i]) => {this.setHeaderEntries(e, i)})
                } :
        this.headers = new Map
  }
  has(t) {
    return this.init(), this.headers.has(t.toLowerCase())
  }
  get(t) {
    this.init();
    let e = this.headers.get(t.toLowerCase());
    return e && e.length > 0 ? e[0] : null
  }
  keys() {
    return this.init(), Array.from(this.normalizedNames.values())
  }
  getAll(t) {
    return this.init(), this.headers.get(t.toLowerCase()) || null
  }
  append(t, e) {
    return this.clone({name: t, value: e, op: 'a'})
  }
  set(t, e) {
    return this.clone({name: t, value: e, op: 's'})
  }
  delete(t, e) {
    return this.clone({name: t, value: e, op: 'd'})
  }
  maybeSetNormalizedName(t, e) {
    this.normalizedNames.has(e) || this.normalizedNames.set(e, t)
  }
  init() {
    this.lazyInit &&
        (this.lazyInit instanceof n ? this.copyFrom(this.lazyInit) :
                                      this.lazyInit(),
         this.lazyInit = null,
         this.lazyUpdate &&
             (this.lazyUpdate.forEach(t => this.applyUpdate(t)),
              this.lazyUpdate = null))
  }
  copyFrom(t) {
    t.init(), Array.from(t.headers.keys()).forEach(e => {
      this.headers.set(e, t.headers.get(e)),
      this.normalizedNames.set(e, t.normalizedNames.get(e))
    })
  }
  clone(t) {
    let e = new n;
    return e.lazyInit = this.lazyInit && this.lazyInit instanceof n ?
               this.lazyInit :
               this,
           e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e
  }
  applyUpdate(t) {
    let e = t.name.toLowerCase();
    switch (t.op) {
      case 'a':
      case 's':
        let i = t.value;
        if (typeof i == 'string' && (i = [i]), i.length === 0) return;
        this.maybeSetNormalizedName(t.name, e);
        let r = (t.op === 'a' ? this.headers.get(e) : void 0) || [];
        r.push(...i), this.headers.set(e, r);
        break;
      case 'd':
        let o = t.value;
        if (!o)
          this.headers.delete(e), this.normalizedNames.delete(e);
        else {
          let s = this.headers.get(e);
          if (!s) return;
          s = s.filter(a => o.indexOf(a) === -1),
          s.length === 0 ?
              (this.headers.delete(e), this.normalizedNames.delete(e)) :
              this.headers.set(e, s)
        }
        break
    }
  }
  addHeaderEntry(t, e) {
    let i = t.toLowerCase();
    this.maybeSetNormalizedName(t, i),
        this.headers.has(i) ? this.headers.get(i).push(e) :
                              this.headers.set(i, [e])
  }
  setHeaderEntries(t, e) {
    let i = (Array.isArray(e) ? e : [e]).map(o => o.toString()),
        r = t.toLowerCase();
    this.headers.set(r, i), this.maybeSetNormalizedName(t, r)
  }
  forEach(t) {
    this.init(),
        Array.from(this.normalizedNames.keys())
            .forEach(e => t(this.normalizedNames.get(e), this.headers.get(e)))
  }
};
var Kg = class {
  encodeKey(t) {
    return gD(t)
  }
  encodeValue(t) {
    return gD(t)
  }
  decodeKey(t) {
    return decodeURIComponent(t)
  }
  decodeValue(t) {
    return decodeURIComponent(t)
  }
};
function yP(n, t) {
  let e = new Map;
  return n.length > 0 && n.replace(/^\?/, '').split('&').forEach(r => {
    let o = r.indexOf('='),
        [s, a] = o == -1 ?
        [t.decodeKey(r), ''] :
        [t.decodeKey(r.slice(0, o)), t.decodeValue(r.slice(o + 1))],
        l = e.get(s) || [];
    l.push(a), e.set(s, l)
  }),
         e
}
var wP = /%(\d[a-f0-9])/gi, xP = {
  40: '@',
  '3A': ':',
  24: '$',
  '2C': ',',
  '3B': ';',
  '3D': '=',
  '3F': '?',
  '2F': '/'
};
function gD(n) {
  return encodeURIComponent(n).replace(wP, (t, e) => xP[e] ?? t)
}
function Lu(n) {
  return `${n}`
}
var Sr = class n {
  map;
  encoder;
  updates = null;
  cloneFrom = null;
  constructor(t = {}) {
    if (this.encoder = t.encoder || new Kg, t.fromString) {
      if (t.fromObject) throw new S(2805, !1);
      this.map = yP(t.fromString, this.encoder)
    } else
      t.fromObject ?
          (this.map = new Map, Object.keys(t.fromObject).forEach(e => {
            let i = t.fromObject[e], r = Array.isArray(i) ? i.map(Lu) : [Lu(i)];
            this.map.set(e, r)
          })) :
          this.map = null
  }
  has(t) {
    return this.init(), this.map.has(t)
  }
  get(t) {
    this.init();
    let e = this.map.get(t);
    return e ? e[0] : null
  }
  getAll(t) {
    return this.init(), this.map.get(t) || null
  }
  keys() {
    return this.init(), Array.from(this.map.keys())
  }
  append(t, e) {
    return this.clone({param: t, value: e, op: 'a'})
  }
  appendAll(t) {
    let e = [];
    return Object.keys(t).forEach(i => {
      let r = t[i];
      Array.isArray(r) ?
          r.forEach(o => {e.push({param: i, value: o, op: 'a'})}) :
          e.push({param: i, value: r, op: 'a'})
    }),
           this.clone(e)
  }
  set(t, e) {
    return this.clone({param: t, value: e, op: 's'})
  }
  delete(t, e) {
    return this.clone({param: t, value: e, op: 'd'})
  }
  toString() {
    return this.init(),
           this.keys()
               .map(t => {
                 let e = this.encoder.encodeKey(t);
                 return this.map.get(t)
                     .map(i => e + '=' + this.encoder.encodeValue(i))
                     .join('&')
               })
               .filter(t => t !== '')
               .join('&')
  }
  clone(t) {
    let e = new n({encoder: this.encoder});
    return e.cloneFrom = this.cloneFrom || this,
           e.updates = (this.updates || []).concat(t), e
  }
  init() {
    this.map === null && (this.map = new Map),
        this.cloneFrom !== null &&
        (this.cloneFrom.init(),
         this.cloneFrom.keys().forEach(
             t => this.map.set(t, this.cloneFrom.map.get(t))),
         this.updates.forEach(t => {
           switch (t.op) {
             case 'a':
             case 's':
               let e = (t.op === 'a' ? this.map.get(t.param) : void 0) || [];
               e.push(Lu(t.value)), this.map.set(t.param, e);
               break;
             case 'd':
               if (t.value !== void 0) {
                 let i = this.map.get(t.param) || [],
                     r = i.indexOf(Lu(t.value));
                 r !== -1 && i.splice(r, 1),
                     i.length > 0 ? this.map.set(t.param, i) :
                                    this.map.delete(t.param)
               } else {
                 this.map.delete(t.param);
                 break
               }
           }
         }),
         this.cloneFrom = this.updates = null)
  }
};
var Xg = class {
  map = new Map;
  set(t, e) {
    return this.map.set(t, e), this
  }
  get(t) {
    return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t)
  }
  delete(t) {
    return this.map.delete(t), this
  }
  has(t) {
    return this.map.has(t)
  }
  keys() {
    return this.map.keys()
  }
};
function CP(n) {
  switch (n) {
    case 'DELETE':
    case 'GET':
    case 'HEAD':
    case 'OPTIONS':
    case 'JSONP':
      return !1;
    default:
      return !0
  }
}
function _D(n) {
  return typeof ArrayBuffer < 'u' && n instanceof ArrayBuffer
}
function bD(n) {
  return typeof Blob < 'u' && n instanceof Blob
}
function vD(n) {
  return typeof FormData < 'u' && n instanceof FormData
}
function DP(n) {
  return typeof URLSearchParams < 'u' && n instanceof URLSearchParams
}
var yD = 'Content-Type', wD = 'Accept', ED = 'X-Request-URL', kD = 'text/plain',
    SD = 'application/json', EP = `${SD}, ${kD}, */*`, ml = class n {
  url;
  body = null;
  headers;
  context;
  reportProgress = !1;
  withCredentials = !1;
  responseType = 'json';
  method;
  params;
  urlWithParams;
  transferCache;
  constructor(t, e, i, r) {
    this.url = e, this.method = t.toUpperCase();
    let o;
    if (CP(this.method) || r ? (this.body = i !== void 0 ? i : null, o = r) :
                               o = i,
        o &&
            (this.reportProgress = !!o.reportProgress,
             this.withCredentials = !!o.withCredentials,
             o.responseType && (this.responseType = o.responseType),
             o.headers && (this.headers = o.headers),
             o.context && (this.context = o.context),
             o.params && (this.params = o.params),
             this.transferCache = o.transferCache),
        this.headers ??= new Io, this.context ??= new Xg, !this.params)
      this.params = new Sr, this.urlWithParams = e;
    else {
      let s = this.params.toString();
      if (s.length === 0)
        this.urlWithParams = e;
      else {
        let a = e.indexOf('?'),
            l = a === -1     ? '?' :
            a < e.length - 1 ? '&' :
                               '';
        this.urlWithParams = e + l + s
      }
    }
  }
  serializeBody() {
    return this.body === null ? null :
        typeof this.body == 'string' || _D(this.body) || bD(this.body) ||
            vD(this.body) || DP(this.body) ?
                                this.body :
        this.body instanceof Sr ? this.body.toString() :
        typeof this.body == 'object' || typeof this.body == 'boolean' ||
            Array.isArray(this.body) ?
                                  JSON.stringify(this.body) :
                                  this.body.toString()
  }
  detectContentTypeHeader() {
    return this.body === null || vD(this.body) ? null :
        bD(this.body)                          ? this.body.type || null :
        _D(this.body)                          ? null :
        typeof this.body == 'string' ?
                        kD :
        this.body instanceof Sr ?
                        'application/x-www-form-urlencoded;charset=UTF-8' :
        typeof this.body == 'object' || typeof this.body == 'number' ||
            typeof this.body == 'boolean' ?
                        SD :
                        null
  }
  clone(t = {}) {
    let e = t.method || this.method, i = t.url || this.url,
        r = t.responseType || this.responseType,
        o = t.transferCache ?? this.transferCache,
        s = t.body !== void 0 ? t.body : this.body,
        a = t.withCredentials ?? this.withCredentials,
        l = t.reportProgress ?? this.reportProgress,
        c = t.headers || this.headers, d = t.params || this.params,
        m = t.context ?? this.context;
    return t.setHeaders !== void 0 &&
               (c = Object.keys(t.setHeaders)
                        .reduce((p, h) => p.set(h, t.setHeaders[h]), c)),
           t.setParams &&
               (d = Object.keys(t.setParams)
                        .reduce((p, h) => p.set(h, t.setParams[h]), d)),
           new n(e, i, s, {
             params: d,
             headers: c,
             context: m,
             reportProgress: l,
             responseType: r,
             withCredentials: a,
             transferCache: o
           })
  }
}
, Ns = function(n) {
  return n[n.Sent = 0] = 'Sent', n[n.UploadProgress = 1] = 'UploadProgress',
                    n[n.ResponseHeader = 2] = 'ResponseHeader',
                    n[n.DownloadProgress = 3] = 'DownloadProgress',
                    n[n.Response = 4] = 'Response', n[n.User = 5] = 'User', n
}(Ns || {}), fl = class {
  headers;
  status;
  statusText;
  url;
  ok;
  type;
  constructor(t, e = 200, i = 'OK') {
    this.headers = t.headers || new Io,
    this.status = t.status !== void 0 ? t.status : e,
    this.statusText = t.statusText || i, this.url = t.url || null,
    this.ok = this.status >= 200 && this.status < 300
  }
}
, Jg = class n extends fl {
  constructor(t = {}) {
    super(t)
  }
  type = Ns.ResponseHeader;
  clone(t = {}) {
    return new n({
      headers: t.headers || this.headers,
      status: t.status !== void 0 ? t.status : this.status,
      statusText: t.statusText || this.statusText,
      url: t.url || this.url || void 0
    })
  }
}
, ju = class n extends fl {
  body;
  constructor(t = {}) {
    super(t), this.body = t.body !== void 0 ? t.body : null
  }
  type = Ns.Response;
  clone(t = {}) {
    return new n({
      body: t.body !== void 0 ? t.body : this.body,
      headers: t.headers || this.headers,
      status: t.status !== void 0 ? t.status : this.status,
      statusText: t.statusText || this.statusText,
      url: t.url || this.url || void 0
    })
  }
}
, Bu = class extends fl {
  name = 'HttpErrorResponse';
  message;
  error;
  ok = !1;
  constructor(t) {
    super(t, 0, 'Unknown Error'),
        this.status >= 200 && this.status < 300 ?
        this.message =
            `Http failure during parsing for ${t.url || '(unknown url)'}` :
        this.message = `Http failure response for ${
            t.url || '(unknown url)'}: ${t.status} ${t.statusText}`,
        this.error = t.error || null
  }
}
, kP = 200, SP = 204;
function Zg(n, t) {
  return {
    body: t, headers: n.headers, context: n.context, observe: n.observe,
        params: n.params, reportProgress: n.reportProgress,
        responseType: n.responseType, withCredentials: n.withCredentials,
        transferCache: n.transferCache
  }
}
var zt = (() => {
  class n {
    handler;
    constructor(e) {
      this.handler = e
    }
    request(e, i, r = {}) {
      let o;
      if (e instanceof ml)
        o = e;
      else {
        let l;
        r.headers instanceof Io ? l = r.headers : l = new Io(r.headers);
        let c;
        r.params &&
            (r.params instanceof Sr ? c = r.params :
                                      c = new Sr({fromObject: r.params})),
            o = new ml(e, i, r.body !== void 0 ? r.body : null, {
              headers: l,
              context: r.context,
              params: c,
              reportProgress: r.reportProgress,
              responseType: r.responseType || 'json',
              withCredentials: r.withCredentials,
              transferCache: r.transferCache
            })
      }
      let s = G(o).pipe(Oi(l => this.handler.handle(l)));
      if (e instanceof ml || r.observe === 'events') return s;
      let a = s.pipe(me(l => l instanceof ju));
      switch (r.observe || 'body') {
        case 'body':
          switch (o.responseType) {
            case 'arraybuffer':
              return a.pipe(Q(l => {
                if (l.body !== null && !(l.body instanceof ArrayBuffer))
                  throw new S(2806, !1);
                return l.body
              }));
            case 'blob':
              return a.pipe(Q(l => {
                if (l.body !== null && !(l.body instanceof Blob))
                  throw new S(2807, !1);
                return l.body
              }));
            case 'text':
              return a.pipe(Q(l => {
                if (l.body !== null && typeof l.body != 'string')
                  throw new S(2808, !1);
                return l.body
              }));
            case 'json':
            default:
              return a.pipe(Q(l => l.body))
          }
        case 'response':
          return a;
        default:
          throw new S(2809, !1)
      }
    }
    delete (e, i = {}) {
      return this.request('DELETE', e, i)
    }
    get(e, i = {}) {
      return this.request('GET', e, i)
    }
    head(e, i = {}) {
      return this.request('HEAD', e, i)
    }
    jsonp(e, i) {
      return this.request('JSONP', e, {
        params: new Sr().append(i, 'JSONP_CALLBACK'),
        observe: 'body',
        responseType: 'json'
      })
    }
    options(e, i = {}) {
      return this.request('OPTIONS', e, i)
    }
    patch(e, i, r = {}) {
      return this.request('PATCH', e, Zg(r, i))
    }
    post(e, i, r = {}) {
      return this.request('POST', e, Zg(r, i))
    }
    put(e, i, r = {}) {
      return this.request('PUT', e, Zg(r, i))
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(hl))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})();
var IP = new w('');
function ID(n, t) {
  return t(n)
}
function MP(n, t) {
  return (e, i) => t.intercept(e, {handle: r => n(r, i)})
}
function TP(n, t, e) {
  return (i, r) => Kt(e, () => t(i, o => n(o, r)))
}
var RP = new w(''), e_ = new w(''), AP = new w(''),
    MD = new w('', {providedIn: 'root', factory: () => !0});
function OP() {
  let n = null;
  return (t, e) => {
    n === null && (n = (u(RP, {optional: !0}) ?? []).reduceRight(MP, ID));
    let i = u(zi);
    if (u(MD)) {
      let o = i.add();
      return n(t, e).pipe(Jn(() => i.remove(o)))
    } else
      return n(t, e)
  }
}
var xD = (() => {
  class n extends hl {
    backend;
    injector;
    chain = null;
    pendingTasks = u(zi);
    contributeToStability = u(MD);
    constructor(e, i) {
      super(), this.backend = e, this.injector = i
    }
    handle(e) {
      if (this.chain === null) {
        let i = Array.from(
            new Set([...this.injector.get(e_), ...this.injector.get(AP, [])]));
        this.chain = i.reduceRight((r, o) => TP(r, o, this.injector), ID)
      }
      if (this.contributeToStability) {
        let i = this.pendingTasks.add();
        return this.chain(e, r => this.backend.handle(r))
            .pipe(Jn(() => this.pendingTasks.remove(i)))
      } else
        return this.chain(e, i => this.backend.handle(i))
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(Vu), A(_t))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})();
var NP = /^\)\]\}',?\n/, PP = RegExp(`^${ED}:`, 'm');
function FP(n) {
  return 'responseURL' in n && n.responseURL ? n.responseURL :
      PP.test(n.getAllResponseHeaders())     ? n.getResponseHeader(ED) :
                                               null
}
var CD = (() => {
  class n {
    xhrFactory;
    constructor(e) {
      this.xhrFactory = e
    }
    handle(e) {
      if (e.method === 'JSONP') throw new S(-2800, !1);
      let i = this.xhrFactory;
      return (i.\u0275loadImpl ? Ue(i.\u0275loadImpl()) : G(null))
          .pipe($e(
              () => new ie(o => {
                let s = i.build();
                if (s.open(e.method, e.urlWithParams),
                    e.withCredentials && (s.withCredentials = !0),
                    e.headers.forEach(
                        (v, k) => s.setRequestHeader(v, k.join(','))),
                    e.headers.has(wD) || s.setRequestHeader(wD, EP),
                    !e.headers.has(yD)) {
                  let v = e.detectContentTypeHeader();
                  v !== null && s.setRequestHeader(yD, v)
                }
                if (e.responseType) {
                  let v = e.responseType.toLowerCase();
                  s.responseType = v !== 'json' ? v : 'text'
                }
                let a = e.serializeBody(), l = null, c = () => {
                  if (l !== null) return l;
                  let v = s.statusText || 'OK',
                      k = new Io(s.getAllResponseHeaders()), F = FP(s) || e.url;
                  return l = new Jg({
                           headers: k,
                           status: s.status,
                           statusText: v,
                           url: F
                         }),
                         l
                }, d = () => {
                  let {headers: v, status: k, statusText: F, url: se} = c(),
                                                                  Ce = null;
                  k !== SP &&
                      (Ce = typeof s.response > 'u' ? s.responseText :
                                                      s.response),
                      k === 0 && (k = Ce ? kP : 0);
                  let Ze = k >= 200 && k < 300;
                  if (e.responseType === 'json' && typeof Ce == 'string') {
                    let kn = Ce;
                    Ce = Ce.replace(NP, '');
                    try {
                      Ce = Ce !== '' ? JSON.parse(Ce) : null
                    } catch (Ut) {
                      Ce = kn, Ze && (Ze = !1, Ce = {error: Ut, text: Ce})
                    }
                  }
                  Ze ? (o.next(new ju({
                    body: Ce,
                    headers: v,
                    status: k,
                    statusText: F,
                    url: se || void 0
                  })),
                        o.complete()) :
                       o.error(new Bu({
                         error: Ce,
                         headers: v,
                         status: k,
                         statusText: F,
                         url: se || void 0
                       }))
                }, m = v => {
                  let {url: k} = c(),
                            F = new Bu({
                              error: v,
                              status: s.status || 0,
                              statusText: s.statusText || 'Unknown Error',
                              url: k || void 0
                            });
                  o.error(F)
                }, p = !1, h = v => {
                  p || (o.next(c()), p = !0);
                  let k = {type: Ns.DownloadProgress, loaded: v.loaded};
                  v.lengthComputable && (k.total = v.total),
                      e.responseType === 'text' && s.responseText &&
                      (k.partialText = s.responseText),
                      o.next(k)
                }, _ = v => {
                  let k = {type: Ns.UploadProgress, loaded: v.loaded};
                  v.lengthComputable && (k.total = v.total), o.next(k)
                };
                return s.addEventListener('load', d),
                       s.addEventListener('error', m),
                       s.addEventListener('timeout', m),
                       s.addEventListener('abort', m),
                       e.reportProgress &&
                           (s.addEventListener('progress', h),
                            a !== null && s.upload &&
                                s.upload.addEventListener('progress', _)),
                       s.send(a), o.next({type: Ns.Sent}), () => {
                         s.removeEventListener('error', m),
                             s.removeEventListener('abort', m),
                             s.removeEventListener('load', d),
                             s.removeEventListener('timeout', m),
                             e.reportProgress &&
                             (s.removeEventListener('progress', h),
                              a !== null && s.upload &&
                                  s.upload.removeEventListener('progress', _)),
                             s.readyState !== s.DONE && s.abort()
                       }
              })))
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(Os))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})(),
    TD = new w(''), LP = 'XSRF-TOKEN',
    VP = new w('', {providedIn: 'root', factory: () => LP}),
    jP = 'X-XSRF-TOKEN',
    BP = new w('', {providedIn: 'root', factory: () => jP}), zu = class {}
, zP = (() => {
    class n {
      doc;
      platform;
      cookieName;
      lastCookieString = '';
      lastToken = null;
      parseCount = 0;
      constructor(e, i, r) {
        this.doc = e, this.platform = i, this.cookieName = r
      }
      getToken() {
        if (this.platform === 'server') return null;
        let e = this.doc.cookie || '';
        return e !== this.lastCookieString &&
                   (this.parseCount++, this.lastToken = Nu(e, this.cookieName),
                    this.lastCookieString = e),
               this.lastToken
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(ce), A(Fn), A(VP))
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })();
function HP(n, t) {
  let e = n.url.toLowerCase();
  if (!u(TD) || n.method === 'GET' || n.method === 'HEAD' ||
      e.startsWith('http://') || e.startsWith('https://'))
    return t(n);
  let i = u(zu).getToken(), r = u(BP);
  return i != null && !n.headers.has(r) &&
             (n = n.clone({headers: n.headers.set(r, i)})),
         t(n)
}
var RD = function(n) {
  return n[n.Interceptors = 0] = 'Interceptors',
                            n[n.LegacyInterceptors = 1] = 'LegacyInterceptors',
                            n[n.CustomXsrfConfiguration = 2] =
                                'CustomXsrfConfiguration',
                            n[n.NoXsrfProtection = 3] = 'NoXsrfProtection',
                            n[n.JsonpSupport = 4] = 'JsonpSupport',
                            n[n.RequestsMadeViaParent = 5] =
                                'RequestsMadeViaParent',
                            n[n.Fetch = 6] = 'Fetch', n
}(RD || {});
function UP(n, t) {
  return {
    \u0275kind: n, \u0275providers: t
  }
}
function $P(...n) {
  let t = [
    zt, CD, xD, {provide: hl, useExisting: xD},
    {provide: Vu, useFactory: () => u(IP, {optional: !0}) ?? u(CD)},
    {provide: e_, useValue: HP, multi: !0}, {provide: TD, useValue: !0},
    {provide: zu, useClass: zP}
  ];
  for (let e of n) t.push(...e.\u0275providers);
  return iu(t)
}
var DD = new w('');
function WP() {
  return UP(RD.LegacyInterceptors, [
    {provide: DD, useFactory: OP}, {provide: e_, useExisting: DD, multi: !0}
  ])
}
var AD = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({providers: [$P(WP())]})
  } return n
})();
var n_ = class extends Ou {
  supportsDOMEvents = !0
}
, i_ = class n extends n_ {
  static makeCurrent() {
    cD(new n)
  }
  onAndCancel(t, e, i, r) {
    return t.addEventListener(e, i, r), () => {
      t.removeEventListener(e, i, r)
    }
  }
  dispatchEvent(t, e) {
    t.dispatchEvent(e)
  }
  remove(t) {
    t.remove()
  }
  createElement(t, e) {
    return e = e || this.getDefaultDocument(), e.createElement(t)
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument('fakeTitle')
  }
  getDefaultDocument() {
    return document
  }
  isElementNode(t) {
    return t.nodeType === Node.ELEMENT_NODE
  }
  isShadowRoot(t) {
    return t instanceof DocumentFragment
  }
  getGlobalEventTarget(t, e) {
    return e === 'window' ? window :
        e === 'document'  ? t :
        e === 'body'      ? t.body :
                            null
  }
  getBaseHref(t) {
    let e = qP();
    return e == null ? null : GP(e)
  }
  resetBaseElement() {
    pl = null
  }
  getUserAgent() {
    return window.navigator.userAgent
  }
  getCookie(t) {
    return Nu(document.cookie, t)
  }
}
, pl = null;
function qP() {
  return pl = pl || document.querySelector('base'),
         pl ? pl.getAttribute('href') : null
}
function GP(n) {
  return new URL(n, document.baseURI).pathname
}
var r_ = class {
  addToWindow(t) {
    Pn.getAngularTestability =
        (i, r = !0) => {
          let o = t.findTestabilityInTree(i, r);
          if (o == null) throw new S(5103, !1);
          return o
        },
    Pn.getAllAngularTestabilities = () => t.getAllTestabilities(),
    Pn.getAllAngularRootElements = () => t.getAllRootElements();
    let e = i => {
      let r = Pn.getAllAngularTestabilities(), o = r.length, s = function() {
        o--, o == 0 && i()
      };
      r.forEach(a => {a.whenStable(s)})
    };
    Pn.frameworkStabilizers || (Pn.frameworkStabilizers = []),
        Pn.frameworkStabilizers.push(e)
  }
  findTestabilityInTree(t, e, i) {
    if (e == null) return null;
    let r = t.getTestability(e);
    return r ??
        (i ? hi().isShadowRoot(e) ?
             this.findTestabilityInTree(t, e.host, !0) :
             this.findTestabilityInTree(t, e.parentElement, !0) :
             null)
  }
}
, QP = (() => {
    class n {
      build() {
        return new XMLHttpRequest
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })(),
  o_ = new w(''),
  LD = (() => {
    class n {
      _zone;
      _plugins;
      _eventNameToPlugin = new Map;
      constructor(e, i) {
        this._zone = i, e.forEach(r => {r.manager = this}),
        this._plugins = e.slice().reverse()
      }
      addEventListener(e, i, r, o) {
        return this._findPluginFor(i).addEventListener(e, i, r, o)
      }
      getZone() {
        return this._zone
      }
      _findPluginFor(e) {
        let i = this._eventNameToPlugin.get(e);
        if (i) return i;
        if (i = this._plugins.find(o => o.supports(e)), !i)
          throw new S(5101, !1);
        return this._eventNameToPlugin.set(e, i), i
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(o_), A(U))
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })(),
  Uu = class {
  _doc;
  constructor(t) {
    this._doc = t
  }
  manager
}
, Hu = 'ng-app-id';
function OD(n) {
  for (let t of n) t.remove()
}
function ND(n, t) {
  let e = t.createElement('style');
  return e.textContent = n, e
}
function YP(n, t, e, i) {
  let r = n.head?.querySelectorAll(`style[${Hu}="${t}"],link[${Hu}="${t}"]`);
  if (r)
    for (let o of r)
      o.removeAttribute(Hu),
          o instanceof HTMLLinkElement ?
          i.set(
              o.href.slice(o.href.lastIndexOf('/') + 1),
              {usage: 0, elements: [o]}) :
          o.textContent && e.set(o.textContent, {usage: 0, elements: [o]})
}
function s_(n, t) {
  let e = t.createElement('link');
  return e.setAttribute('rel', 'stylesheet'), e.setAttribute('href', n), e
}
var VD = (() => {
  class n {
    doc;
    appId;
    nonce;
    inline = new Map;
    external = new Map;
    hosts = new Set;
    isServer;
    constructor(e, i, r, o = {}) {
      this.doc = e, this.appId = i, this.nonce = r, this.isServer = Yg(o),
      YP(e, i, this.inline, this.external), this.hosts.add(e.head)
    }
    addStyles(e, i) {
      for (let r of e) this.addUsage(r, this.inline, ND);
      i?.forEach(r => this.addUsage(r, this.external, s_))
    }
    removeStyles(e, i) {
      for (let r of e) this.removeUsage(r, this.inline);
      i?.forEach(r => this.removeUsage(r, this.external))
    }
    addUsage(e, i, r) {
      let o = i.get(e);
      o ? o.usage++ : i.set(e, {
        usage: 1,
        elements: [...this.hosts].map(s => this.addElement(s, r(e, this.doc)))
      })
    }
    removeUsage(e, i) {
      let r = i.get(e);
      r && (r.usage--, r.usage <= 0 && (OD(r.elements), i.delete(e)))
    }
    ngOnDestroy() {
      for (let [, {elements: e}] of [...this.inline, ...this.external]) OD(e);
      this.hosts.clear()
    }
    addHost(e) {
      this.hosts.add(e);
      for (let [i, {elements: r}] of this.inline)
        r.push(this.addElement(e, ND(i, this.doc)));
      for (let [i, {elements: r}] of this.external)
        r.push(this.addElement(e, s_(i, this.doc)))
    }
    removeHost(e) {
      this.hosts.delete(e)
    }
    addElement(e, i) {
      return this.nonce && i.setAttribute('nonce', this.nonce),
             this.isServer && i.setAttribute(Hu, this.appId), e.appendChild(i)
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(ce), A(Ms), A(il, 8), A(Fn))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})(),
    t_ = {
      svg: 'http://www.w3.org/2000/svg',
      xhtml: 'http://www.w3.org/1999/xhtml',
      xlink: 'http://www.w3.org/1999/xlink',
      xml: 'http://www.w3.org/XML/1998/namespace',
      xmlns: 'http://www.w3.org/2000/xmlns/',
      math: 'http://www.w3.org/1998/Math/MathML'
    },
    l_ = /%COMP%/g;
var jD = '%COMP%', ZP = `_nghost-${jD}`, KP = `_ngcontent-${jD}`, XP = !0,
    JP = new w('', {providedIn: 'root', factory: () => XP});
function eF(n) {
  return KP.replace(l_, n)
}
function tF(n) {
  return ZP.replace(l_, n)
}
function BD(n, t) {
  return t.map(e => e.replace(l_, n))
}
var $u = (() => {
  class n {
    eventManager;
    sharedStylesHost;
    appId;
    removeStylesOnCompDestroy;
    doc;
    platformId;
    ngZone;
    nonce;
    tracingService;
    rendererByCompId = new Map;
    defaultRenderer;
    platformIsServer;
    constructor(e, i, r, o, s, a, l, c = null, d = null) {
      this.eventManager = e, this.sharedStylesHost = i, this.appId = r,
      this.removeStylesOnCompDestroy = o, this.doc = s, this.platformId = a,
      this.ngZone = l, this.nonce = c, this.tracingService = d,
      this.platformIsServer = Yg(a),
      this.defaultRenderer =
          new gl(e, s, l, this.platformIsServer, this.tracingService)
    }
    createRenderer(e, i) {
      if (!e || !i) return this.defaultRenderer;
      this.platformIsServer && i.encapsulation === ai.ShadowDom &&
          (i = ae(y({}, i), {encapsulation: ai.Emulated}));
      let r = this.getOrCreateRenderer(e, i);
      return r instanceof Wu ? r.applyToHost(e) :
                               r instanceof _l && r.applyStyles(),
             r
    }
    getOrCreateRenderer(e, i) {
      let r = this.rendererByCompId, o = r.get(i.id);
      if (!o) {
        let s = this.doc, a = this.ngZone, l = this.eventManager,
            c = this.sharedStylesHost, d = this.removeStylesOnCompDestroy,
            m = this.platformIsServer, p = this.tracingService;
        switch (i.encapsulation) {
          case ai.Emulated:
            o = new Wu(l, c, i, this.appId, d, s, a, m, p);
            break;
          case ai.ShadowDom:
            return new a_(l, c, e, i, s, a, this.nonce, m, p);
          default:
            o = new _l(l, c, i, d, s, a, m, p);
            break
        }
        r.set(i.id, o)
      }
      return o
    }
    ngOnDestroy() {
      this.rendererByCompId.clear()
    }
    componentReplaced(e) {
      this.rendererByCompId.delete(e)
    }
    static \u0275fac = function(i) {
      return new (i || n)(
          A(LD), A(VD), A(Ms), A(JP), A(ce), A(Fn), A(U), A(il), A(Ts, 8))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})(),
    gl = class {
  eventManager;
  doc;
  ngZone;
  platformIsServer;
  tracingService;
  data = Object.create(null);
  throwOnSyntheticProps = !0;
  constructor(t, e, i, r, o) {
    this.eventManager = t, this.doc = e, this.ngZone = i,
    this.platformIsServer = r, this.tracingService = o
  }
  destroy() {}
  destroyNode = null;
  createElement(t, e) {
    return e ? this.doc.createElementNS(t_[e] || e, t) :
               this.doc.createElement(t)
  }
  createComment(t) {
    return this.doc.createComment(t)
  }
  createText(t) {
    return this.doc.createTextNode(t)
  }
  appendChild(t, e) {
    (PD(t) ? t.content : t).appendChild(e)
  }
  insertBefore(t, e, i) {
    t && (PD(t) ? t.content : t).insertBefore(e, i)
  }
  removeChild(t, e) {
    e.remove()
  }
  selectRootElement(t, e) {
    let i = typeof t == 'string' ? this.doc.querySelector(t) : t;
    if (!i) throw new S(-5104, !1);
    return e || (i.textContent = ''), i
  }
  parentNode(t) {
    return t.parentNode
  }
  nextSibling(t) {
    return t.nextSibling
  }
  setAttribute(t, e, i, r) {
    if (r) {
      e = r + ':' + e;
      let o = t_[r];
      o ? t.setAttributeNS(o, e, i) : t.setAttribute(e, i)
    } else
      t.setAttribute(e, i)
  }
  removeAttribute(t, e, i) {
    if (i) {
      let r = t_[i];
      r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${i}:${e}`)
    } else
      t.removeAttribute(e)
  }
  addClass(t, e) {
    t.classList.add(e)
  }
  removeClass(t, e) {
    t.classList.remove(e)
  }
  setStyle(t, e, i, r) {
    r&(li.DashCase | li.Important) ?
        t.style.setProperty(e, i, r & li.Important ? 'important' : '') :
        t.style[e] = i
  }
  removeStyle(t, e, i) {
    i&li.DashCase ? t.style.removeProperty(e) : t.style[e] = ''
  }
  setProperty(t, e, i) {
    t != null && (t[e] = i)
  }
  setValue(t, e) {
    t.nodeValue = e
  }
  listen(t, e, i, r) {
    if (typeof t == 'string' &&
        (t = hi().getGlobalEventTarget(this.doc, t), !t))
      throw new S(5102, !1);
    let o = this.decoratePreventDefault(i);
    return this.tracingService?.wrapEventListener &&
               (o = this.tracingService.wrapEventListener(t, e, o)),
           this.eventManager.addEventListener(t, e, o, r)
  }
  decoratePreventDefault(t) {
    return e => {
      if (e === '__ngUnwrap__') return t;
      (this.platformIsServer ? this.ngZone.runGuarded(() => t(e)) : t(e)) ===
              !1 &&
          e.preventDefault()
    }
  }
};
function PD(n) {
  return n.tagName === 'TEMPLATE' && n.content !== void 0
}
var a_ = class extends gl {
  sharedStylesHost;
  hostEl;
  shadowRoot;
  constructor(t, e, i, r, o, s, a, l, c) {
    super(t, o, s, l, c), this.sharedStylesHost = e, this.hostEl = i,
                          this.shadowRoot = i.attachShadow({mode: 'open'}),
                          this.sharedStylesHost.addHost(this.shadowRoot);
    let d = r.styles;
    d = BD(r.id, d);
    for (let p of d) {
      let h = document.createElement('style');
      a && h.setAttribute('nonce', a), h.textContent = p,
                                       this.shadowRoot.appendChild(h)
    }
    let m = r.getExternalStyles?.();
    if (m)
      for (let p of m) {
        let h = s_(p, o);
        a && h.setAttribute('nonce', a), this.shadowRoot.appendChild(h)
      }
  }
  nodeOrShadowRoot(t) {
    return t === this.hostEl ? this.shadowRoot : t
  }
  appendChild(t, e) {
    return super.appendChild(this.nodeOrShadowRoot(t), e)
  }
  insertBefore(t, e, i) {
    return super.insertBefore(this.nodeOrShadowRoot(t), e, i)
  }
  removeChild(t, e) {
    return super.removeChild(null, e)
  }
  parentNode(t) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot)
  }
}
, _l = class extends gl {
  sharedStylesHost;
  removeStylesOnCompDestroy;
  styles;
  styleUrls;
  constructor(t, e, i, r, o, s, a, l, c) {
    super(t, o, s, a, l), this.sharedStylesHost = e,
                          this.removeStylesOnCompDestroy = r;
    let d = i.styles;
    this.styles = c ? BD(c, d) : d, this.styleUrls = i.getExternalStyles?.(c)
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles, this.styleUrls)
  }
  destroy() {
    this.removeStylesOnCompDestroy &&
        this.sharedStylesHost.removeStyles(this.styles, this.styleUrls)
  }
}
, Wu = class extends _l {
  contentAttr;
  hostAttr;
  constructor(t, e, i, r, o, s, a, l, c) {
    let d = r + '-' + i.id;
    super(t, e, i, o, s, a, l, c, d), this.contentAttr = eF(d),
                                      this.hostAttr = tF(d)
  }
  applyToHost(t) {
    this.applyStyles(), this.setAttribute(t, this.hostAttr, '')
  }
  createElement(t, e) {
    let i = super.createElement(t, e);
    return super.setAttribute(i, this.contentAttr, ''), i
  }
}
, nF = (() => {
    class n extends Uu {
      constructor(e) {
        super(e)
      }
      supports(e) {
        return !0
      }
      addEventListener(e, i, r, o) {
        return e.addEventListener(i, r, o),
               () => this.removeEventListener(e, i, r, o)
      }
      removeEventListener(e, i, r, o) {
        return e.removeEventListener(i, r, o)
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(ce))
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })(),
  FD = ['alt', 'control', 'meta', 'shift'], iF = {
    '\b': 'Backspace',
    '	': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    Del: 'Delete',
    Esc: 'Escape',
    Left: 'ArrowLeft',
    Right: 'ArrowRight',
    Up: 'ArrowUp',
    Down: 'ArrowDown',
    Menu: 'ContextMenu',
    Scroll: 'ScrollLock',
    Win: 'OS'
  },
  rF = {
    alt: n => n.altKey,
    control: n => n.ctrlKey,
    meta: n => n.metaKey,
    shift: n => n.shiftKey
  },
  oF = (() => {
    class n extends Uu {
      constructor(e) {
        super(e)
      }
      supports(e) {
        return n.parseEventName(e) != null
      }
      addEventListener(e, i, r, o) {
        let s = n.parseEventName(i),
            a = n.eventCallback(s.fullKey, r, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(
            () => hi().onAndCancel(e, s.domEventName, a, o))
      }
      static parseEventName(e) {
        let i = e.toLowerCase().split('.'), r = i.shift();
        if (i.length === 0 || !(r === 'keydown' || r === 'keyup')) return null;
        let o = n._normalizeKey(i.pop()), s = '', a = i.indexOf('code');
        if (a > -1 && (i.splice(a, 1), s = 'code.'), FD.forEach(c => {
              let d = i.indexOf(c);
              d > -1 && (i.splice(d, 1), s += c + '.')
            }),
            s += o, i.length != 0 || o.length === 0)
          return null;
        let l = {};
        return l.domEventName = r, l.fullKey = s, l
      }
      static matchEventFullKeyCode(e, i) {
        let r = iF[e.key] || e.key, o = '';
        return i.indexOf('code.') > -1 && (r = e.code, o = 'code.'),
               r == null || !r ?
                   !1 :
                   (r = r.toLowerCase(),
                    r === ' ' ? r = 'space' : r === '.' && (r = 'dot'),
                    FD.forEach(s => {
                      if (s !== r) {
                        let a = rF[s];
                        a(e) && (o += s + '.')
                      }
                    }),
                    o += r, o === i)
      }
      static eventCallback(e, i, r) {
        return o => {
          n.matchEventFullKeyCode(o, e) && r.runGuarded(() => i(o))
        }
      }
      static _normalizeKey(e) {
        return e === 'esc' ? 'escape' : e
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(ce))
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })();
function sF() {
  i_.makeCurrent()
}
function aF() {
  return new ln
}
function lF() {
  return fx(document), document
}
var cF =
        [
          {provide: Fn, useValue: Qg}, {provide: cg, useValue: sF, multi: !0},
          {provide: ce, useFactory: lF, deps: []}
        ],
    c_ = Vg(XC, 'browser', cF);
var dF =
        [
          {provide: cl, useClass: r_, deps: []},
          {provide: Ng, useClass: Eu, deps: [U, ku, cl]},
          {provide: Eu, useClass: Eu, deps: [U, ku, cl]}
        ],
    uF =
        [
          {provide: ru, useValue: 'root'},
          {provide: ln, useFactory: aF, deps: []},
          {provide: o_, useClass: nF, multi: !0, deps: [ce]},
          {provide: o_, useClass: oF, multi: !0, deps: [ce]}, $u, VD, LD,
          {provide: Ot, useExisting: $u}, {provide: Os, useClass: QP, deps: []},
          []
        ],
    qu = (() => {
      class n {
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({providers: [...uF, ...dF], imports: [Er, JC]})
      } return n
    })();
var zD = (() => {
  class n {
    _doc;
    constructor(e) {
      this._doc = e
    }
    getTitle() {
      return this._doc.title
    }
    setTitle(e) {
      this._doc.title = e || ''
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(ce))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
var bl = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({
      token: n,
      factory: function(i) {
        let r = null;
        return i ? r = new (i || n) : r = A(mF), r
      },
      providedIn: 'root'
    })
  } return n
})(),
    mF = (() => {
      class n extends bl {
        _doc;
        constructor(e) {
          super(), this._doc = e
        }
        sanitize(e, i) {
          if (i == null) return null;
          switch (e) {
            case Et.NONE:
              return i;
            case Et.HTML:
              return xo(i, 'HTML') ? di(i) :
                                     Tx(this._doc, String(i)).toString();
            case Et.STYLE:
              return xo(i, 'Style') ? di(i) : i;
            case Et.SCRIPT:
              if (xo(i, 'Script')) return di(i);
              throw new S(5200, !1);
            case Et.URL:
              return xo(i, 'URL') ? di(i) : pu(String(i));
            case Et.RESOURCE_URL:
              if (xo(i, 'ResourceURL')) return di(i);
              throw new S(5201, !1);
            default:
              throw new S(5202, !1)
          }
        }
        bypassSecurityTrustHtml(e) {
          return yx(e)
        }
        bypassSecurityTrustStyle(e) {
          return wx(e)
        }
        bypassSecurityTrustScript(e) {
          return xx(e)
        }
        bypassSecurityTrustUrl(e) {
          return Cx(e)
        }
        bypassSecurityTrustResourceUrl(e) {
          return Dx(e)
        }
        static \u0275fac = function(i) {
          return new (i || n)(A(ce))
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
var QD = (() => {
  class n {
    _renderer;
    _elementRef;
    onChange = e => {};
    onTouched = () => {};
    constructor(e, i) {
      this._renderer = e, this._elementRef = i
    }
    setProperty(e, i) {
      this._renderer.setProperty(this._elementRef.nativeElement, e, i)
    }
    registerOnTouched(e) {
      this.onTouched = e
    }
    registerOnChange(e) {
      this.onChange = e
    }
    setDisabledState(e) {
      this.setProperty('disabled', e)
    }
    static \u0275fac = function(i) {
      return new (i || n)(z(rt), z(L))
    };
    static \u0275dir = T({type: n})
  } return n
})(),
    hF = (() => {
      class n extends QD {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({type: n, features: [te]})
      } return n
    })(),
    Ro = new w('');
var fF = {provide: Ro, useExisting: Zt(() => pi), multi: !0};
function pF() {
  let n = hi() ? hi().getUserAgent() : '';
  return /android (\d+)/.test(n.toLowerCase())
}
var gF = new w(''),
    pi = (() => {
      class n extends QD {
        _compositionMode;
        _composing = !1;
        constructor(e, i, r) {
          super(e, i),
              this._compositionMode = r,
              this._compositionMode == null && (this._compositionMode = !pF())
        }
        writeValue(e) {
          let i = e ?? '';
          this.setProperty('value', i)
        }
        _handleInput(e) {
          (!this._compositionMode ||
           this._compositionMode && !this._composing) &&
              this.onChange(e)
        }
        _compositionStart() {
          this._composing = !0
        }
        _compositionEnd(e) {
          this._composing = !1, this._compositionMode && this.onChange(e)
        }
        static \u0275fac = function(i) {
          return new (i || n)(z(rt), z(L), z(gF, 8))
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['input', 'formControlName', '', 3, 'type', 'checkbox'],
            ['textarea', 'formControlName', ''],
            ['input', 'formControl', '', 3, 'type', 'checkbox'],
            ['textarea', 'formControl', ''],
            ['input', 'ngModel', '', 3, 'type', 'checkbox'],
            ['textarea', 'ngModel', ''], ['', 'ngDefaultControl', '']
          ],
          hostBindings: function(i, r) {
            i&1 && M('input', function(s) {
              return r._handleInput(s.target.value)
            })('blur', function() {
              return r.onTouched()
            })('compositionstart', function() {
              return r._compositionStart()
            })('compositionend', function(s) {
              return r._compositionEnd(s.target.value)
            })
          },
          standalone: !1,
          features: [ye([fF]), te]
        })
      } return n
    })();
function f_(n) {
  return n == null || p_(n) === 0
}
function p_(n) {
  return n == null                             ? null :
      Array.isArray(n) || typeof n == 'string' ? n.length :
      n instanceof Set                         ? n.size :
                                                 null
}
var Mr = new w(''), im = new w(''),
    _F =
        /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    Ls = class {
  static min(t) {
    return bF(t)
  }
  static max(t) {
    return vF(t)
  }
  static required(t) {
    return yF(t)
  }
  static requiredTrue(t) {
    return wF(t)
  }
  static email(t) {
    return xF(t)
  }
  static minLength(t) {
    return CF(t)
  }
  static maxLength(t) {
    return DF(t)
  }
  static pattern(t) {
    return EF(t)
  }
  static nullValidator(t) {
    return YD()
  }
  static compose(t) {
    return tE(t)
  }
  static composeAsync(t) {
    return nE(t)
  }
};
function bF(n) {
  return t => {
    if (t.value == null || n == null) return null;
    let e = parseFloat(t.value);
    return !isNaN(e) && e < n ? {min: {min: n, actual: t.value}} : null
  }
}
function vF(n) {
  return t => {
    if (t.value == null || n == null) return null;
    let e = parseFloat(t.value);
    return !isNaN(e) && e > n ? {max: {max: n, actual: t.value}} : null
  }
}
function yF(n) {
  return f_(n.value) ? {required: !0} : null
}
function wF(n) {
  return n.value === !0 ? null : {required: !0}
}
function xF(n) {
  return f_(n.value) || _F.test(n.value) ? null : {email: !0}
}
function CF(n) {
  return t => {
    let e = t.value?.length ?? p_(t.value);
    return e === null || e === 0 ? null :
        e < n ? {minlength: {requiredLength: n, actualLength: e}} :
                null
  }
}
function DF(n) {
  return t => {
    let e = t.value?.length ?? p_(t.value);
    return e !== null && e > n ?
        {maxlength: {requiredLength: n, actualLength: e}} :
        null
  }
}
function EF(n) {
  if (!n) return YD;
  let t, e;
  return typeof n == 'string' ?
             (e = '', n.charAt(0) !== '^' && (e += '^'), e += n,
              n.charAt(n.length - 1) !== '$' && (e += '$'), t = new RegExp(e)) :
             (e = n.toString(), t = n),
         i => {
           if (f_(i.value)) return null;
           let r = i.value;
           return t.test(r) ? null :
                              {pattern: {requiredPattern: e, actualValue: r}}
         }
}
function YD(n) {
  return null
}
function ZD(n) {
  return n != null
}
function KD(n) {
  return wr(n) ? Ue(n) : n
}
function XD(n) {
  let t = {};
  return n.forEach(e => {t = e != null ? y(y({}, t), e) : t}),
         Object.keys(t).length === 0 ? null : t
}
function JD(n, t) {
  return t.map(e => e(n))
}
function kF(n) {
  return !n.validate
}
function eE(n) {
  return n.map(t => kF(t) ? t : e => t.validate(e))
}
function tE(n) {
  if (!n) return null;
  let t = n.filter(ZD);
  return t.length == 0 ? null : function(e) {
    return XD(JD(e, t))
  }
}
function g_(n) {
  return n != null ? tE(eE(n)) : null
}
function nE(n) {
  if (!n) return null;
  let t = n.filter(ZD);
  return t.length == 0 ? null : function(e) {
    let i = JD(e, t).map(KD);
    return Fa(i).pipe(Q(XD))
  }
}
function __(n) {
  return n != null ? nE(eE(n)) : null
}
function HD(n, t) {
  return n === null ? [t] : Array.isArray(n) ? [...n, t] : [n, t]
}
function iE(n) {
  return n._rawValidators
}
function rE(n) {
  return n._rawAsyncValidators
}
function d_(n) {
  return n ? Array.isArray(n) ? n : [n] : []
}
function Yu(n, t) {
  return Array.isArray(n) ? n.includes(t) : n === t
}
function UD(n, t) {
  let e = d_(t);
  return d_(n).forEach(r => {Yu(e, r) || e.push(r)}), e
}
function $D(n, t) {
  return d_(t).filter(e => !Yu(n, e))
}
var Zu = class {
  get value() {
    return this.control ? this.control.value : null
  }
  get valid() {
    return this.control ? this.control.valid : null
  }
  get invalid() {
    return this.control ? this.control.invalid : null
  }
  get pending() {
    return this.control ? this.control.pending : null
  }
  get disabled() {
    return this.control ? this.control.disabled : null
  }
  get enabled() {
    return this.control ? this.control.enabled : null
  }
  get errors() {
    return this.control ? this.control.errors : null
  }
  get pristine() {
    return this.control ? this.control.pristine : null
  }
  get dirty() {
    return this.control ? this.control.dirty : null
  }
  get touched() {
    return this.control ? this.control.touched : null
  }
  get status() {
    return this.control ? this.control.status : null
  }
  get untouched() {
    return this.control ? this.control.untouched : null
  }
  get statusChanges() {
    return this.control ? this.control.statusChanges : null
  }
  get valueChanges() {
    return this.control ? this.control.valueChanges : null
  }
  get path() {
    return null
  }
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators = [];
  _rawAsyncValidators = [];
  _setValidators(t) {
    this._rawValidators = t || [],
    this._composedValidatorFn = g_(this._rawValidators)
  }
  _setAsyncValidators(t) {
    this._rawAsyncValidators = t || [],
    this._composedAsyncValidatorFn = __(this._rawAsyncValidators)
  }
  get validator() {
    return this._composedValidatorFn || null
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null
  }
  _onDestroyCallbacks = [];
  _registerOnDestroy(t) {
    this._onDestroyCallbacks.push(t)
  }
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = []
  }
  reset(t = void 0) {
    this.control && this.control.reset(t)
  }
  hasError(t, e) {
    return this.control ? this.control.hasError(t, e) : !1
  }
  getError(t, e) {
    return this.control ? this.control.getError(t, e) : null
  }
}
, To = class extends Zu {
  name;
  get formDirective() {
    return null
  }
  get path() {
    return null
  }
}
, Bn = class extends Zu {
  _parent = null;
  name = null;
  valueAccessor = null
}
, u_ = class {
  _cd;
  constructor(t) {
    this._cd = t
  }
  get isTouched() {
    return this._cd?.control?._touched?.(), !!this._cd?.control?.touched
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched
  }
  get isPristine() {
    return this._cd?.control?._pristine?.(), !!this._cd?.control?.pristine
  }
  get isDirty() {
    return !!this._cd?.control?.dirty
  }
  get isValid() {
    return this._cd?.control?._status?.(), !!this._cd?.control?.valid
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid
  }
  get isPending() {
    return !!this._cd?.control?.pending
  }
  get isSubmitted() {
    return this._cd?._submitted?.(), !!this._cd?.submitted
  }
}
, SF = {
  '[class.ng-untouched]': 'isUntouched',
  '[class.ng-touched]': 'isTouched',
  '[class.ng-pristine]': 'isPristine',
  '[class.ng-dirty]': 'isDirty',
  '[class.ng-valid]': 'isValid',
  '[class.ng-invalid]': 'isInvalid',
  '[class.ng-pending]': 'isPending'
},
  zQ = ae(y({}, SF), {'[class.ng-submitted]': 'isSubmitted'}),
  Tr = (() => {
    class n extends u_ {
      constructor(e) {
        super(e)
      }
      static \u0275fac = function(i) {
        return new (i || n)(z(Bn, 2))
      };
      static \u0275dir = T({
        type: n,
        selectors: [
          ['', 'formControlName', ''], ['', 'ngModel', ''],
          ['', 'formControl', '']
        ],
        hostVars: 14,
        hostBindings: function(i, r) {
          i&2 &&
              Y('ng-untouched', r.isUntouched)('ng-touched', r.isTouched)(
                  'ng-pristine', r.isPristine)('ng-dirty', r.isDirty)(
                  'ng-valid', r.isValid)('ng-invalid', r.isInvalid)(
                  'ng-pending', r.isPending)
        },
        standalone: !1,
        features: [te]
      })
    } return n
  })();
var vl = 'VALID', Qu = 'INVALID', Ps = 'PENDING', yl = 'DISABLED', Ir = class {}
, Ku = class extends Ir {
  value;
  source;
  constructor(t, e) {
    super(), this.value = t, this.source = e
  }
}
, xl = class extends Ir {
  pristine;
  source;
  constructor(t, e) {
    super(), this.pristine = t, this.source = e
  }
}
, Cl = class extends Ir {
  touched;
  source;
  constructor(t, e) {
    super(), this.touched = t, this.source = e
  }
}
, Fs = class extends Ir {
  status;
  source;
  constructor(t, e) {
    super(), this.status = t, this.source = e
  }
}
, m_ = class extends Ir {
  source;
  constructor(t) {
    super(), this.source = t
  }
}
, h_ = class extends Ir {
  source;
  constructor(t) {
    super(), this.source = t
  }
};
function oE(n) {
  return (rm(n) ? n.validators : n) || null
}
function IF(n) {
  return Array.isArray(n) ? g_(n) : n || null
}
function sE(n, t) {
  return (rm(t) ? t.asyncValidators : n) || null
}
function MF(n) {
  return Array.isArray(n) ? __(n) : n || null
}
function rm(n) {
  return n != null && !Array.isArray(n) && typeof n == 'object'
}
function TF(n, t, e) {
  let i = n.controls;
  if (!(t ? Object.keys(i) : i).length) throw new S(1e3, '');
  if (!i[e]) throw new S(1001, '')
}
function RF(n, t, e) {
  n._forEachChild((i, r) => {
    if (e[r] === void 0) throw new S(1002, '')
  })
}
var Xu = class {
  _pendingDirty = !1;
  _hasOwnPendingAsyncValidator = null;
  _pendingTouched = !1;
  _onCollectionChange = () => {};
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators;
  _rawAsyncValidators;
  value;
  constructor(t, e) {
    this._assignValidators(t), this._assignAsyncValidators(e)
  }
  get validator() {
    return this._composedValidatorFn
  }
  set validator(t) {
    this._rawValidators = this._composedValidatorFn = t
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn
  }
  set asyncValidator(t) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = t
  }
  get parent() {
    return this._parent
  }
  get status() {
    return tn(this.statusReactive)
  }
  set status(t) {
    tn(() => this.statusReactive.set(t))
  }
  _status = mi(() => this.statusReactive());
  statusReactive = Jt(void 0);
  get valid() {
    return this.status === vl
  }
  get invalid() {
    return this.status === Qu
  }
  get pending() {
    return this.status == Ps
  }
  get disabled() {
    return this.status === yl
  }
  get enabled() {
    return this.status !== yl
  }
  errors;
  get pristine() {
    return tn(this.pristineReactive)
  }
  set pristine(t) {
    tn(() => this.pristineReactive.set(t))
  }
  _pristine = mi(() => this.pristineReactive());
  pristineReactive = Jt(!0);
  get dirty() {
    return !this.pristine
  }
  get touched() {
    return tn(this.touchedReactive)
  }
  set touched(t) {
    tn(() => this.touchedReactive.set(t))
  }
  _touched = mi(() => this.touchedReactive());
  touchedReactive = Jt(!1);
  get untouched() {
    return !this.touched
  }
  _events = new I;
  events = this._events.asObservable();
  valueChanges;
  statusChanges;
  get updateOn() {
    return this._updateOn ? this._updateOn :
        this.parent       ? this.parent.updateOn :
                            'change'
  }
  setValidators(t) {
    this._assignValidators(t)
  }
  setAsyncValidators(t) {
    this._assignAsyncValidators(t)
  }
  addValidators(t) {
    this.setValidators(UD(t, this._rawValidators))
  }
  addAsyncValidators(t) {
    this.setAsyncValidators(UD(t, this._rawAsyncValidators))
  }
  removeValidators(t) {
    this.setValidators($D(t, this._rawValidators))
  }
  removeAsyncValidators(t) {
    this.setAsyncValidators($D(t, this._rawAsyncValidators))
  }
  hasValidator(t) {
    return Yu(this._rawValidators, t)
  }
  hasAsyncValidator(t) {
    return Yu(this._rawAsyncValidators, t)
  }
  clearValidators() {
    this.validator = null
  }
  clearAsyncValidators() {
    this.asyncValidator = null
  }
  markAsTouched(t = {}) {
    let e = this.touched === !1;
    this.touched = !0;
    let i = t.sourceControl ?? this;
    this._parent && !t.onlySelf &&
        this._parent.markAsTouched(ae(y({}, t), {sourceControl: i})),
        e && t.emitEvent !== !1 && this._events.next(new Cl(!0, i))
  }
  markAllAsTouched(t = {}) {
    this.markAsTouched(
        {onlySelf: !0, emitEvent: t.emitEvent, sourceControl: this}),
        this._forEachChild(e => e.markAllAsTouched(t))
  }
  markAsUntouched(t = {}) {
    let e = this.touched === !0;
    this.touched = !1, this._pendingTouched = !1;
    let i = t.sourceControl ?? this;
    this._forEachChild(
        r => {r.markAsUntouched(
            {onlySelf: !0, emitEvent: t.emitEvent, sourceControl: i})}),
        this._parent && !t.onlySelf && this._parent._updateTouched(t, i),
        e && t.emitEvent !== !1 && this._events.next(new Cl(!1, i))
  }
  markAsDirty(t = {}) {
    let e = this.pristine === !0;
    this.pristine = !1;
    let i = t.sourceControl ?? this;
    this._parent && !t.onlySelf &&
        this._parent.markAsDirty(ae(y({}, t), {sourceControl: i})),
        e && t.emitEvent !== !1 && this._events.next(new xl(!1, i))
  }
  markAsPristine(t = {}) {
    let e = this.pristine === !1;
    this.pristine = !0, this._pendingDirty = !1;
    let i = t.sourceControl ?? this;
    this._forEachChild(
        r => {r.markAsPristine({onlySelf: !0, emitEvent: t.emitEvent})}),
        this._parent && !t.onlySelf && this._parent._updatePristine(t, i),
        e && t.emitEvent !== !1 && this._events.next(new xl(!0, i))
  }
  markAsPending(t = {}) {
    this.status = Ps;
    let e = t.sourceControl ?? this;
    t.emitEvent !== !1 &&
        (this._events.next(new Fs(this.status, e)),
         this.statusChanges.emit(this.status)),
        this._parent && !t.onlySelf &&
        this._parent.markAsPending(ae(y({}, t), {sourceControl: e}))
  }
  disable(t = {}) {
    let e = this._parentMarkedDirty(t.onlySelf);
    this.status = yl, this.errors = null,
    this._forEachChild(r => {r.disable(ae(y({}, t), {onlySelf: !0}))}),
    this._updateValue();
    let i = t.sourceControl ?? this;
    t.emitEvent !== !1 &&
        (this._events.next(new Ku(this.value, i)),
         this._events.next(new Fs(this.status, i)),
         this.valueChanges.emit(this.value),
         this.statusChanges.emit(this.status)),
        this._updateAncestors(ae(y({}, t), {skipPristineCheck: e}), this),
        this._onDisabledChange.forEach(r => r(!0))
  }
  enable(t = {}) {
    let e = this._parentMarkedDirty(t.onlySelf);
    this.status = vl,
    this._forEachChild(i => {i.enable(ae(y({}, t), {onlySelf: !0}))}),
    this.updateValueAndValidity({onlySelf: !0, emitEvent: t.emitEvent}),
    this._updateAncestors(ae(y({}, t), {skipPristineCheck: e}), this),
    this._onDisabledChange.forEach(i => i(!1))
  }
  _updateAncestors(t, e) {
    this._parent && !t.onlySelf &&
        (this._parent.updateValueAndValidity(t),
         t.skipPristineCheck || this._parent._updatePristine({}, e),
         this._parent._updateTouched({}, e))
  }
  setParent(t) {
    this._parent = t
  }
  getRawValue() {
    return this.value
  }
  updateValueAndValidity(t = {}) {
    if (this._setInitialStatus(), this._updateValue(), this.enabled) {
      let i = this._cancelExistingSubscription();
      this.errors = this._runValidator(), this.status = this._calculateStatus(),
      (this.status === vl || this.status === Ps) &&
          this._runAsyncValidator(i, t.emitEvent)
    }
    let e = t.sourceControl ?? this;
    t.emitEvent !== !1 &&
        (this._events.next(new Ku(this.value, e)),
         this._events.next(new Fs(this.status, e)),
         this.valueChanges.emit(this.value),
         this.statusChanges.emit(this.status)),
        this._parent && !t.onlySelf &&
        this._parent.updateValueAndValidity(ae(y({}, t), {sourceControl: e}))
  }
  _updateTreeValidity(t = {emitEvent: !0}) {
    this._forEachChild(e => e._updateTreeValidity(t)),
        this.updateValueAndValidity({onlySelf: !0, emitEvent: t.emitEvent})
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? yl : vl
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null
  }
  _runAsyncValidator(t, e) {
    if (this.asyncValidator) {
      this.status = Ps,
      this._hasOwnPendingAsyncValidator = {emitEvent: e !== !1};
      let i = KD(this.asyncValidator(this));
      this._asyncValidationSubscription = i.subscribe(r => {
        this._hasOwnPendingAsyncValidator = null,
        this.setErrors(r, {emitEvent: e, shouldHaveEmitted: t})
      })
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      let t = this._hasOwnPendingAsyncValidator?.emitEvent ?? !1;
      return this._hasOwnPendingAsyncValidator = null, t
    }
    return !1
  }
  setErrors(t, e = {}) {
    this.errors = t,
    this._updateControlsErrors(e.emitEvent !== !1, this, e.shouldHaveEmitted)
  }
  get(t) {
    let e = t;
    return e == null ||
            (Array.isArray(e) || (e = e.split('.')), e.length === 0) ?
        null :
        e.reduce((i, r) => i && i._find(r), this)
  }
  getError(t, e) {
    let i = e ? this.get(e) : this;
    return i && i.errors ? i.errors[t] : null
  }
  hasError(t, e) {
    return !!this.getError(t, e)
  }
  get root() {
    let t = this;
    for (; t._parent;) t = t._parent;
    return t
  }
  _updateControlsErrors(t, e, i) {
    this.status = this._calculateStatus(),
    t && this.statusChanges.emit(this.status),
    (t || i) && this._events.next(new Fs(this.status, e)),
    this._parent && this._parent._updateControlsErrors(t, e, i)
  }
  _initObservables() {
    this.valueChanges = new H, this.statusChanges = new H
  }
  _calculateStatus() {
    return this._allControlsDisabled() ? yl :
        this.errors                    ? Qu :
        this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Ps) ?
                      Ps :
        this._anyControlsHaveStatus(Qu) ? Qu :
                                          vl
  }
  _anyControlsHaveStatus(t) {
    return this._anyControls(e => e.status === t)
  }
  _anyControlsDirty() {
    return this._anyControls(t => t.dirty)
  }
  _anyControlsTouched() {
    return this._anyControls(t => t.touched)
  }
  _updatePristine(t, e) {
    let i = !this._anyControlsDirty(), r = this.pristine !== i;
    this.pristine = i,
    this._parent && !t.onlySelf && this._parent._updatePristine(t, e),
    r && this._events.next(new xl(this.pristine, e))
  }
  _updateTouched(t = {}, e) {
    this.touched = this._anyControlsTouched(),
    this._events.next(new Cl(this.touched, e)),
    this._parent && !t.onlySelf && this._parent._updateTouched(t, e)
  }
  _onDisabledChange = [];
  _registerOnCollectionChange(t) {
    this._onCollectionChange = t
  }
  _setUpdateStrategy(t) {
    rm(t) && t.updateOn != null && (this._updateOn = t.updateOn)
  }
  _parentMarkedDirty(t) {
    let e = this._parent && this._parent.dirty;
    return !t && !!e && !this._parent._anyControlsDirty()
  }
  _find(t) {
    return null
  }
  _assignValidators(t) {
    this._rawValidators = Array.isArray(t) ? t.slice() : t,
    this._composedValidatorFn = IF(this._rawValidators)
  }
  _assignAsyncValidators(t) {
    this._rawAsyncValidators = Array.isArray(t) ? t.slice() : t,
    this._composedAsyncValidatorFn = MF(this._rawAsyncValidators)
  }
}
, Ju = class extends Xu {
  constructor(t, e, i) {
    super(oE(e), sE(i, e)),
        this.controls = t, this._initObservables(), this._setUpdateStrategy(e),
        this._setUpControls(),
        this.updateValueAndValidity(
            {onlySelf: !0, emitEvent: !!this.asyncValidator})
  }
  controls;
  registerControl(t, e) {
    return this.controls[t] ?
        this.controls[t] :
        (this.controls[t] = e, e.setParent(this),
         e._registerOnCollectionChange(this._onCollectionChange), e)
  }
  addControl(t, e, i = {}) {
    this.registerControl(t, e),
        this.updateValueAndValidity({emitEvent: i.emitEvent}),
        this._onCollectionChange()
  }
  removeControl(t, e = {}) {
    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}),
        delete this.controls[t],
        this.updateValueAndValidity({emitEvent: e.emitEvent}),
        this._onCollectionChange()
  }
  setControl(t, e, i = {}) {
    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}),
        delete this.controls[t], e && this.registerControl(t, e),
        this.updateValueAndValidity({emitEvent: i.emitEvent}),
        this._onCollectionChange()
  }
  contains(t) {
    return this.controls.hasOwnProperty(t) && this.controls[t].enabled
  }
  setValue(t, e = {}) {
    RF(this, !0, t), Object.keys(t).forEach(i => {
      TF(this, !0, i),
      this.controls[i].setValue(t[i], {onlySelf: !0, emitEvent: e.emitEvent})
    }),
        this.updateValueAndValidity(e)
  }
  patchValue(t, e = {}) {
    t != null &&
        (Object.keys(t).forEach(i => {
          let r = this.controls[i];
          r && r.patchValue(t[i], {onlySelf: !0, emitEvent: e.emitEvent})
        }),
         this.updateValueAndValidity(e))
  }
  reset(t = {}, e = {}) {
    this._forEachChild(
        (i, r) => {
            i.reset(t ? t[r] : null, {onlySelf: !0, emitEvent: e.emitEvent})}),
        this._updatePristine(e, this), this._updateTouched(e, this),
        this.updateValueAndValidity(e)
  }
  getRawValue() {
    return this._reduceChildren({}, (t, e, i) => (t[i] = e.getRawValue(), t))
  }
  _syncPendingControls() {
    let t =
        this._reduceChildren(!1, (e, i) => i._syncPendingControls() ? !0 : e);
    return t && this.updateValueAndValidity({onlySelf: !0}), t
  }
  _forEachChild(t) {
    Object.keys(this.controls).forEach(e => {
      let i = this.controls[e];
      i && t(i, e)
    })
  }
  _setUpControls() {
    this._forEachChild(t => {
      t.setParent(this),
      t._registerOnCollectionChange(this._onCollectionChange)
    })
  }
  _updateValue() {
    this.value = this._reduceValue()
  }
  _anyControls(t) {
    for (let [e, i] of Object.entries(this.controls))
      if (this.contains(e) && t(i)) return !0;
    return !1
  }
  _reduceValue() {
    let t = {};
    return this._reduceChildren(
        t, (e, i, r) => ((i.enabled || this.disabled) && (e[r] = i.value), e))
  }
  _reduceChildren(t, e) {
    let i = t;
    return this._forEachChild((r, o) => {i = e(i, r, o)}), i
  }
  _allControlsDisabled() {
    for (let t of Object.keys(this.controls))
      if (this.controls[t].enabled) return !1;
    return Object.keys(this.controls).length > 0 || this.disabled
  }
  _find(t) {
    return this.controls.hasOwnProperty(t) ? this.controls[t] : null
  }
};
var Vs = new w('', {providedIn: 'root', factory: () => om}), om = 'always';
function AF(n, t) {
  return [...t.path, n]
}
function Dl(n, t, e = om) {
  b_(n, t), t.valueAccessor.writeValue(n.value),
      (n.disabled || e === 'always') &&
      t.valueAccessor.setDisabledState?.(n.disabled),
      NF(n, t), FF(n, t), PF(n, t), OF(n, t)
}
function em(n, t, e = !0) {
  let i = () => {};
  t.valueAccessor &&
      (t.valueAccessor.registerOnChange(i),
       t.valueAccessor.registerOnTouched(i)),
      nm(n, t),
      n &&
      (t._invokeOnDestroyCallbacks(), n._registerOnCollectionChange(() => {}))
}
function tm(n, t) {
  n.forEach(
      e => {e.registerOnValidatorChange && e.registerOnValidatorChange(t)})
}
function OF(n, t) {
  if (t.valueAccessor.setDisabledState) {
    let e = i => {
      t.valueAccessor.setDisabledState(i)
    };
    n.registerOnDisabledChange(e),
        t._registerOnDestroy(() => {n._unregisterOnDisabledChange(e)})
  }
}
function b_(n, t) {
  let e = iE(n);
  t.validator !== null ? n.setValidators(HD(e, t.validator)) :
                         typeof e == 'function' && n.setValidators([e]);
  let i = rE(n);
  t.asyncValidator !== null ?
      n.setAsyncValidators(HD(i, t.asyncValidator)) :
      typeof i == 'function' && n.setAsyncValidators([i]);
  let r = () => n.updateValueAndValidity();
  tm(t._rawValidators, r), tm(t._rawAsyncValidators, r)
}
function nm(n, t) {
  let e = !1;
  if (n !== null) {
    if (t.validator !== null) {
      let r = iE(n);
      if (Array.isArray(r) && r.length > 0) {
        let o = r.filter(s => s !== t.validator);
        o.length !== r.length && (e = !0, n.setValidators(o))
      }
    }
    if (t.asyncValidator !== null) {
      let r = rE(n);
      if (Array.isArray(r) && r.length > 0) {
        let o = r.filter(s => s !== t.asyncValidator);
        o.length !== r.length && (e = !0, n.setAsyncValidators(o))
      }
    }
  }
  let i = () => {};
  return tm(t._rawValidators, i), tm(t._rawAsyncValidators, i), e
}
function NF(n, t) {
  t.valueAccessor.registerOnChange(e => {
    n._pendingValue = e,
    n._pendingChange = !0,
    n._pendingDirty = !0,
    n.updateOn === 'change' && aE(n, t)
  })
}
function PF(n, t) {
  t.valueAccessor.registerOnTouched(() => {
    n._pendingTouched = !0,
    n.updateOn === 'blur' && n._pendingChange && aE(n, t),
    n.updateOn !== 'submit' && n.markAsTouched()
  })
}
function aE(n, t) {
  n._pendingDirty && n.markAsDirty(),
      n.setValue(n._pendingValue, {emitModelToViewChange: !1}),
      t.viewToModelUpdate(n._pendingValue), n._pendingChange = !1
}
function FF(n, t) {
  let e = (i, r) => {
    t.valueAccessor.writeValue(i), r && t.viewToModelUpdate(i)
  };
  n.registerOnChange(e), t._registerOnDestroy(() => {n._unregisterOnChange(e)})
}
function lE(n, t) {
  n == null, b_(n, t)
}
function LF(n, t) {
  return nm(n, t)
}
function cE(n, t) {
  if (!n.hasOwnProperty('model')) return !1;
  let e = n.model;
  return e.isFirstChange() ? !0 : !Object.is(t, e.currentValue)
}
function VF(n) {
  return Object.getPrototypeOf(n.constructor) === hF
}
function dE(n, t) {
  n._syncPendingControls(), t.forEach(e => {
    let i = e.control;
    i.updateOn === 'submit' && i._pendingChange &&
        (e.viewToModelUpdate(i._pendingValue), i._pendingChange = !1)
  })
}
function uE(n, t) {
  if (!t) return null;
  Array.isArray(t);
  let e, i, r;
  return t.forEach(
             o => {
                 o.constructor === pi ? e = o :
                     VF(o)            ? i = o :
                                        r = o}),
         r || i || e || null
}
function jF(n, t) {
  let e = n.indexOf(t);
  e > -1 && n.splice(e, 1)
}
var BF = {provide: To, useExisting: Zt(() => El)}, wl = Promise.resolve(),
    El = (() => {
      class n extends To {
        callSetDisabledState;
        get submitted() {
          return tn(this.submittedReactive)
        }
        _submitted = mi(() => this.submittedReactive());
        submittedReactive = Jt(!1);
        _directives = new Set;
        form;
        ngSubmit = new H;
        options;
        constructor(e, i, r) {
          super(), this.callSetDisabledState = r,
                   this.form = new Ju({}, g_(e), __(i))
        }
        ngAfterViewInit() {
          this._setUpdateStrategy()
        }
        get formDirective() {
          return this
        }
        get control() {
          return this.form
        }
        get path() {
          return []
        }
        get controls() {
          return this.form.controls
        }
        addControl(e) {
          wl.then(() => {
            let i = this._findContainer(e.path);
            e.control = i.registerControl(e.name, e.control),
            Dl(e.control, e, this.callSetDisabledState),
            e.control.updateValueAndValidity({emitEvent: !1}),
            this._directives.add(e)
          })
        }
        getControl(e) {
          return this.form.get(e.path)
        }
        removeControl(e) {
          wl.then(() => {
            let i = this._findContainer(e.path);
            i && i.removeControl(e.name), this._directives.delete(e)
          })
        }
        addFormGroup(e) {
          wl.then(() => {
            let i = this._findContainer(e.path), r = new Ju({});
            lE(r, e), i.registerControl(e.name, r),
                r.updateValueAndValidity({emitEvent: !1})
          })
        }
        removeFormGroup(e) {
          wl.then(() => {
            let i = this._findContainer(e.path);
            i && i.removeControl(e.name)
          })
        }
        getFormGroup(e) {
          return this.form.get(e.path)
        }
        updateModel(e, i) {
          wl.then(() => {this.form.get(e.path).setValue(i)})
        }
        setValue(e) {
          this.control.setValue(e)
        }
        onSubmit(e) {
          return this.submittedReactive.set(!0),
                 dE(this.form, this._directives), this.ngSubmit.emit(e),
                 e?.target?.method === 'dialog'
        }
        onReset() {
          this.resetForm()
        }
        resetForm(e = void 0) {
          this.form.reset(e), this.submittedReactive.set(!1)
        }
        _setUpdateStrategy() {
          this.options && this.options.updateOn != null &&
              (this.form._updateOn = this.options.updateOn)
        }
        _findContainer(e) {
          return e.pop(), e.length ? this.form.get(e) : this.form
        }
        static \u0275fac = function(i) {
          return new (i || n)(z(Mr, 10), z(im, 10), z(Vs, 8))
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['form', 3, 'ngNoForm', '', 3, 'formGroup', ''], ['ng-form'],
            ['', 'ngForm', '']
          ],
          hostBindings: function(i, r) {
            i&1 && M('submit', function(s) {
              return r.onSubmit(s)
            })('reset', function() {
              return r.onReset()
            })
          },
          inputs: {options: [0, 'ngFormOptions', 'options']},
          outputs: {ngSubmit: 'ngSubmit'},
          exportAs: ['ngForm'],
          standalone: !1,
          features: [ye([BF]), te]
        })
      } return n
    })();
function WD(n, t) {
  let e = n.indexOf(t);
  e > -1 && n.splice(e, 1)
}
function qD(n) {
  return typeof n == 'object' && n !== null && Object.keys(n).length === 2 &&
      'value' in n && 'disabled' in n
}
var sm = class extends Xu {
  defaultValue = null;
  _onChange = [];
  _pendingValue;
  _pendingChange = !1;
  constructor(t = null, e, i) {
    super(oE(e), sE(i, e)), this._applyFormState(t), this._setUpdateStrategy(e),
        this._initObservables(),
        this.updateValueAndValidity(
            {onlySelf: !0, emitEvent: !!this.asyncValidator}),
        rm(e) && (e.nonNullable || e.initialValueIsDefault) &&
        (qD(t) ? this.defaultValue = t.value : this.defaultValue = t)
  }
  setValue(t, e = {}) {
    this.value = this._pendingValue = t,
    this._onChange.length && e.emitModelToViewChange !== !1 &&
        this._onChange.forEach(
            i => i(this.value, e.emitViewToModelChange !== !1)),
    this.updateValueAndValidity(e)
  }
  patchValue(t, e = {}) {
    this.setValue(t, e)
  }
  reset(t = this.defaultValue, e = {}) {
    this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e),
        this.setValue(this.value, e), this._pendingChange = !1
  }
  _updateValue() {}
  _anyControls(t) {
    return !1
  }
  _allControlsDisabled() {
    return this.disabled
  }
  registerOnChange(t) {
    this._onChange.push(t)
  }
  _unregisterOnChange(t) {
    WD(this._onChange, t)
  }
  registerOnDisabledChange(t) {
    this._onDisabledChange.push(t)
  }
  _unregisterOnDisabledChange(t) {
    WD(this._onDisabledChange, t)
  }
  _forEachChild(t) {}
  _syncPendingControls() {
    return this.updateOn === 'submit' &&
            (this._pendingDirty && this.markAsDirty(),
             this._pendingTouched && this.markAsTouched(),
             this._pendingChange) ?
        (this.setValue(
             this._pendingValue, {onlySelf: !0, emitModelToViewChange: !1}),
         !0) :
        !1
  }
  _applyFormState(t) {
    qD(t) ? (this.value = this._pendingValue = t.value,
             t.disabled ? this.disable({onlySelf: !0, emitEvent: !1}) :
                          this.enable({onlySelf: !0, emitEvent: !1})) :
            this.value = this._pendingValue = t
  }
};
var zF = n => n instanceof sm;
var HF = {provide: Bn, useExisting: Zt(() => Gi)}, GD = Promise.resolve(),
    Gi = (() => {
      class n extends Bn {
        _changeDetectorRef;
        callSetDisabledState;
        control = new sm;
        static ngAcceptInputType_isDisabled;
        _registered = !1;
        viewModel;
        name = '';
        isDisabled;
        model;
        options;
        update = new H;
        constructor(e, i, r, o, s, a) {
          super(), this._changeDetectorRef = s, this.callSetDisabledState = a,
                   this._parent = e, this._setValidators(i),
                   this._setAsyncValidators(r), this.valueAccessor = uE(this, o)
        }
        ngOnChanges(e) {
          if (this._checkForErrors(), !this._registered || 'name' in e) {
            if (this._registered && (this._checkName(), this.formDirective)) {
              let i = e.name.previousValue;
              this.formDirective.removeControl(
                  {name: i, path: this._getPath(i)})
            }
            this._setUpControl()
          }
          'isDisabled' in e && this._updateDisabled(e),
              cE(e, this.viewModel) &&
              (this._updateValue(this.model), this.viewModel = this.model)
        }
        ngOnDestroy() {
          this.formDirective && this.formDirective.removeControl(this)
        }
        get path() {
          return this._getPath(this.name)
        }
        get formDirective() {
          return this._parent ? this._parent.formDirective : null
        }
        viewToModelUpdate(e) {
          this.viewModel = e, this.update.emit(e)
        }
        _setUpControl() {
          this._setUpdateStrategy(),
              this._isStandalone() ? this._setUpStandalone() :
                                     this.formDirective.addControl(this),
              this._registered = !0
        }
        _setUpdateStrategy() {
          this.options && this.options.updateOn != null &&
              (this.control._updateOn = this.options.updateOn)
        }
        _isStandalone() {
          return !this._parent || !!(this.options && this.options.standalone)
        }
        _setUpStandalone() {
          Dl(this.control, this, this.callSetDisabledState),
              this.control.updateValueAndValidity({emitEvent: !1})
        }
        _checkForErrors() {
          this._checkName()
        }
        _checkName() {
          this.options && this.options.name && (this.name = this.options.name),
              !this._isStandalone() && this.name
        }
        _updateValue(e) {
          GD.then(() => {
            this.control.setValue(e, {emitViewToModelChange: !1}),
            this._changeDetectorRef?.markForCheck()
          })
        }
        _updateDisabled(e) {
          let i = e.isDisabled.currentValue, r = i !== 0 && q(i);
          GD.then(() => {
            r && !this.control.disabled ?
                this.control.disable() :
                !r && this.control.disabled && this.control.enable(),
            this._changeDetectorRef?.markForCheck()
          })
        }
        _getPath(e) {
          return this._parent ? AF(e, this._parent) : [e]
        }
        static \u0275fac = function(i) {
          return new (i || n)(
              z(To, 9), z(Mr, 10), z(im, 10), z(Ro, 10), z(Ae, 8), z(Vs, 8))
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['', 'ngModel', '', 3, 'formControlName', '', 3, 'formControl', '']
          ],
          inputs: {
            name: 'name',
            isDisabled: [0, 'disabled', 'isDisabled'],
            model: [0, 'ngModel', 'model'],
            options: [0, 'ngModelOptions', 'options']
          },
          outputs: {update: 'ngModelChange'},
          exportAs: ['ngModel'],
          standalone: !1,
          features: [ye([HF]), te, Pe]
        })
      } return n
    })();
var mE = new w(''), UF = {provide: Bn, useExisting: Zt(() => v_)},
    v_ = (() => {
      class n extends Bn {
        _ngModelWarningConfig;
        callSetDisabledState;
        viewModel;
        form;
        set isDisabled(e) {}
        model;
        update = new H;
        static _ngModelWarningSentOnce = !1;
        _ngModelWarningSent = !1;
        constructor(e, i, r, o, s) {
          super(), this._ngModelWarningConfig = o,
                   this.callSetDisabledState = s, this._setValidators(e),
                   this._setAsyncValidators(i), this.valueAccessor = uE(this, r)
        }
        ngOnChanges(e) {
          if (this._isControlChanged(e)) {
            let i = e.form.previousValue;
            i && em(i, this, !1),
                Dl(this.form, this, this.callSetDisabledState),
                this.form.updateValueAndValidity({emitEvent: !1})
          }
          cE(e, this.viewModel) &&
              (this.form.setValue(this.model), this.viewModel = this.model)
        }
        ngOnDestroy() {
          this.form && em(this.form, this, !1)
        }
        get path() {
          return []
        }
        get control() {
          return this.form
        }
        viewToModelUpdate(e) {
          this.viewModel = e, this.update.emit(e)
        }
        _isControlChanged(e) {
          return e.hasOwnProperty('form')
        }
        static \u0275fac = function(i) {
          return new (i || n)(
              z(Mr, 10), z(im, 10), z(Ro, 10), z(mE, 8), z(Vs, 8))
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'formControl', '']],
          inputs: {
            form: [0, 'formControl', 'form'],
            isDisabled: [0, 'disabled', 'isDisabled'],
            model: [0, 'ngModel', 'model']
          },
          outputs: {update: 'ngModelChange'},
          exportAs: ['ngForm'],
          standalone: !1,
          features: [ye([UF]), te, Pe]
        })
      } return n
    })(),
    $F = {provide: To, useExisting: Zt(() => kl)},
    kl = (() => {
      class n extends To {
        callSetDisabledState;
        get submitted() {
          return tn(this._submittedReactive)
        }
        set submitted(e) {
          this._submittedReactive.set(e)
        }
        _submitted = mi(() => this._submittedReactive());
        _submittedReactive = Jt(!1);
        _oldForm;
        _onCollectionChange = () => this._updateDomValue();
        directives = [];
        form = null;
        ngSubmit = new H;
        constructor(e, i, r) {
          super(), this.callSetDisabledState = r, this._setValidators(e),
                   this._setAsyncValidators(i)
        }
        ngOnChanges(e) {
          e.hasOwnProperty('form') &&
              (this._updateValidators(), this._updateDomValue(),
               this._updateRegistrations(), this._oldForm = this.form)
        }
        ngOnDestroy() {
          this.form &&
              (nm(this.form, this),
               this.form._onCollectionChange === this._onCollectionChange &&
                   this.form._registerOnCollectionChange(() => {}))
        }
        get formDirective() {
          return this
        }
        get control() {
          return this.form
        }
        get path() {
          return []
        }
        addControl(e) {
          let i = this.form.get(e.path);
          return Dl(i, e, this.callSetDisabledState),
                 i.updateValueAndValidity({emitEvent: !1}),
                 this.directives.push(e), i
        }
        getControl(e) {
          return this.form.get(e.path)
        }
        removeControl(e) {
          em(e.control || null, e, !1), jF(this.directives, e)
        }
        addFormGroup(e) {
          this._setUpFormContainer(e)
        }
        removeFormGroup(e) {
          this._cleanUpFormContainer(e)
        }
        getFormGroup(e) {
          return this.form.get(e.path)
        }
        addFormArray(e) {
          this._setUpFormContainer(e)
        }
        removeFormArray(e) {
          this._cleanUpFormContainer(e)
        }
        getFormArray(e) {
          return this.form.get(e.path)
        }
        updateModel(e, i) {
          this.form.get(e.path).setValue(i)
        }
        onSubmit(e) {
          return this._submittedReactive.set(!0),
                 dE(this.form, this.directives), this.ngSubmit.emit(e),
                 this.form._events.next(new m_(this.control)),
                 e?.target?.method === 'dialog'
        }
        onReset() {
          this.resetForm()
        }
        resetForm(e = void 0) {
          this.form.reset(e), this._submittedReactive.set(!1),
              this.form._events.next(new h_(this.form))
        }
        _updateDomValue() {
          this.directives.forEach(e => {
            let i = e.control, r = this.form.get(e.path);
            i !== r &&
                (em(i || null, e),
                 zF(r) && (Dl(r, e, this.callSetDisabledState), e.control = r))
          }),
              this.form._updateTreeValidity({emitEvent: !1})
        }
        _setUpFormContainer(e) {
          let i = this.form.get(e.path);
          lE(i, e), i.updateValueAndValidity({emitEvent: !1})
        }
        _cleanUpFormContainer(e) {
          if (this.form) {
            let i = this.form.get(e.path);
            i && LF(i, e) && i.updateValueAndValidity({emitEvent: !1})
          }
        }
        _updateRegistrations() {
          this.form._registerOnCollectionChange(this._onCollectionChange),
              this._oldForm &&
              this._oldForm._registerOnCollectionChange(() => {})
        }
        _updateValidators() {
          b_(this.form, this), this._oldForm && nm(this._oldForm, this)
        }
        static \u0275fac = function(i) {
          return new (i || n)(z(Mr, 10), z(im, 10), z(Vs, 8))
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'formGroup', '']],
          hostBindings: function(i, r) {
            i&1 && M('submit', function(s) {
              return r.onSubmit(s)
            })('reset', function() {
              return r.onReset()
            })
          },
          inputs: {form: [0, 'formGroup', 'form']},
          outputs: {ngSubmit: 'ngSubmit'},
          exportAs: ['ngForm'],
          standalone: !1,
          features: [ye([$F]), te, Pe]
        })
      } return n
    })();
var hE = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})();
var am = (() => {
  class n {
    static withConfig(e) {
      return {
        ngModule: n,
            providers: [{provide: Vs, useValue: e.callSetDisabledState ?? om}]
      }
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [hE]})
  } return n
})(),
    fE = (() => {
      class n {
        static withConfig(e) {
          return {
            ngModule: n, providers: [
              {
                provide: mE,
                useValue: e.warnOnNgModelWithFormControl ?? 'always'
              },
              {provide: Vs, useValue: e.callSetDisabledState ?? om}
            ]
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [hE]})
      } return n
    })();
var Ee = 'primary', jl = Symbol('RouteTitle'), D_ = class {
  params;
  constructor(t) {
    this.params = t || {}
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.params, t)
  }
  get(t) {
    if (this.has(t)) {
      let e = this.params[t];
      return Array.isArray(e) ? e[0] : e
    }
    return null
  }
  getAll(t) {
    if (this.has(t)) {
      let e = this.params[t];
      return Array.isArray(e) ? e : [e]
    }
    return []
  }
  get keys() {
    return Object.keys(this.params)
  }
};
function $s(n) {
  return new D_(n)
}
function WF(n, t, e) {
  let i = e.path.split('/');
  if (i.length > n.length ||
      e.pathMatch === 'full' && (t.hasChildren() || i.length < n.length))
    return null;
  let r = {};
  for (let o = 0; o < i.length; o++) {
    let s = i[o], a = n[o];
    if (s[0] === ':')
      r[s.substring(1)] = a;
    else if (s !== a.path)
      return null
  }
  return {
    consumed: n.slice(0, i.length), posParams: r
  }
}
function qF(n, t) {
  if (n.length !== t.length) return !1;
  for (let e = 0; e < n.length; ++e)
    if (!gi(n[e], t[e])) return !1;
  return !0
}
function gi(n, t) {
  let e = n ? E_(n) : void 0, i = t ? E_(t) : void 0;
  if (!e || !i || e.length != i.length) return !1;
  let r;
  for (let o = 0; o < e.length; o++)
    if (r = e[o], !DE(n[r], t[r])) return !1;
  return !0
}
function E_(n) {
  return [...Object.keys(n), ...Object.getOwnPropertySymbols(n)]
}
function DE(n, t) {
  if (Array.isArray(n) && Array.isArray(t)) {
    if (n.length !== t.length) return !1;
    let e = [...n].sort(), i = [...t].sort();
    return e.every((r, o) => i[o] === r)
  } else
    return n === t
}
function EE(n) {
  return n.length > 0 ? n[n.length - 1] : null
}
function Nr(n) {
  return lr(n) ? n : wr(n) ? Ue(Promise.resolve(n)) : G(n)
}
var GF = {exact: SE, subset: IE},
    kE = {exact: QF, subset: YF, ignored: () => !0};
function pE(n, t, e) {
  return GF[e.paths](n.root, t.root, e.matrixParams) &&
      kE[e.queryParams](n.queryParams, t.queryParams) &&
      !(e.fragment === 'exact' && n.fragment !== t.fragment)
}
function QF(n, t) {
  return gi(n, t)
}
function SE(n, t, e) {
  if (!Oo(n.segments, t.segments) || !um(n.segments, t.segments, e) ||
      n.numberOfChildren !== t.numberOfChildren)
    return !1;
  for (let i in t.children)
    if (!n.children[i] || !SE(n.children[i], t.children[i], e)) return !1;
  return !0
}
function YF(n, t) {
  return Object.keys(t).length <= Object.keys(n).length &&
      Object.keys(t).every(e => DE(n[e], t[e]))
}
function IE(n, t, e) {
  return ME(n, t, t.segments, e)
}
function ME(n, t, e, i) {
  if (n.segments.length > e.length) {
    let r = n.segments.slice(0, e.length);
    return !(!Oo(r, e) || t.hasChildren() || !um(r, e, i))
  } else if (n.segments.length === e.length) {
    if (!Oo(n.segments, e) || !um(n.segments, e, i)) return !1;
    for (let r in t.children)
      if (!n.children[r] || !IE(n.children[r], t.children[r], i)) return !1;
    return !0
  } else {
    let r = e.slice(0, n.segments.length), o = e.slice(n.segments.length);
    return !Oo(n.segments, r) || !um(n.segments, r, i) || !n.children[Ee] ?
        !1 :
        ME(n.children[Ee], t, o, i)
  }
}
function um(n, t, e) {
  return t.every((i, r) => kE[e](n[r].parameters, i.parameters))
}
var Yi = class {
  root;
  queryParams;
  fragment;
  _queryParamMap;
  constructor(t = new je([], {}), e = {}, i = null) {
    this.root = t, this.queryParams = e, this.fragment = i
  }
  get queryParamMap() {
    return this._queryParamMap ??= $s(this.queryParams), this._queryParamMap
  }
  toString() {
    return XF.serialize(this)
  }
}
, je = class {
  segments;
  children;
  parent = null;
  constructor(t, e) {
    this.segments = t, this.children = e,
    Object.values(e).forEach(i => i.parent = this)
  }
  hasChildren() {
    return this.numberOfChildren > 0
  }
  get numberOfChildren() {
    return Object.keys(this.children).length
  }
  toString() {
    return mm(this)
  }
}
, Ao = class {
  path;
  parameters;
  _parameterMap;
  constructor(t, e) {
    this.path = t, this.parameters = e
  }
  get parameterMap() {
    return this._parameterMap ??= $s(this.parameters), this._parameterMap
  }
  toString() {
    return RE(this)
  }
};
function ZF(n, t) {
  return Oo(n, t) && n.every((e, i) => gi(e.parameters, t[i].parameters))
}
function Oo(n, t) {
  return n.length !== t.length ? !1 : n.every((e, i) => e.path === t[i].path)
}
function KF(n, t) {
  let e = [];
  return Object.entries(n.children)
             .forEach(([i, r]) => {i === Ee && (e = e.concat(t(r, i)))}),
         Object.entries(n.children)
             .forEach(([i, r]) => {i !== Ee && (e = e.concat(t(r, i)))}),
         e
}
var Bl = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: () => new Ws, providedIn: 'root'})
  } return n
})(),
    Ws = class {
  parse(t) {
    let e = new S_(t);
    return new Yi(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment())
  }
  serialize(t) {
    let e = `/${Sl(t.root, !0)}`, i = tL(t.queryParams),
        r = typeof t.fragment == 'string' ? `#${JF(t.fragment)}` : '';
    return `${e}${i}${r}`
  }
}
, XF = new Ws;
function mm(n) {
  return n.segments.map(t => RE(t)).join('/')
}
function Sl(n, t) {
  if (!n.hasChildren()) return mm(n);
  if (t) {
    let e = n.children[Ee] ? Sl(n.children[Ee], !1) : '', i = [];
    return Object.entries(n.children)
               .forEach(([r, o]) => {r !== Ee && i.push(`${r}:${Sl(o, !1)}`)}),
           i.length > 0 ? `${e}(${i.join('//')})` : e
  } else {
    let e = KF(
        n,
        (i, r) => r === Ee ? [Sl(n.children[Ee], !1)] : [`${r}:${Sl(i, !1)}`]);
    return Object.keys(n.children).length === 1 && n.children[Ee] != null ?
        `${mm(n)}/${e[0]}` :
        `${mm(n)}/(${e.join('//')})`
  }
}
function TE(n) {
  return encodeURIComponent(n)
      .replace(/%40/g, '@')
      .replace(/%3A/gi, ':')
      .replace(/%24/g, '$')
      .replace(/%2C/gi, ',')
}
function cm(n) {
  return TE(n).replace(/%3B/gi, ';')
}
function JF(n) {
  return encodeURI(n)
}
function k_(n) {
  return TE(n).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&')
}
function hm(n) {
  return decodeURIComponent(n)
}
function gE(n) {
  return hm(n.replace(/\+/g, '%20'))
}
function RE(n) {
  return `${k_(n.path)}${eL(n.parameters)}`
}
function eL(n) {
  return Object.entries(n).map(([t, e]) => `;${k_(t)}=${k_(e)}`).join('')
}
function tL(n) {
  let t = Object.entries(n)
              .map(
                  ([e, i]) => Array.isArray(i) ?
                      i.map(r => `${cm(e)}=${cm(r)}`).join('&') :
                      `${cm(e)}=${cm(i)}`)
              .filter(e => e);
  return t.length ? `?${t.join('&')}` : ''
}
var nL = /^[^\/()?;#]+/;
function y_(n) {
  let t = n.match(nL);
  return t ? t[0] : ''
}
var iL = /^[^\/()?;=#]+/;
function rL(n) {
  let t = n.match(iL);
  return t ? t[0] : ''
}
var oL = /^[^=?&#]+/;
function sL(n) {
  let t = n.match(oL);
  return t ? t[0] : ''
}
var aL = /^[^&#]+/;
function lL(n) {
  let t = n.match(aL);
  return t ? t[0] : ''
}
var S_ = class {
  url;
  remaining;
  constructor(t) {
    this.url = t, this.remaining = t
  }
  parseRootSegment() {
    return this.consumeOptional('/'),
           this.remaining === '' || this.peekStartsWith('?') ||
                   this.peekStartsWith('#') ?
               new je([], {}) :
               new je([], this.parseChildren())
  }
  parseQueryParams() {
    let t = {};
    if (this.consumeOptional('?')) do
        this.parseQueryParam(t);
      while (this.consumeOptional('&'));
    return t
  }
  parseFragment() {
    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null
  }
  parseChildren() {
    if (this.remaining === '') return {};
    this.consumeOptional('/');
    let t = [];
    for (this.peekStartsWith('(') || t.push(this.parseSegment());
         this.peekStartsWith('/') && !this.peekStartsWith('//') &&
         !this.peekStartsWith('/(');)
      this.capture('/'), t.push(this.parseSegment());
    let e = {};
    this.peekStartsWith('/(') && (this.capture('/'), e = this.parseParens(!0));
    let i = {};
    return this.peekStartsWith('(') && (i = this.parseParens(!1)),
           (t.length > 0 || Object.keys(e).length > 0) &&
               (i[Ee] = new je(t, e)),
           i
  }
  parseSegment() {
    let t = y_(this.remaining);
    if (t === '' && this.peekStartsWith(';')) throw new S(4009, !1);
    return this.capture(t), new Ao(hm(t), this.parseMatrixParams())
  }
  parseMatrixParams() {
    let t = {};
    for (; this.consumeOptional(';');) this.parseParam(t);
    return t
  }
  parseParam(t) {
    let e = rL(this.remaining);
    if (!e) return;
    this.capture(e);
    let i = '';
    if (this.consumeOptional('=')) {
      let r = y_(this.remaining);
      r && (i = r, this.capture(i))
    }
    t[hm(e)] = hm(i)
  }
  parseQueryParam(t) {
    let e = sL(this.remaining);
    if (!e) return;
    this.capture(e);
    let i = '';
    if (this.consumeOptional('=')) {
      let s = lL(this.remaining);
      s && (i = s, this.capture(i))
    }
    let r = gE(e), o = gE(i);
    if (t.hasOwnProperty(r)) {
      let s = t[r];
      Array.isArray(s) || (s = [s], t[r] = s), s.push(o)
    } else
      t[r] = o
  }
  parseParens(t) {
    let e = {};
    for (this.capture('(');
         !this.consumeOptional(')') && this.remaining.length > 0;) {
      let i = y_(this.remaining), r = this.remaining[i.length];
      if (r !== '/' && r !== ')' && r !== ';') throw new S(4010, !1);
      let o;
      i.indexOf(':') > -1 ?
          (o = i.slice(0, i.indexOf(':')), this.capture(o), this.capture(':')) :
          t && (o = Ee);
      let s = this.parseChildren();
      e[o] = Object.keys(s).length === 1 ? s[Ee] : new je([], s),
      this.consumeOptional('//')
    }
    return e
  }
  peekStartsWith(t) {
    return this.remaining.startsWith(t)
  }
  consumeOptional(t) {
    return this.peekStartsWith(t) ?
        (this.remaining = this.remaining.substring(t.length), !0) :
        !1
  }
  capture(t) {
    if (!this.consumeOptional(t)) throw new S(4011, !1)
  }
};
function AE(n) {
  return n.segments.length > 0 ? new je([], {[Ee]: n}) : n
}
function OE(n) {
  let t = {};
  for (let [i, r] of Object.entries(n.children)) {
    let o = OE(r);
    if (i === Ee && o.segments.length === 0 && o.hasChildren())
      for (let [s, a] of Object.entries(o.children)) t[s] = a;
    else
      (o.segments.length > 0 || o.hasChildren()) && (t[i] = o)
  }
  let e = new je(n.segments, t);
  return cL(e)
}
function cL(n) {
  if (n.numberOfChildren === 1 && n.children[Ee]) {
    let t = n.children[Ee];
    return new je(n.segments.concat(t.segments), t.children)
  }
  return n
}
function Rl(n) {
  return n instanceof Yi
}
function dL(n, t, e = null, i = null) {
  let r = NE(n);
  return PE(r, t, e, i)
}
function NE(n) {
  let t;
  function e(o) {
    let s = {};
    for (let l of o.children) {
      let c = e(l);
      s[l.outlet] = c
    }
    let a = new je(o.url, s);
    return o === n && (t = a), a
  }
  let i = e(n.root), r = AE(i);
  return t ?? r
}
function PE(n, t, e, i) {
  let r = n;
  for (; r.parent;) r = r.parent;
  if (t.length === 0) return w_(r, r, r, e, i);
  let o = uL(t);
  if (o.toRoot()) return w_(r, r, new je([], {}), e, i);
  let s = mL(o, r, n),
      a = s.processChildren ? Ml(s.segmentGroup, s.index, o.commands) :
                              LE(s.segmentGroup, s.index, o.commands);
  return w_(r, s.segmentGroup, a, e, i)
}
function pm(n) {
  return typeof n == 'object' && n != null && !n.outlets && !n.segmentPath
}
function Al(n) {
  return typeof n == 'object' && n != null && n.outlets
}
function w_(n, t, e, i, r) {
  let o = {};
  i &&
      Object.entries(i).forEach(
          ([l, c]) => {o[l] = Array.isArray(c) ? c.map(d => `${d}`) : `${c}`});
  let s;
  n === t ? s = e : s = FE(n, t, e);
  let a = AE(OE(s));
  return new Yi(a, o, r)
}
function FE(n, t, e) {
  let i = {};
  return Object.entries(n.children)
             .forEach(([r, o]) => {o === t ? i[r] = e : i[r] = FE(o, t, e)}),
         new je(n.segments, i)
}
var gm = class {
  isAbsolute;
  numberOfDoubleDots;
  commands;
  constructor(t, e, i) {
    if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i,
        t && i.length > 0 && pm(i[0]))
      throw new S(4003, !1);
    let r = i.find(Al);
    if (r && r !== EE(i)) throw new S(4004, !1)
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 &&
        this.commands[0] == '/'
  }
};
function uL(n) {
  if (typeof n[0] == 'string' && n.length === 1 && n[0] === '/')
    return new gm(!0, 0, n);
  let t = 0, e = !1, i = n.reduce((r, o, s) => {
    if (typeof o == 'object' && o != null) {
      if (o.outlets) {
        let a = {};
        return Object.entries(o.outlets).forEach(
                   ([l, c]) => {
                       a[l] = typeof c == 'string' ? c.split('/') : c}),
               [...r, {outlets: a}]
      }
      if (o.segmentPath) return [...r, o.segmentPath]
    }
    return typeof o != 'string' ? [...r, o] :
        s === 0                 ? (o.split('/').forEach(
                       (a, l) => {
                           l == 0 && a === '.' ||
                           (l == 0 && a === '' ? e = !0 :
                                                a === '..'     ? t++ :
                                                                 a != '' && r.push(a))}),
                   r) :
                                  [...r, o]
  }, []);
  return new gm(e, t, i)
}
var zs = class {
  segmentGroup;
  processChildren;
  index;
  constructor(t, e, i) {
    this.segmentGroup = t, this.processChildren = e, this.index = i
  }
};
function mL(n, t, e) {
  if (n.isAbsolute) return new zs(t, !0, 0);
  if (!e) return new zs(t, !1, NaN);
  if (e.parent === null) return new zs(e, !0, 0);
  let i = pm(n.commands[0]) ? 0 : 1, r = e.segments.length - 1 + i;
  return hL(e, r, n.numberOfDoubleDots)
}
function hL(n, t, e) {
  let i = n, r = t, o = e;
  for (; o > r;) {
    if (o -= r, i = i.parent, !i) throw new S(4005, !1);
    r = i.segments.length
  }
  return new zs(i, !1, r - o)
}
function fL(n) {
  return Al(n[0]) ? n[0].outlets : {[Ee]: n}
}
function LE(n, t, e) {
  if (n ??= new je([], {}), n.segments.length === 0 && n.hasChildren())
    return Ml(n, t, e);
  let i = pL(n, t, e), r = e.slice(i.commandIndex);
  if (i.match && i.pathIndex < n.segments.length) {
    let o = new je(n.segments.slice(0, i.pathIndex), {});
    return o.children[Ee] = new je(n.segments.slice(i.pathIndex), n.children),
           Ml(o, 0, r)
  } else
    return i.match && r.length === 0 ? new je(n.segments, {}) :
        i.match && !n.hasChildren()  ? I_(n, t, e) :
        i.match                      ? Ml(n, 0, r) :
                                       I_(n, t, e)
}
function Ml(n, t, e) {
  if (e.length === 0) return new je(n.segments, {});
  {
    let i = fL(e), r = {};
    if (Object.keys(i).some(o => o !== Ee) && n.children[Ee] &&
        n.numberOfChildren === 1 && n.children[Ee].segments.length === 0) {
      let o = Ml(n.children[Ee], t, e);
      return new je(n.segments, o.children)
    }
    return Object.entries(i).forEach(([o, s]) => {
      typeof s == 'string' && (s = [s]),
      s !== null && (r[o] = LE(n.children[o], t, s))
    }),
           Object.entries(n.children)
               .forEach(([o, s]) => {i[o] === void 0 && (r[o] = s)}),
           new je(n.segments, r)
  }
}
function pL(n, t, e) {
  let i = 0, r = t, o = {match: !1, pathIndex: 0, commandIndex: 0};
  for (; r < n.segments.length;) {
    if (i >= e.length) return o;
    let s = n.segments[r], a = e[i];
    if (Al(a)) break;
    let l = `${a}`, c = i < e.length - 1 ? e[i + 1] : null;
    if (r > 0 && l === void 0) break;
    if (l && c && typeof c == 'object' && c.outlets === void 0) {
      if (!bE(l, c, s)) return o;
      i += 2
    } else {
      if (!bE(l, {}, s)) return o;
      i++
    }
    r++
  }
  return {
    match: !0, pathIndex: r, commandIndex: i
  }
}
function I_(n, t, e) {
  let i = n.segments.slice(0, t), r = 0;
  for (; r < e.length;) {
    let o = e[r];
    if (Al(o)) {
      let l = gL(o.outlets);
      return new je(i, l)
    }
    if (r === 0 && pm(e[0])) {
      let l = n.segments[t];
      i.push(new Ao(l.path, _E(e[0]))), r++;
      continue
    }
    let s = Al(o) ? o.outlets[Ee] : `${o}`,
        a = r < e.length - 1 ? e[r + 1] : null;
    s && a && pm(a) ? (i.push(new Ao(s, _E(a))), r += 2) :
                      (i.push(new Ao(s, {})), r++)
  }
  return new je(i, {})
}
function gL(n) {
  let t = {};
  return Object.entries(n).forEach(([e, i]) => {
    typeof i == 'string' && (i = [i]),
    i !== null && (t[e] = I_(new je([], {}), 0, i))
  }),
         t
}
function _E(n) {
  let t = {};
  return Object.entries(n).forEach(([e, i]) => t[e] = `${i}`), t
}
function bE(n, t, e) {
  return n == e.path && gi(t, e.parameters)
}
var fm = 'imperative', Ct = function(n) {
  return n[n.NavigationStart = 0] = 'NavigationStart',
                               n[n.NavigationEnd = 1] = 'NavigationEnd',
                               n[n.NavigationCancel = 2] = 'NavigationCancel',
                               n[n.NavigationError = 3] = 'NavigationError',
                               n[n.RoutesRecognized = 4] = 'RoutesRecognized',
                               n[n.ResolveStart = 5] = 'ResolveStart',
                               n[n.ResolveEnd = 6] = 'ResolveEnd',
                               n[n.GuardsCheckStart = 7] = 'GuardsCheckStart',
                               n[n.GuardsCheckEnd = 8] = 'GuardsCheckEnd',
                               n[n.RouteConfigLoadStart = 9] =
                                   'RouteConfigLoadStart',
                               n[n.RouteConfigLoadEnd = 10] =
                                   'RouteConfigLoadEnd',
                               n[n.ChildActivationStart = 11] =
                                   'ChildActivationStart',
                               n[n.ChildActivationEnd = 12] =
                                   'ChildActivationEnd',
                               n[n.ActivationStart = 13] = 'ActivationStart',
                               n[n.ActivationEnd = 14] = 'ActivationEnd',
                               n[n.Scroll = 15] = 'Scroll',
                               n[n.NavigationSkipped = 16] =
                                   'NavigationSkipped',
                               n
}(Ct || {}), wn = class {
  id;
  url;
  constructor(t, e) {
    this.id = t, this.url = e
  }
}
, qs = class extends wn {
  type = Ct.NavigationStart;
  navigationTrigger;
  restoredState;
  constructor(t, e, i = 'imperative', r = null) {
    super(t, e), this.navigationTrigger = i, this.restoredState = r
  }
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`
  }
}
, Hn = class extends wn {
  urlAfterRedirects;
  type = Ct.NavigationEnd;
  constructor(t, e, i) {
    super(t, e), this.urlAfterRedirects = i
  }
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
  }
}
, dn = function(n) {
  return n[n.Redirect = 0] = 'Redirect',
                        n[n.SupersededByNewNavigation = 1] =
                            'SupersededByNewNavigation',
                        n[n.NoDataFromResolver = 2] = 'NoDataFromResolver',
                        n[n.GuardRejected = 3] = 'GuardRejected', n
}(dn || {}), _m = function(n) {
  return n[n.IgnoredSameUrlNavigation = 0] = 'IgnoredSameUrlNavigation',
                                        n[n.IgnoredByUrlHandlingStrategy = 1] =
                                            'IgnoredByUrlHandlingStrategy',
                                        n
}(_m || {}), Qi = class extends wn {
  reason;
  code;
  type = Ct.NavigationCancel;
  constructor(t, e, i, r) {
    super(t, e), this.reason = i, this.code = r
  }
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
  }
}
, Rr = class extends wn {
  reason;
  code;
  type = Ct.NavigationSkipped;
  constructor(t, e, i, r) {
    super(t, e), this.reason = i, this.code = r
  }
}
, Ol = class extends wn {
  error;
  target;
  type = Ct.NavigationError;
  constructor(t, e, i, r) {
    super(t, e), this.error = i, this.target = r
  }
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${
        this.error})`
  }
}
, bm = class extends wn {
  urlAfterRedirects;
  state;
  type = Ct.RoutesRecognized;
  constructor(t, e, i, r) {
    super(t, e), this.urlAfterRedirects = i, this.state = r
  }
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${
        this.state})`
  }
}
, M_ = class extends wn {
  urlAfterRedirects;
  state;
  type = Ct.GuardsCheckStart;
  constructor(t, e, i, r) {
    super(t, e), this.urlAfterRedirects = i, this.state = r
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${
        this.state})`
  }
}
, T_ = class extends wn {
  urlAfterRedirects;
  state;
  shouldActivate;
  type = Ct.GuardsCheckEnd;
  constructor(t, e, i, r, o) {
    super(t, e), this.urlAfterRedirects = i, this.state = r,
                 this.shouldActivate = o
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${
        this.state}, shouldActivate: ${this.shouldActivate})`
  }
}
, R_ = class extends wn {
  urlAfterRedirects;
  state;
  type = Ct.ResolveStart;
  constructor(t, e, i, r) {
    super(t, e), this.urlAfterRedirects = i, this.state = r
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${
        this.state})`
  }
}
, A_ = class extends wn {
  urlAfterRedirects;
  state;
  type = Ct.ResolveEnd;
  constructor(t, e, i, r) {
    super(t, e), this.urlAfterRedirects = i, this.state = r
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${
        this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${
        this.state})`
  }
}
, O_ = class {
  route;
  type = Ct.RouteConfigLoadStart;
  constructor(t) {
    this.route = t
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`
  }
}
, N_ = class {
  route;
  type = Ct.RouteConfigLoadEnd;
  constructor(t) {
    this.route = t
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`
  }
}
, P_ = class {
  snapshot;
  type = Ct.ChildActivationStart;
  constructor(t) {
    this.snapshot = t
  }
  toString() {
    return `ChildActivationStart(path: '${
        this.snapshot.routeConfig && this.snapshot.routeConfig.path || ''}')`
  }
}
, F_ = class {
  snapshot;
  type = Ct.ChildActivationEnd;
  constructor(t) {
    this.snapshot = t
  }
  toString() {
    return `ChildActivationEnd(path: '${
        this.snapshot.routeConfig && this.snapshot.routeConfig.path || ''}')`
  }
}
, L_ = class {
  snapshot;
  type = Ct.ActivationStart;
  constructor(t) {
    this.snapshot = t
  }
  toString() {
    return `ActivationStart(path: '${
        this.snapshot.routeConfig && this.snapshot.routeConfig.path || ''}')`
  }
}
, V_ = class {
  snapshot;
  type = Ct.ActivationEnd;
  constructor(t) {
    this.snapshot = t
  }
  toString() {
    return `ActivationEnd(path: '${
        this.snapshot.routeConfig && this.snapshot.routeConfig.path || ''}')`
  }
}
, vm = class {
  routerEvent;
  position;
  anchor;
  type = Ct.Scroll;
  constructor(t, e, i) {
    this.routerEvent = t, this.position = e, this.anchor = i
  }
  toString() {
    let t = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${t}')`
  }
}
, Nl = class {}
, Gs = class {
  url;
  navigationBehaviorOptions;
  constructor(t, e) {
    this.url = t, this.navigationBehaviorOptions = e
  }
};
function _L(n, t) {
  return n.providers && !n._injector &&
             (n._injector = Cu(n.providers, t, `Route: ${n.path}`)),
         n._injector ?? t
}
function zn(n) {
  return n.outlet || Ee
}
function bL(n, t) {
  let e = n.filter(i => zn(i) === t);
  return e.push(...n.filter(i => zn(i) !== t)), e
}
function zl(n) {
  if (!n) return null;
  if (n.routeConfig?._injector) return n.routeConfig._injector;
  for (let t = n.parent; t; t = t.parent) {
    let e = t.routeConfig;
    if (e?._loadedInjector) return e._loadedInjector;
    if (e?._injector) return e._injector
  }
  return null
}
var j_ = class {
  rootInjector;
  outlet = null;
  route = null;
  children;
  attachRef = null;
  get injector() {
    return zl(this.route?.snapshot) ?? this.rootInjector
  }
  constructor(t) {
    this.rootInjector = t, this.children = new Hl(this.rootInjector)
  }
}
, Hl = (() => {
    class n {
      rootInjector;
      contexts = new Map;
      constructor(e) {
        this.rootInjector = e
      }
      onChildOutletCreated(e, i) {
        let r = this.getOrCreateContext(e);
        r.outlet = i, this.contexts.set(e, r)
      }
      onChildOutletDestroyed(e) {
        let i = this.getContext(e);
        i && (i.outlet = null, i.attachRef = null)
      }
      onOutletDeactivated() {
        let e = this.contexts;
        return this.contexts = new Map, e
      }
      onOutletReAttached(e) {
        this.contexts = e
      }
      getOrCreateContext(e) {
        let i = this.getContext(e);
        return i || (i = new j_(this.rootInjector), this.contexts.set(e, i)), i
      }
      getContext(e) {
        return this.contexts.get(e) || null
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(_t))
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  ym = class {
  _root;
  constructor(t) {
    this._root = t
  }
  get root() {
    return this._root.value
  }
  parent(t) {
    let e = this.pathFromRoot(t);
    return e.length > 1 ? e[e.length - 2] : null
  }
  children(t) {
    let e = B_(t, this._root);
    return e ? e.children.map(i => i.value) : []
  }
  firstChild(t) {
    let e = B_(t, this._root);
    return e && e.children.length > 0 ? e.children[0].value : null
  }
  siblings(t) {
    let e = z_(t, this._root);
    return e.length < 2 ?
        [] :
        e[e.length - 2].children.map(r => r.value).filter(r => r !== t)
  }
  pathFromRoot(t) {
    return z_(t, this._root).map(e => e.value)
  }
};
function B_(n, t) {
  if (n === t.value) return t;
  for (let e of t.children) {
    let i = B_(n, e);
    if (i) return i
  }
  return null
}
function z_(n, t) {
  if (n === t.value) return [t];
  for (let e of t.children) {
    let i = z_(n, e);
    if (i.length) return i.unshift(t), i
  }
  return []
}
var cn = class {
  value;
  children;
  constructor(t, e) {
    this.value = t, this.children = e
  }
  toString() {
    return `TreeNode(${this.value})`
  }
};
function Bs(n) {
  let t = {};
  return n && n.children.forEach(e => t[e.value.outlet] = e), t
}
var wm = class extends ym {
  snapshot;
  constructor(t, e) {
    super(t), this.snapshot = e, Z_(this, t)
  }
  toString() {
    return this.snapshot.toString()
  }
};
function VE(n) {
  let t = vL(n), e = new Le([new Ao('', {})]), i = new Le({}), r = new Le({}),
      o = new Le({}), s = new Le(''), a = new Ar(e, i, o, s, r, Ee, n, t.root);
  return a.snapshot = t.root, new wm(new cn(a, []), t)
}
function vL(n) {
  let t = {}, e = {}, i = {}, r = '',
      o = new Hs([], t, i, r, e, Ee, n, null, {});
  return new Cm('', new cn(o, []))
}
var Ar = class {
  urlSubject;
  paramsSubject;
  queryParamsSubject;
  fragmentSubject;
  dataSubject;
  outlet;
  component;
  snapshot;
  _futureSnapshot;
  _routerState;
  _paramMap;
  _queryParamMap;
  title;
  url;
  params;
  queryParams;
  fragment;
  data;
  constructor(t, e, i, r, o, s, a, l) {
    this.urlSubject = t, this.paramsSubject = e, this.queryParamsSubject = i,
    this.fragmentSubject = r, this.dataSubject = o, this.outlet = s,
    this.component = a, this._futureSnapshot = l,
    this.title = this.dataSubject?.pipe(Q(c => c[jl])) ?? G(void 0),
    this.url = t, this.params = e, this.queryParams = i, this.fragment = r,
    this.data = o
  }
  get routeConfig() {
    return this._futureSnapshot.routeConfig
  }
  get root() {
    return this._routerState.root
  }
  get parent() {
    return this._routerState.parent(this)
  }
  get firstChild() {
    return this._routerState.firstChild(this)
  }
  get children() {
    return this._routerState.children(this)
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this)
  }
  get paramMap() {
    return this._paramMap ??= this.params.pipe(Q(t => $s(t))), this._paramMap
  }
  get queryParamMap() {
    return this._queryParamMap ??= this.queryParams.pipe(Q(t => $s(t))),
           this._queryParamMap
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() :
                           `Future(${this._futureSnapshot})`
  }
};
function xm(n, t, e = 'emptyOnly') {
  let i, {routeConfig: r} = n;
  return t !== null &&
                 (e === 'always' || r?.path === '' ||
                  !t.component && !t.routeConfig?.loadComponent) ?
             i = {
               params: y(y({}, t.params), n.params),
               data: y(y({}, t.data), n.data),
               resolve: y(y(y(y({}, n.data), t.data), r?.data), n._resolvedData)
             } :
             i = {
               params: y({}, n.params),
               data: y({}, n.data),
               resolve: y(y({}, n.data), n._resolvedData ?? {})
             },
             r && BE(r) && (i.resolve[jl] = r.title), i
}
var Hs = class {
  url;
  params;
  queryParams;
  fragment;
  data;
  outlet;
  component;
  routeConfig;
  _resolve;
  _resolvedData;
  _routerState;
  _paramMap;
  _queryParamMap;
  get title() {
    return this.data?.[jl]
  }
  constructor(t, e, i, r, o, s, a, l, c) {
    this.url = t, this.params = e, this.queryParams = i, this.fragment = r,
    this.data = o, this.outlet = s, this.component = a, this.routeConfig = l,
    this._resolve = c
  }
  get root() {
    return this._routerState.root
  }
  get parent() {
    return this._routerState.parent(this)
  }
  get firstChild() {
    return this._routerState.firstChild(this)
  }
  get children() {
    return this._routerState.children(this)
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this)
  }
  get paramMap() {
    return this._paramMap ??= $s(this.params), this._paramMap
  }
  get queryParamMap() {
    return this._queryParamMap ??= $s(this.queryParams), this._queryParamMap
  }
  toString() {
    let t = this.url.map(i => i.toString()).join('/'),
        e = this.routeConfig ? this.routeConfig.path : '';
    return `Route(url:'${t}', path:'${e}')`
  }
}
, Cm = class extends ym {
  url;
  constructor(t, e) {
    super(e), this.url = t, Z_(this, e)
  }
  toString() {
    return jE(this._root)
  }
};
function Z_(n, t) {
  t.value._routerState = n, t.children.forEach(e => Z_(n, e))
}
function jE(n) {
  let t = n.children.length > 0 ? ` { ${n.children.map(jE).join(', ')} } ` : '';
  return `${n.value}${t}`
}
function x_(n) {
  if (n.snapshot) {
    let t = n.snapshot, e = n._futureSnapshot;
    n.snapshot = e,
    gi(t.queryParams, e.queryParams) ||
        n.queryParamsSubject.next(e.queryParams),
    t.fragment !== e.fragment && n.fragmentSubject.next(e.fragment),
    gi(t.params, e.params) || n.paramsSubject.next(e.params),
    qF(t.url, e.url) || n.urlSubject.next(e.url),
    gi(t.data, e.data) || n.dataSubject.next(e.data)
  } else
    n.snapshot = n._futureSnapshot, n.dataSubject.next(n._futureSnapshot.data)
}
function H_(n, t) {
  let e = gi(n.params, t.params) && ZF(n.url, t.url),
      i = !n.parent != !t.parent;
  return e && !i && (!n.parent || H_(n.parent, t.parent))
}
function BE(n) {
  return typeof n.title == 'string' || n.title === null
}
var yL = new w(''),
    wL = (() => {
      class n {
        activated = null;
        get activatedComponentRef() {
          return this.activated
        }
        _activatedRoute = null;
        name = Ee;
        activateEvents = new H;
        deactivateEvents = new H;
        attachEvents = new H;
        detachEvents = new H;
        routerOutletData = ox(void 0);
        parentContexts = u(Hl);
        location = u(Ge);
        changeDetector = u(Ae);
        inputBinder = u(Im, {optional: !0});
        supportsBindingToComponentInputs = !0;
        ngOnChanges(e) {
          if (e.name) {
            let {firstChange: i, previousValue: r} = e.name;
            if (i) return;
            this.isTrackedInParentContexts(r) &&
                (this.deactivate(),
                 this.parentContexts.onChildOutletDestroyed(r)),
                this.initializeOutletWithName()
          }
        }
        ngOnDestroy() {
          this.isTrackedInParentContexts(this.name) &&
              this.parentContexts.onChildOutletDestroyed(this.name),
              this.inputBinder?.unsubscribeFromRouteData(this)
        }
        isTrackedInParentContexts(e) {
          return this.parentContexts.getContext(e)?.outlet === this
        }
        ngOnInit() {
          this.initializeOutletWithName()
        }
        initializeOutletWithName() {
          if (this.parentContexts.onChildOutletCreated(this.name, this),
              this.activated)
            return;
          let e = this.parentContexts.getContext(this.name);
          e?.route &&
              (e.attachRef ? this.attach(e.attachRef, e.route) :
                             this.activateWith(e.route, e.injector))
        }
        get isActivated() {
          return !!this.activated
        }
        get component() {
          if (!this.activated) throw new S(4012, !1);
          return this.activated.instance
        }
        get activatedRoute() {
          if (!this.activated) throw new S(4012, !1);
          return this._activatedRoute
        }
        get activatedRouteData() {
          return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
        }
        detach() {
          if (!this.activated) throw new S(4012, !1);
          this.location.detach();
          let e = this.activated;
          return this.activated = null, this._activatedRoute = null,
                 this.detachEvents.emit(e.instance), e
        }
        attach(e, i) {
          this.activated = e, this._activatedRoute = i,
          this.location.insert(e.hostView),
          this.inputBinder?.bindActivatedRouteToOutletComponent(this),
          this.attachEvents.emit(e.instance)
        }
        deactivate() {
          if (this.activated) {
            let e = this.component;
            this.activated.destroy(), this.activated = null,
                                      this._activatedRoute = null,
                                      this.deactivateEvents.emit(e)
          }
        }
        activateWith(e, i) {
          if (this.isActivated) throw new S(4013, !1);
          this._activatedRoute = e;
          let r = this.location, s = e.snapshot.component,
              a = this.parentContexts.getOrCreateContext(this.name).children,
              l = new U_(e, a, r.injector, this.routerOutletData);
          this.activated = r.createComponent(
              s, {index: r.length, injector: l, environmentInjector: i}),
          this.changeDetector.markForCheck(),
          this.inputBinder?.bindActivatedRouteToOutletComponent(this),
          this.activateEvents.emit(this.activated.instance)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['router-outlet']],
          inputs: {name: 'name', routerOutletData: [1, 'routerOutletData']},
          outputs: {
            activateEvents: 'activate',
            deactivateEvents: 'deactivate',
            attachEvents: 'attach',
            detachEvents: 'detach'
          },
          exportAs: ['outlet'],
          features: [Pe]
        })
      } return n
    })(),
    U_ = class n {
  route;
  childContexts;
  parent;
  outletData;
  __ngOutletInjector(t) {
    return new n(this.route, this.childContexts, t, this.outletData)
  }
  constructor(t, e, i, r) {
    this.route = t, this.childContexts = e, this.parent = i, this.outletData = r
  }
  get(t, e) {
    return t === Ar ? this.route :
        t === Hl    ? this.childContexts :
        t === yL    ? this.outletData :
                      this.parent.get(t, e)
  }
}
, Im = new w(''),
  vE = (() => {
    class n {
      outletDataSubscriptions = new Map;
      bindActivatedRouteToOutletComponent(e) {
        this.unsubscribeFromRouteData(e), this.subscribeToRouteData(e)
      }
      unsubscribeFromRouteData(e) {
        this.outletDataSubscriptions.get(e)?.unsubscribe(),
            this.outletDataSubscriptions.delete(e)
      }
      subscribeToRouteData(e) {
        let {
          activatedRoute: i
        } = e,
       r = Mn([i.queryParams, i.params, i.data])
               .pipe(
                   $e(([o, s, a], l) =>
                          (a = y(y(y({}, o), s), a),
                           l === 0 ? G(a) : Promise.resolve(a))))
               .subscribe(o => {
                 if (!e.isActivated || !e.activatedComponentRef ||
                     e.activatedRoute !== i || i.component === null) {
                   this.unsubscribeFromRouteData(e);
                   return
                 }
                 let s = tD(i.component);
                 if (!s) {
                   this.unsubscribeFromRouteData(e);
                   return
                 }
                 for (let {templateName: a} of s.inputs)
                   e.activatedComponentRef.setInput(a, o[a])
               });
        this.outletDataSubscriptions.set(e, r)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })();
function xL(n, t, e) {
  let i = Pl(n, t._root, e ? e._root : void 0);
  return new wm(i, t)
}
function Pl(n, t, e) {
  if (e && n.shouldReuseRoute(t.value, e.value.snapshot)) {
    let i = e.value;
    i._futureSnapshot = t.value;
    let r = CL(n, t, e);
    return new cn(i, r)
  } else {
    if (n.shouldAttach(t.value)) {
      let o = n.retrieve(t.value);
      if (o !== null) {
        let s = o.route;
        return s.value._futureSnapshot = t.value,
               s.children = t.children.map(a => Pl(n, a)), s
      }
    }
    let i = DL(t.value), r = t.children.map(o => Pl(n, o));
    return new cn(i, r)
  }
}
function CL(n, t, e) {
  return t.children.map(i => {
    for (let r of e.children)
      if (n.shouldReuseRoute(i.value, r.value.snapshot)) return Pl(n, i, r);
    return Pl(n, i)
  })
}
function DL(n) {
  return new Ar(
      new Le(n.url), new Le(n.params), new Le(n.queryParams),
      new Le(n.fragment), new Le(n.data), n.outlet, n.component, n)
}
var Fl = class {
  redirectTo;
  navigationBehaviorOptions;
  constructor(t, e) {
    this.redirectTo = t, this.navigationBehaviorOptions = e
  }
}
, zE = 'ngNavigationCancelingError';
function Dm(n, t) {
  let {redirectTo: e, navigationBehaviorOptions: i} =
      Rl(t) ? {redirectTo: t, navigationBehaviorOptions: void 0} : t,
                                                 r = HE(!1, dn.Redirect);
  return r.url = e, r.navigationBehaviorOptions = i, r
}
function HE(n, t) {
  let e = new Error(`NavigationCancelingError: ${n || ''}`);
  return e[zE] = !0, e.cancellationCode = t, e
}
function EL(n) {
  return UE(n) && Rl(n.url)
}
function UE(n) {
  return !!n && n[zE]
}
var kL = (n, t, e, i) =>
        Q(r =>
              (new $_(t, r.targetRouterState, r.currentRouterState, e, i)
                   .activate(n),
               r)),
    $_ = class {
  routeReuseStrategy;
  futureState;
  currState;
  forwardEvent;
  inputBindingEnabled;
  constructor(t, e, i, r, o) {
    this.routeReuseStrategy = t, this.futureState = e, this.currState = i,
    this.forwardEvent = r, this.inputBindingEnabled = o
  }
  activate(t) {
    let e = this.futureState._root,
        i = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(e, i, t), x_(this.futureState.root),
        this.activateChildRoutes(e, i, t)
  }
  deactivateChildRoutes(t, e, i) {
    let r = Bs(e);
    t.children.forEach(o => {
      let s = o.value.outlet;
      this.deactivateRoutes(o, r[s], i), delete r[s]
    }),
        Object.values(r).forEach(
            o => {this.deactivateRouteAndItsChildren(o, i)})
  }
  deactivateRoutes(t, e, i) {
    let r = t.value, o = e ? e.value : null;
    if (r === o)
      if (r.component) {
        let s = i.getContext(r.outlet);
        s && this.deactivateChildRoutes(t, e, s.children)
      } else
        this.deactivateChildRoutes(t, e, i);
    else
      o && this.deactivateRouteAndItsChildren(e, i)
  }
  deactivateRouteAndItsChildren(t, e) {
    t.value.component &&
            this.routeReuseStrategy.shouldDetach(t.value.snapshot) ?
        this.detachAndStoreRouteSubtree(t, e) :
        this.deactivateRouteAndOutlet(t, e)
  }
  detachAndStoreRouteSubtree(t, e) {
    let i = e.getContext(t.value.outlet),
        r = i && t.value.component ? i.children : e, o = Bs(t);
    for (let s of Object.values(o)) this.deactivateRouteAndItsChildren(s, r);
    if (i && i.outlet) {
      let s = i.outlet.detach(), a = i.children.onOutletDeactivated();
      this.routeReuseStrategy.store(
          t.value.snapshot, {componentRef: s, route: t, contexts: a})
    }
  }
  deactivateRouteAndOutlet(t, e) {
    let i = e.getContext(t.value.outlet),
        r = i && t.value.component ? i.children : e, o = Bs(t);
    for (let s of Object.values(o)) this.deactivateRouteAndItsChildren(s, r);
    i &&
        (i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated()),
         i.attachRef = null, i.route = null)
  }
  activateChildRoutes(t, e, i) {
    let r = Bs(e);
    t.children.forEach(o => {
      this.activateRoutes(o, r[o.value.outlet], i),
      this.forwardEvent(new V_(o.value.snapshot))
    }),
        t.children.length && this.forwardEvent(new F_(t.value.snapshot))
  }
  activateRoutes(t, e, i) {
    let r = t.value, o = e ? e.value : null;
    if (x_(r), r === o)
      if (r.component) {
        let s = i.getOrCreateContext(r.outlet);
        this.activateChildRoutes(t, e, s.children)
      } else
        this.activateChildRoutes(t, e, i);
    else if (r.component) {
      let s = i.getOrCreateContext(r.outlet);
      if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
        let a = this.routeReuseStrategy.retrieve(r.snapshot);
        this.routeReuseStrategy.store(r.snapshot, null),
            s.children.onOutletReAttached(a.contexts),
            s.attachRef = a.componentRef, s.route = a.route.value,
            s.outlet && s.outlet.attach(a.componentRef, a.route.value),
            x_(a.route.value), this.activateChildRoutes(t, null, s.children)
      } else
        s.attachRef = null, s.route = r,
        s.outlet && s.outlet.activateWith(r, s.injector),
        this.activateChildRoutes(t, null, s.children)
    } else
      this.activateChildRoutes(t, null, i)
  }
}
, Em = class {
  path;
  route;
  constructor(t) {
    this.path = t, this.route = this.path[this.path.length - 1]
  }
}
, Us = class {
  component;
  route;
  constructor(t, e) {
    this.component = t, this.route = e
  }
};
function SL(n, t, e) {
  let i = n._root, r = t ? t._root : null;
  return Il(i, r, e, [i.value])
}
function IL(n) {
  let t = n.routeConfig ? n.routeConfig.canActivateChild : null;
  return !t || t.length === 0 ? null : {node: n, guards: t}
}
function Ys(n, t) {
  let e = Symbol(), i = t.get(n, e);
  return i === e ? typeof n == 'function' && !tw(n) ? n : t.get(n) : i
}
function Il(n, t, e, i, r = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  let o = Bs(t);
  return n.children.forEach(s => {
    ML(s, o[s.value.outlet], e, i.concat([s.value]), r),
    delete o[s.value.outlet]
  }),
         Object.entries(o).forEach(([s, a]) => Tl(a, e.getContext(s), r)), r
}
function ML(n, t, e, i, r = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  let o = n.value, s = t ? t.value : null,
      a = e ? e.getContext(n.value.outlet) : null;
  if (s && o.routeConfig === s.routeConfig) {
    let l = TL(s, o, o.routeConfig.runGuardsAndResolvers);
    l ? r.canActivateChecks.push(new Em(i)) :
        (o.data = s.data, o._resolvedData = s._resolvedData),
        o.component ? Il(n, t, a ? a.children : null, i, r) : Il(n, t, e, i, r),
        l && a && a.outlet && a.outlet.isActivated &&
        r.canDeactivateChecks.push(new Us(a.outlet.component, s))
  } else
    s && Tl(t, a, r), r.canActivateChecks.push(new Em(i)),
        o.component ? Il(n, null, a ? a.children : null, i, r) :
                      Il(n, null, e, i, r);
  return r
}
function TL(n, t, e) {
  if (typeof e == 'function') return e(n, t);
  switch (e) {
    case 'pathParamsChange':
      return !Oo(n.url, t.url);
    case 'pathParamsOrQueryParamsChange':
      return !Oo(n.url, t.url) || !gi(n.queryParams, t.queryParams);
    case 'always':
      return !0;
    case 'paramsOrQueryParamsChange':
      return !H_(n, t) || !gi(n.queryParams, t.queryParams);
    case 'paramsChange':
    default:
      return !H_(n, t)
  }
}
function Tl(n, t, e) {
  let i = Bs(n), r = n.value;
  Object.entries(i).forEach(
      ([o, s]) => {
          r.component ?
              t ? Tl(s, t.children.getContext(o), e) : Tl(s, null, e) :
              Tl(s, t, e)}),
      r.component ? t && t.outlet && t.outlet.isActivated ?
                    e.canDeactivateChecks.push(new Us(t.outlet.component, r)) :
                    e.canDeactivateChecks.push(new Us(null, r)) :
                    e.canDeactivateChecks.push(new Us(null, r))
}
function Ul(n) {
  return typeof n == 'function'
}
function RL(n) {
  return typeof n == 'boolean'
}
function AL(n) {
  return n && Ul(n.canLoad)
}
function OL(n) {
  return n && Ul(n.canActivate)
}
function NL(n) {
  return n && Ul(n.canActivateChild)
}
function PL(n) {
  return n && Ul(n.canDeactivate)
}
function FL(n) {
  return n && Ul(n.canMatch)
}
function $E(n) {
  return n instanceof Ai || n?.name === 'EmptyError'
}
var dm = Symbol('INITIAL_VALUE');
function Qs() {
  return $e(
      n => Mn(n.map(t => t.pipe(Ye(1), Xe(dm))))
               .pipe(
                   Q(t => {
                     for (let e of t)
                       if (e !== !0) {
                         if (e === dm) return dm;
                         if (e === !1 || LL(e)) return e
                       }
                     return !0
                   }),
                   me(t => t !== dm), Ye(1)))
}
function LL(n) {
  return Rl(n) || n instanceof Fl
}
function VL(n, t) {
  return ot(e => {
    let {
      targetSnapshot: i,
      currentSnapshot: r,
      guards: {canActivateChecks: o, canDeactivateChecks: s}
    } = e;
    return s.length === 0 && o.length === 0 ?
        G(ae(y({}, e), {guardsResult: !0})) :
        jL(s, i, r, n)
            .pipe(
                ot(a => a && RL(a) ? BL(i, o, n, t) : G(a)),
                Q(a => ae(y({}, e), {guardsResult: a})))
  })
}
function jL(n, t, e, i) {
  return Ue(n).pipe(
      ot(r => WL(r.component, r.route, e, t, i)), ei(r => r !== !0, !0))
}
function BL(n, t, e, i) {
  return Ue(t).pipe(
      Oi(r =>
             dr(HL(r.route.parent, i), zL(r.route, i), $L(n, r.path, e),
                UL(n, r.route, e))),
      ei(r => r !== !0, !0))
}
function zL(n, t) {
  return n !== null && t && t(new L_(n)), G(!0)
}
function HL(n, t) {
  return n !== null && t && t(new P_(n)), G(!0)
}
function UL(n, t, e) {
  let i = t.routeConfig ? t.routeConfig.canActivate : null;
  if (!i || i.length === 0) return G(!0);
  let r = i.map(o => Xn(() => {
                  let s = zl(t) ?? e, a = Ys(o, s),
                      l = OL(a) ? a.canActivate(t, n) : Kt(s, () => a(t, n));
                  return Nr(l).pipe(ei())
                }));
  return G(r).pipe(Qs())
}
function $L(n, t, e) {
  let i = t[t.length - 1],
      o = t.slice(0, t.length - 1)
              .reverse()
              .map(s => IL(s))
              .filter(s => s !== null)
              .map(s => Xn(() => {
                     let a = s.guards.map(l => {
                       let c = zl(s.node) ?? e, d = Ys(l, c),
                           m = NL(d) ? d.canActivateChild(i, n) :
                                       Kt(c, () => d(i, n));
                       return Nr(m).pipe(ei())
                     });
                     return G(a).pipe(Qs())
                   }));
  return G(o).pipe(Qs())
}
function WL(n, t, e, i, r) {
  let o = t && t.routeConfig ? t.routeConfig.canDeactivate : null;
  if (!o || o.length === 0) return G(!0);
  let s = o.map(a => {
    let l = zl(t) ?? r, c = Ys(a, l),
        d = PL(c) ? c.canDeactivate(n, t, e, i) : Kt(l, () => c(n, t, e, i));
    return Nr(d).pipe(ei())
  });
  return G(s).pipe(Qs())
}
function qL(n, t, e, i) {
  let r = t.canLoad;
  if (r === void 0 || r.length === 0) return G(!0);
  let o = r.map(s => {
    let a = Ys(s, n), l = AL(a) ? a.canLoad(t, e) : Kt(n, () => a(t, e));
    return Nr(l)
  });
  return G(o).pipe(Qs(), WE(i))
}
function WE(n) {
  return mf(
      He(t => {
        if (typeof t != 'boolean') throw Dm(n, t)
      }),
      Q(t => t === !0))
}
function GL(n, t, e, i) {
  let r = t.canMatch;
  if (!r || r.length === 0) return G(!0);
  let o = r.map(s => {
    let a = Ys(s, n), l = FL(a) ? a.canMatch(t, e) : Kt(n, () => a(t, e));
    return Nr(l)
  });
  return G(o).pipe(Qs(), WE(i))
}
var Ll = class {
  segmentGroup;
  constructor(t) {
    this.segmentGroup = t || null
  }
}
, Vl = class extends Error {
  urlTree;
  constructor(t) {
    super(), this.urlTree = t
  }
};
function js(n) {
  return ar(new Ll(n))
}
function QL(n) {
  return ar(new S(4e3, !1))
}
function YL(n) {
  return ar(HE(!1, dn.GuardRejected))
}
var W_ = class {
  urlSerializer;
  urlTree;
  constructor(t, e) {
    this.urlSerializer = t, this.urlTree = e
  }
  lineralizeSegments(t, e) {
    let i = [], r = e.root;
    for (;;) {
      if (i = i.concat(r.segments), r.numberOfChildren === 0) return G(i);
      if (r.numberOfChildren > 1 || !r.children[Ee])
        return QL(`${t.redirectTo}`);
      r = r.children[Ee]
    }
  }
  applyRedirectCommands(t, e, i, r, o) {
    if (typeof e != 'string') {
      let a = e, {
        queryParams: l,
        fragment: c,
        routeConfig: d,
        url: m,
        outlet: p,
        params: h,
        data: _,
        title: v
      } = r,
          k = Kt(o, () => a({
                      params: h,
                      data: _,
                      queryParams: l,
                      fragment: c,
                      routeConfig: d,
                      url: m,
                      outlet: p,
                      title: v
                    }));
      if (k instanceof Yi) throw new Vl(k);
      e = k
    }
    let s =
        this.applyRedirectCreateUrlTree(e, this.urlSerializer.parse(e), t, i);
    if (e[0] === '/') throw new Vl(s);
    return s
  }
  applyRedirectCreateUrlTree(t, e, i, r) {
    let o = this.createSegmentGroup(t, e.root, i, r);
    return new Yi(
        o, this.createQueryParams(e.queryParams, this.urlTree.queryParams),
        e.fragment)
  }
  createQueryParams(t, e) {
    let i = {};
    return Object.entries(t).forEach(([r, o]) => {
      if (typeof o == 'string' && o[0] === ':') {
        let a = o.substring(1);
        i[r] = e[a]
      } else
        i[r] = o
    }),
           i
  }
  createSegmentGroup(t, e, i, r) {
    let o = this.createSegments(t, e.segments, i, r), s = {};
    return Object.entries(e.children)
               .forEach(
                   ([a, l]) => {s[a] = this.createSegmentGroup(t, l, i, r)}),
           new je(o, s)
  }
  createSegments(t, e, i, r) {
    return e.map(
        o => o.path[0] === ':' ? this.findPosParam(t, o, r) :
                                 this.findOrReturn(o, i))
  }
  findPosParam(t, e, i) {
    let r = i[e.path.substring(1)];
    if (!r) throw new S(4001, !1);
    return r
  }
  findOrReturn(t, e) {
    let i = 0;
    for (let r of e) {
      if (r.path === t.path) return e.splice(i), r;
      i++
    }
    return t
  }
}
, q_ = {
  matched: !1,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function ZL(n, t, e, i, r) {
  let o = qE(n, t, e);
  return o.matched ?
      (i = _L(t, i), GL(i, t, e, r).pipe(Q(s => s === !0 ? o : y({}, q_)))) :
      G(o)
}
function qE(n, t, e) {
  if (t.path === '**') return KL(e);
  if (t.path === '')
    return t.pathMatch === 'full' && (n.hasChildren() || e.length > 0) ?
        y({}, q_) :
        {
          matched: !0,
          consumedSegments: [],
          remainingSegments: e,
          parameters: {},
          positionalParamSegments: {}
        };
  let r = (t.matcher || WF)(e, n, t);
  if (!r) return y({}, q_);
  let o = {};
  Object.entries(r.posParams ?? {}).forEach(([a, l]) => {o[a] = l.path});
  let s = r.consumed.length > 0 ?
      y(y({}, o), r.consumed[r.consumed.length - 1].parameters) :
      o;
  return {
    matched: !0, consumedSegments: r.consumed,
        remainingSegments: e.slice(r.consumed.length), parameters: s,
        positionalParamSegments: r.posParams ?? {}
  }
}
function KL(n) {
  return {
    matched: !0, parameters: n.length > 0 ? EE(n).parameters : {},
        consumedSegments: n, remainingSegments: [], positionalParamSegments: {}
  }
}
function yE(n, t, e, i) {
  return e.length > 0 && e2(n, e, i) ?
      {
        segmentGroup: new je(t, JL(i, new je(e, n.children))),
        slicedSegments: []
      } :
      e.length === 0 && t2(n, e, i) ?
      {
        segmentGroup: new je(n.segments, XL(n, e, i, n.children)),
        slicedSegments: e
      } :
      {segmentGroup: new je(n.segments, n.children), slicedSegments: e}
}
function XL(n, t, e, i) {
  let r = {};
  for (let o of e)
    if (Mm(n, t, o) && !i[zn(o)]) {
      let s = new je([], {});
      r[zn(o)] = s
    }
  return y(y({}, i), r)
}
function JL(n, t) {
  let e = {};
  e[Ee] = t;
  for (let i of n)
    if (i.path === '' && zn(i) !== Ee) {
      let r = new je([], {});
      e[zn(i)] = r
    }
  return e
}
function e2(n, t, e) {
  return e.some(i => Mm(n, t, i) && zn(i) !== Ee)
}
function t2(n, t, e) {
  return e.some(i => Mm(n, t, i))
}
function Mm(n, t, e) {
  return (n.hasChildren() || t.length > 0) && e.pathMatch === 'full' ?
      !1 :
      e.path === ''
}
function n2(n, t, e) {
  return t.length === 0 && !n.children[e]
}
var G_ = class {};
function i2(n, t, e, i, r, o, s = 'emptyOnly') {
  return new Q_(n, t, e, i, r, s, o).recognize()
}
var r2 = 31, Q_ = class {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = !0;
  constructor(t, e, i, r, o, s, a) {
    this.injector = t, this.configLoader = e, this.rootComponentType = i,
    this.config = r, this.urlTree = o, this.paramsInheritanceStrategy = s,
    this.urlSerializer = a,
    this.applyRedirects = new W_(this.urlSerializer, this.urlTree)
  }
  noMatchError(t) {
    return new S(4002, `'${t.segmentGroup}'`)
  }
  recognize() {
    let t = yE(this.urlTree.root, [], [], this.config).segmentGroup;
    return this.match(t).pipe(Q(({children: e, rootSnapshot: i}) => {
      let r = new cn(i, e), o = new Cm('', r),
          s = dL(i, [], this.urlTree.queryParams, this.urlTree.fragment);
      return s.queryParams = this.urlTree.queryParams,
             o.url = this.urlSerializer.serialize(s), {
        state: o, tree: s
      }
    }))
  }
  match(t) {
    let e = new Hs(
        [], Object.freeze({}), Object.freeze(y({}, this.urlTree.queryParams)),
        this.urlTree.fragment, Object.freeze({}), Ee, this.rootComponentType,
        null, {});
    return this.processSegmentGroup(this.injector, this.config, t, Ee, e)
        .pipe(Q(i => ({children: i, rootSnapshot: e})), sn(i => {
                if (i instanceof Vl)
                  return this.urlTree = i.urlTree, this.match(i.urlTree.root);
                throw i instanceof Ll ? this.noMatchError(i) : i
              }))
  }
  processSegmentGroup(t, e, i, r, o) {
    return i.segments.length === 0 && i.hasChildren() ?
        this.processChildren(t, e, i, o) :
        this.processSegment(t, e, i, i.segments, r, !0, o)
            .pipe(Q(s => s instanceof cn ? [s] : []))
  }
  processChildren(t, e, i, r) {
    let o = [];
    for (let s of Object.keys(i.children))
      s === 'primary' ? o.unshift(s) : o.push(s);
    return Ue(o).pipe(
        Oi(s => {
          let a = i.children[s], l = bL(e, s);
          return this.processSegmentGroup(t, l, a, s, r)
        }),
        bf((s, a) => (s.push(...a), s)), ur(null), _f(), ot(s => {
          if (s === null) return js(i);
          let a = GE(s);
          return o2(a), G(a)
        }))
  }
  processSegment(t, e, i, r, o, s, a) {
    return Ue(e).pipe(
        Oi(l => this.processSegmentAgainstRoute(
                        l._injector ?? t, e, l, i, r, o, s, a)
                    .pipe(sn(c => {
                      if (c instanceof Ll) return G(null);
                      throw c
                    }))),
        ei(l => !!l), sn(l => {
          if ($E(l)) return n2(i, r, o) ? G(new G_) : js(i);
          throw l
        }))
  }
  processSegmentAgainstRoute(t, e, i, r, o, s, a, l) {
    return zn(i) !== s && (s === Ee || !Mm(r, o, i)) ?
        js(r) :
        i.redirectTo === void 0 ?
        this.matchSegmentAgainstRoute(t, r, i, o, s, l) :
        this.allowRedirects && a ?
        this.expandSegmentAgainstRouteUsingRedirect(t, r, e, i, o, s, l) :
        js(r)
  }
  expandSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s, a) {
    let {
      matched: l,
      parameters: c,
      consumedSegments: d,
      positionalParamSegments: m,
      remainingSegments: p
    } = qE(e, r, o);
    if (!l) return js(e);
    typeof r.redirectTo == 'string' && r.redirectTo[0] === '/' &&
        (this.absoluteRedirectCount++,
         this.absoluteRedirectCount > r2 && (this.allowRedirects = !1));
    let h = new Hs(
            o, c, Object.freeze(y({}, this.urlTree.queryParams)),
            this.urlTree.fragment, wE(r), zn(r),
            r.component ?? r._loadedComponent ?? null, r, xE(r)),
        _ = xm(h, a, this.paramsInheritanceStrategy);
    h.params = Object.freeze(_.params), h.data = Object.freeze(_.data);
    let v = this.applyRedirects.applyRedirectCommands(d, r.redirectTo, m, h, t);
    return this.applyRedirects.lineralizeSegments(r, v).pipe(
        ot(k => this.processSegment(t, i, e, k.concat(p), s, !1, a)))
  }
  matchSegmentAgainstRoute(t, e, i, r, o, s) {
    let a = ZL(e, i, r, t, this.urlSerializer);
    return i.path === '**' && (e.children = {}),
           a.pipe($e(
               l => l.matched ?
                   (t = i._injector ?? t,
                    this.getChildConfig(t, i, r).pipe($e(({routes: c}) => {
                      let d = i._loadedInjector ?? t, {
                        parameters: m,
                        consumedSegments: p,
                        remainingSegments: h
                      } = l,
                          _ = new Hs(
                              p, m,
                              Object.freeze(y({}, this.urlTree.queryParams)),
                              this.urlTree.fragment, wE(i), zn(i),
                              i.component ?? i._loadedComponent ?? null, i,
                              xE(i)),
                          v = xm(_, s, this.paramsInheritanceStrategy);
                      _.params = Object.freeze(v.params),
                      _.data = Object.freeze(v.data);
                      let {segmentGroup: k, slicedSegments: F} = yE(e, p, h, c);
                      if (F.length === 0 && k.hasChildren())
                        return this.processChildren(d, c, k, _)
                            .pipe(Q(Ce => new cn(_, Ce)));
                      if (c.length === 0 && F.length === 0)
                        return G(new cn(_, []));
                      let se = zn(i) === o;
                      return this.processSegment(d, c, k, F, se ? Ee : o, !0, _)
                          .pipe(
                              Q(Ce => new cn(_, Ce instanceof cn ? [Ce] : [])))
                    }))) :
                   js(e)))
  }
  getChildConfig(t, e, i) {
    return e.children ?
        G({routes: e.children, injector: t}) :
        e.loadChildren ?
        e._loadedRoutes !== void 0 ?
        G({routes: e._loadedRoutes, injector: e._loadedInjector}) :
        qL(t, e, i, this.urlSerializer)
                .pipe(ot(
                    r => r ? this.configLoader.loadChildren(t, e).pipe(He(o => {
                      e._loadedRoutes = o.routes,
                      e._loadedInjector = o.injector
                    })) :
                             YL(e))) :
        G({routes: [], injector: t})
  }
};
function o2(n) {
  n.sort(
      (t, e) => t.value.outlet === Ee ? -1 :
          e.value.outlet === Ee       ? 1 :
                                  t.value.outlet.localeCompare(e.value.outlet))
}
function s2(n) {
  let t = n.value.routeConfig;
  return t && t.path === ''
}
function GE(n) {
  let t = [], e = new Set;
  for (let i of n) {
    if (!s2(i)) {
      t.push(i);
      continue
    }
    let r = t.find(o => i.value.routeConfig === o.value.routeConfig);
    r !== void 0 ? (r.children.push(...i.children), e.add(r)) : t.push(i)
  }
  for (let i of e) {
    let r = GE(i.children);
    t.push(new cn(i.value, r))
  }
  return t.filter(i => !e.has(i))
}
function wE(n) {
  return n.data || {}
}
function xE(n) {
  return n.resolve || {}
}
function a2(n, t, e, i, r, o) {
  return ot(
      s => i2(n, t, e, i, s.extractedUrl, r, o)
               .pipe(
                   Q(({state: a, tree: l}) => ae(
                         y({}, s), {targetSnapshot: a, urlAfterRedirects: l}))))
}
function l2(n, t) {
  return ot(e => {
    let {targetSnapshot: i, guards: {canActivateChecks: r}} = e;
    if (!r.length) return G(e);
    let o = new Set(r.map(l => l.route)), s = new Set;
    for (let l of o)
      if (!s.has(l))
        for (let c of QE(l)) s.add(c);
    let a = 0;
    return Ue(s).pipe(
        Oi(l => o.has(l) ? c2(l, i, n, t) :
                           (l.data = xm(l, l.parent, n).resolve, G(void 0))),
        He(() => a++), ls(1), ot(l => a === s.size ? G(e) : mt))
  })
}
function QE(n) {
  let t = n.children.map(e => QE(e)).flat();
  return [n, ...t]
}
function c2(n, t, e, i) {
  let r = n.routeConfig, o = n._resolve;
  return r?.title !== void 0 && !BE(r) && (o[jl] = r.title),
         d2(o, n, t, i)
             .pipe(
                 Q(s =>
                       (n._resolvedData = s,
                        n.data = xm(n, n.parent, e).resolve, null)))
}
function d2(n, t, e, i) {
  let r = E_(n);
  if (r.length === 0) return G({});
  let o = {};
  return Ue(r).pipe(
      ot(s => u2(n[s], t, e, i).pipe(ei(), He(a => {
                                       if (a instanceof Fl) throw Dm(new Ws, a);
                                       o[s] = a
                                     }))),
      ls(1), Q(() => o), sn(s => $E(s) ? mt : ar(s)))
}
function u2(n, t, e, i) {
  let r = zl(t) ?? i, o = Ys(n, r),
      s = o.resolve ? o.resolve(t, e) : Kt(r, () => o(t, e));
  return Nr(s)
}
function C_(n) {
  return $e(t => {
    let e = n(t);
    return e ? Ue(e).pipe(Q(() => t)) : G(t)
  })
}
var YE = (() => {
  class n {
    buildTitle(e) {
      let i, r = e.root;
      for (; r !== void 0;)
        i = this.getResolvedTitleForRoute(r) ?? i,
        r = r.children.find(o => o.outlet === Ee);
      return i
    }
    getResolvedTitleForRoute(e) {
      return e.data[jl]
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: () => u(m2), providedIn: 'root'})
  } return n
})(),
    m2 = (() => {
      class n extends YE {
        title;
        constructor(e) {
          super(), this.title = e
        }
        updateTitle(e) {
          let i = this.buildTitle(e);
          i !== void 0 && this.title.setTitle(i)
        }
        static \u0275fac = function(i) {
          return new (i || n)(A(zD))
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    $l = new w('', {providedIn: 'root', factory: () => ({})}),
    h2 = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['ng-component']],
          exportAs: ['emptyRouterOutlet'],
          decls: 1,
          vars: 0,
          template: function(i, r) {
            i&1 && B(0, 'router-outlet')
          },
          dependencies: [wL],
          encapsulation: 2
        })
      } return n
    })();
function K_(n) {
  let t = n.children && n.children.map(K_),
      e = t ? ae(y({}, n), {children: t}) : y({}, n);
  return !e.component && !e.loadComponent && (t || e.loadChildren) &&
             e.outlet && e.outlet !== Ee && (e.component = h2),
         e
}
var km = new w(''),
    X_ = (() => {
      class n {
        componentLoaders = new WeakMap;
        childrenLoaders = new WeakMap;
        onLoadStartListener;
        onLoadEndListener;
        compiler = u(Mu);
        loadComponent(e) {
          if (this.componentLoaders.get(e)) return this.componentLoaders.get(e);
          if (e._loadedComponent) return G(e._loadedComponent);
          this.onLoadStartListener && this.onLoadStartListener(e);
          let i = Nr(e.loadComponent())
                      .pipe(
                          Q(ZE), He(o => {
                            this.onLoadEndListener && this.onLoadEndListener(e),
                            e._loadedComponent = o
                          }),
                          Jn(() => {this.componentLoaders.delete(e)})),
              r = new sr(i, () => new I).pipe(ns());
          return this.componentLoaders.set(e, r), r
        }
        loadChildren(e, i) {
          if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
          if (i._loadedRoutes)
            return G({routes: i._loadedRoutes, injector: i._loadedInjector});
          this.onLoadStartListener && this.onLoadStartListener(i);
          let o = f2(i, this.compiler, e, this.onLoadEndListener)
                      .pipe(Jn(() => {this.childrenLoaders.delete(i)})),
              s = new sr(o, () => new I).pipe(ns());
          return this.childrenLoaders.set(i, s), s
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function f2(n, t, e, i) {
  return Nr(n.loadChildren())
      .pipe(
          Q(ZE),
          ot(r => r instanceof Tg || Array.isArray(r) ?
                 G(r) :
                 Ue(t.compileModuleAsync(r))),
          Q(r => {
            i && i(n);
            let o, s, a = !1;
            return Array.isArray(r) ?
                       (s = r, a = !0) :
                       (o = r.create(e).injector,
                        s = o.get(km, [], {optional: !0, self: !0}).flat()),
            {
              routes: s.map(K_), injector: o
            }
          }))
}
function p2(n) {
  return n && typeof n == 'object' && 'default' in n
}
function ZE(n) {
  return p2(n) ? n.default : n
}
var J_ = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: () => u(g2), providedIn: 'root'})
  } return n
})(),
    g2 = (() => {
      class n {
        shouldProcessUrl(e) {
          return !0
        }
        extract(e) {
          return e
        }
        merge(e, i) {
          return e
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    KE = new w(''), XE = new w('');
function _2(n, t, e) {
  let i = n.get(XE), r = n.get(ce);
  return n.get(U).runOutsideAngular(() => {
    if (!r.startViewTransition || i.skipNextTransition)
      return i.skipNextTransition = !1, new Promise(c => setTimeout(c));
    let o, s = new Promise(c => {o = c}),
           a = r.startViewTransition(() => (o(), b2(n))),
           {onViewTransitionCreated: l} = i;
    return l && Kt(n, () => l({transition: a, from: t, to: e})), s
  })
}
function b2(n) {
  return new Promise(t => {ht({read: () => setTimeout(t)}, {injector: n})})
}
var JE = new w(''),
    eb = (() => {
      class n {
        currentNavigation = null;
        currentTransition = null;
        lastSuccessfulNavigation = null;
        events = new I;
        transitionAbortSubject = new I;
        configLoader = u(X_);
        environmentInjector = u(_t);
        destroyRef = u(ks);
        urlSerializer = u(Bl);
        rootContexts = u(Hl);
        location = u(Dr);
        inputBindingEnabled = u(Im, {optional: !0}) !== null;
        titleStrategy = u(YE);
        options = u($l, {optional: !0}) || {};
        paramsInheritanceStrategy =
            this.options.paramsInheritanceStrategy || 'emptyOnly';
        urlHandlingStrategy = u(J_);
        createViewTransition = u(KE, {optional: !0});
        navigationErrorHandler = u(JE, {optional: !0});
        navigationId = 0;
        get hasRequestedNavigation() {
          return this.navigationId !== 0
        }
        transitions;
        afterPreactivation = () => G(void 0);
        rootComponentType = null;
        destroyed = !1;
        constructor() {
          let e = r => this.events.next(new O_(r)),
              i = r => this.events.next(new N_(r));
          this.configLoader.onLoadEndListener = i,
          this.configLoader.onLoadStartListener = e,
          this.destroyRef.onDestroy(() => {this.destroyed = !0})
        }
        complete() {
          this.transitions?.complete()
        }
        handleNavigationRequest(e) {
          let i = ++this.navigationId;
          this.transitions?.next(ae(y({}, e), {
            extractedUrl: this.urlHandlingStrategy.extract(e.rawUrl),
            targetSnapshot: null,
            targetRouterState: null,
            guards: {canActivateChecks: [], canDeactivateChecks: []},
            guardsResult: null,
            id: i
          }))
        }
        setupNavigations(e) {
          return this.transitions = new Le(null),
                 this.transitions.pipe(
                     me(i => i !== null), $e(i => {
                       let r = !1, o = !1;
                       return G(i).pipe(
                           $e(s => {
                             if (this.navigationId > i.id)
                               return this.cancelNavigationTransition(
                                          i, '', dn.SupersededByNewNavigation),
                                      mt;
                             this.currentTransition = i,
                             this.currentNavigation = {
                               id: s.id,
                               initialUrl: s.rawUrl,
                               extractedUrl: s.extractedUrl,
                               targetBrowserUrl:
                                   typeof s.extras.browserUrl == 'string' ?
                                   this.urlSerializer.parse(
                                       s.extras.browserUrl) :
                                   s.extras.browserUrl,
                               trigger: s.source,
                               extras: s.extras,
                               previousNavigation:
                                   this.lastSuccessfulNavigation ?
                                   ae(y({}, this.lastSuccessfulNavigation),
                                      {previousNavigation: null}) :
                                   null
                             };
                             let a = !e.navigated ||
                                 this.isUpdatingInternalState() ||
                                 this.isUpdatedBrowserUrl(),
                                 l = s.extras.onSameUrlNavigation ??
                                 e.onSameUrlNavigation;
                             if (!a && l !== 'reload') {
                               let c = '';
                               return this.events.next(new Rr(
                                          s.id,
                                          this.urlSerializer.serialize(
                                              s.rawUrl),
                                          c, _m.IgnoredSameUrlNavigation)),
                                      s.resolve(!1), mt
                             }
                             if (this.urlHandlingStrategy.shouldProcessUrl(
                                     s.rawUrl))
                               return G(s).pipe(
                                   $e(c =>
                                          (this.events.next(new qs(
                                               c.id,
                                               this.urlSerializer.serialize(
                                                   c.extractedUrl),
                                               c.source, c.restoredState)),
                                           c.id !== this.navigationId ?
                                               mt :
                                               Promise.resolve(c))),
                                   a2(this.environmentInjector,
                                      this.configLoader, this.rootComponentType,
                                      e.config, this.urlSerializer,
                                      this.paramsInheritanceStrategy),
                                   He(c => {
                                     i.targetSnapshot = c.targetSnapshot,
                                     i.urlAfterRedirects = c.urlAfterRedirects,
                                     this.currentNavigation =
                                         ae(y({}, this.currentNavigation),
                                            {finalUrl: c.urlAfterRedirects});
                                     let d = new bm(
                                         c.id,
                                         this.urlSerializer.serialize(
                                             c.extractedUrl),
                                         this.urlSerializer.serialize(
                                             c.urlAfterRedirects),
                                         c.targetSnapshot);
                                     this.events.next(d)
                                   }));
                             if (a &&
                                 this.urlHandlingStrategy.shouldProcessUrl(
                                     s.currentRawUrl)) {
                               let {
                                 id: c,
                                 extractedUrl: d,
                                 source: m,
                                 restoredState: p,
                                 extras: h
                               } = s,
                              _ = new qs(
                                  c, this.urlSerializer.serialize(d), m, p);
                               this.events.next(_);
                               let v = VE(this.rootComponentType).snapshot;
                               return this.currentTransition = i =
                                          ae(y({}, s), {
                                            targetSnapshot: v,
                                            urlAfterRedirects: d,
                                            extras: ae(y({}, h), {
                                              skipLocationChange: !1,
                                              replaceUrl: !1
                                            })
                                          }),
                                      this.currentNavigation.finalUrl = d, G(i)
                             } else {
                               let c = '';
                               return this.events.next(new Rr(
                                          s.id,
                                          this.urlSerializer.serialize(
                                              s.extractedUrl),
                                          c, _m.IgnoredByUrlHandlingStrategy)),
                                      s.resolve(!1), mt
                             }
                           }),
                           He(s => {
                             let a = new M_(
                                 s.id,
                                 this.urlSerializer.serialize(s.extractedUrl),
                                 this.urlSerializer.serialize(
                                     s.urlAfterRedirects),
                                 s.targetSnapshot);
                             this.events.next(a)
                           }),
                           Q(s =>
                                 (this.currentTransition = i = ae(y({}, s), {
                                    guards:
                                        SL(s.targetSnapshot, s.currentSnapshot,
                                           this.rootContexts)
                                  }),
                                  i)),
                           VL(this.environmentInjector,
                              s => this.events.next(s)),
                           He(s => {
                             if (i.guardsResult = s.guardsResult,
                                 s.guardsResult &&
                                     typeof s.guardsResult != 'boolean')
                               throw Dm(this.urlSerializer, s.guardsResult);
                             let a = new T_(
                                 s.id,
                                 this.urlSerializer.serialize(s.extractedUrl),
                                 this.urlSerializer.serialize(
                                     s.urlAfterRedirects),
                                 s.targetSnapshot, !!s.guardsResult);
                             this.events.next(a)
                           }),
                           me(s => s.guardsResult ?
                                  !0 :
                                  (this.cancelNavigationTransition(
                                       s, '', dn.GuardRejected),
                                   !1)),
                           C_(s => {
                             if (s.guards.canActivateChecks.length !== 0)
                               return G(s).pipe(
                                   He(a => {
                                     let l = new R_(
                                         a.id,
                                         this.urlSerializer.serialize(
                                             a.extractedUrl),
                                         this.urlSerializer.serialize(
                                             a.urlAfterRedirects),
                                         a.targetSnapshot);
                                     this.events.next(l)
                                   }),
                                   $e(a => {
                                     let l = !1;
                                     return G(a).pipe(
                                         l2(this.paramsInheritanceStrategy,
                                            this.environmentInjector),
                                         He({
                                           next: () => l = !0,
                                           complete: () => {
                                             l ||
                                                 this.cancelNavigationTransition(
                                                     a, '',
                                                     dn.NoDataFromResolver)
                                           }
                                         }))
                                   }),
                                   He(a => {
                                     let l = new A_(
                                         a.id,
                                         this.urlSerializer.serialize(
                                             a.extractedUrl),
                                         this.urlSerializer.serialize(
                                             a.urlAfterRedirects),
                                         a.targetSnapshot);
                                     this.events.next(l)
                                   }))
                           }),
                           C_(s => {
                             let a = l => {
                               let c = [];
                               l.routeConfig?.loadComponent &&
                                   !l.routeConfig._loadedComponent &&
                                   c.push(this.configLoader
                                              .loadComponent(l.routeConfig)
                                              .pipe(
                                                  He(d => {l.component = d}),
                                                  Q(() => {})));
                               for (let d of l.children) c.push(...a(d));
                               return c
                             };
                             return Mn(a(s.targetSnapshot.root))
                                 .pipe(ur(null), Ye(1))
                           }),
                           C_(() => this.afterPreactivation()), $e(() => {
                             let {
                               currentSnapshot: s,
                               targetSnapshot: a
                             } = i,
                            l = this.createViewTransition?.(
                                this.environmentInjector, s.root, a.root);
                             return l ? Ue(l).pipe(Q(() => i)) : G(i)
                           }),
                           Q(s => {
                             let a =
                                 xL(e.routeReuseStrategy, s.targetSnapshot,
                                    s.currentRouterState);
                             return this.currentTransition = i =
                                        ae(y({}, s), {targetRouterState: a}),
                                    this.currentNavigation.targetRouterState =
                                        a,
                                    i
                           }),
                           He(() => {this.events.next(new Nl)}),
                           kL(this.rootContexts, e.routeReuseStrategy,
                              s => this.events.next(s),
                              this.inputBindingEnabled),
                           Ye(1), He({
                             next: s => {
                               r = !0,
                               this.lastSuccessfulNavigation =
                                   this.currentNavigation,
                               this.events.next(new Hn(
                                   s.id,
                                   this.urlSerializer.serialize(s.extractedUrl),
                                   this.urlSerializer.serialize(
                                       s.urlAfterRedirects))),
                               this.titleStrategy?.updateTitle(
                                   s.targetRouterState.snapshot),
                               s.resolve(!0)
                             },
                             complete: () => {
                               r = !0
                             }
                           }),
                           re(this.transitionAbortSubject.pipe(
                               He(s => {throw s}))),
                           Jn(() => {
                             !r && !o &&
                                 this.cancelNavigationTransition(
                                     i, '', dn.SupersededByNewNavigation),
                             this.currentTransition?.id === i.id &&
                                 (this.currentNavigation = null,
                                  this.currentTransition = null)
                           }),
                           sn(s => {
                             if (this.destroyed) return i.resolve(!1), mt;
                             if (o = !0, UE(s))
                               this.events.next(new Qi(
                                   i.id,
                                   this.urlSerializer.serialize(i.extractedUrl),
                                   s.message, s.cancellationCode)),
                                   EL(s) ?
                                   this.events.next(new Gs(
                                       s.url, s.navigationBehaviorOptions)) :
                                   i.resolve(!1);
                             else {
                               let a = new Ol(
                                   i.id,
                                   this.urlSerializer.serialize(i.extractedUrl),
                                   s, i.targetSnapshot ?? void 0);
                               try {
                                 let l =
                                     Kt(this.environmentInjector,
                                        () => this.navigationErrorHandler?.(a));
                                 if (l instanceof Fl) {
                                   let {message: c, cancellationCode: d} =
                                       Dm(this.urlSerializer, l);
                                   this.events.next(new Qi(
                                       i.id,
                                       this.urlSerializer.serialize(
                                           i.extractedUrl),
                                       c, d)),
                                       this.events.next(new Gs(
                                           l.redirectTo,
                                           l.navigationBehaviorOptions))
                                 } else
                                   throw this.events.next(a), s
                               } catch (l) {
                                 this.options.resolveNavigationPromiseOnError ?
                                     i.resolve(!1) :
                                     i.reject(l)
                               }
                             }
                             return mt
                           }))
                     }))
        }
        cancelNavigationTransition(e, i, r) {
          let o =
              new Qi(e.id, this.urlSerializer.serialize(e.extractedUrl), i, r);
          this.events.next(o), e.resolve(!1)
        }
        isUpdatingInternalState() {
          return this.currentTransition?.extractedUrl.toString() !==
              this.currentTransition?.currentUrlTree.toString()
        }
        isUpdatedBrowserUrl() {
          let e = this.urlHandlingStrategy.extract(
                  this.urlSerializer.parse(this.location.path(!0))),
              i = this.currentNavigation?.targetBrowserUrl ??
              this.currentNavigation?.extractedUrl;
          return e.toString() !== i?.toString() &&
              !this.currentNavigation?.extras.skipLocationChange
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function v2(n) {
  return n !== fm
}
var y2 = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: () => u(w2), providedIn: 'root'})
  } return n
})(),
    Y_ = class {
  shouldDetach(t) {
    return !1
  }
  store(t, e) {}
  shouldAttach(t) {
    return !1
  }
  retrieve(t) {
    return null
  }
  shouldReuseRoute(t, e) {
    return t.routeConfig === e.routeConfig
  }
}
, w2 = (() => {
    class n extends Y_ {
      static \u0275fac = (() => {
        let e;
        return function(r) {
          return (e || (e = Te(n)))(r || n)
        }
      })();
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  ek = (() => {
    class n {
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: () => u(x2), providedIn: 'root'})
    } return n
  })(),
  x2 = (() => {
    class n extends ek {
      location = u(Dr);
      urlSerializer = u(Bl);
      options = u($l, {optional: !0}) || {};
      canceledNavigationResolution =
          this.options.canceledNavigationResolution || 'replace';
      urlHandlingStrategy = u(J_);
      urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';
      currentUrlTree = new Yi;
      getCurrentUrlTree() {
        return this.currentUrlTree
      }
      rawUrlTree = this.currentUrlTree;
      getRawUrlTree() {
        return this.rawUrlTree
      }
      currentPageId = 0;
      lastSuccessfulId = -1;
      restoredState() {
        return this.location.getState()
      }
      get browserPageId() {
        return this.canceledNavigationResolution !== 'computed' ?
            this.currentPageId :
            this.restoredState()?.\u0275routerPageId ?? this.currentPageId
      }
      routerState = VE(null);
      getRouterState() {
        return this.routerState
      }
      stateMemento = this.createStateMemento();
      createStateMemento() {
        return {
          rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree,
              routerState: this.routerState
        }
      }
      registerNonRouterCurrentEntryChangeListener(e) {
        return this.location.subscribe(
            i => {i.type === 'popstate' && e(i.url, i.state)})
      }
      handleRouterEvent(e, i) {
        if (e instanceof qs)
          this.stateMemento = this.createStateMemento();
        else if (e instanceof Rr)
          this.rawUrlTree = i.initialUrl;
        else if (e instanceof bm) {
          if (this.urlUpdateStrategy === 'eager' &&
              !i.extras.skipLocationChange) {
            let r = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl);
            this.setBrowserUrl(i.targetBrowserUrl ?? r, i)
          }
        } else
          e instanceof Nl ?
              (this.currentUrlTree = i.finalUrl,
               this.rawUrlTree =
                   this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl),
               this.routerState = i.targetRouterState,
               this.urlUpdateStrategy === 'deferred' &&
                   !i.extras.skipLocationChange &&
                   this.setBrowserUrl(
                       i.targetBrowserUrl ?? this.rawUrlTree, i)) :
              e instanceof Qi &&
                  (e.code === dn.GuardRejected ||
                   e.code === dn.NoDataFromResolver) ?
              this.restoreHistory(i) :
              e instanceof Ol ? this.restoreHistory(i, !0) :
                                e instanceof Hn &&
                  (this.lastSuccessfulId = e.id,
                   this.currentPageId = this.browserPageId)
      }
      setBrowserUrl(e, i) {
        let r = e instanceof Yi ? this.urlSerializer.serialize(e) : e;
        if (this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl) {
          let o = this.browserPageId,
              s = y(y({}, i.extras.state), this.generateNgRouterState(i.id, o));
          this.location.replaceState(r, '', s)
        } else {
          let o =
              y(y({}, i.extras.state),
                this.generateNgRouterState(i.id, this.browserPageId + 1));
          this.location.go(r, '', o)
        }
      }
      restoreHistory(e, i = !1) {
        if (this.canceledNavigationResolution === 'computed') {
          let r = this.browserPageId, o = this.currentPageId - r;
          o !== 0 ? this.location.historyGo(o) :
                    this.currentUrlTree === e.finalUrl && o === 0 &&
                  (this.resetState(e), this.resetUrlToCurrentUrlTree())
        } else
          this.canceledNavigationResolution === 'replace' &&
              (i && this.resetState(e), this.resetUrlToCurrentUrlTree())
      }
      resetState(e) {
        this.routerState = this.stateMemento.routerState,
        this.currentUrlTree = this.stateMemento.currentUrlTree,
        this.rawUrlTree = this.urlHandlingStrategy.merge(
            this.currentUrlTree, e.finalUrl ?? this.rawUrlTree)
      }
      resetUrlToCurrentUrlTree() {
        this.location.replaceState(
            this.urlSerializer.serialize(this.rawUrlTree), '',
            this.generateNgRouterState(
                this.lastSuccessfulId, this.currentPageId))
      }
      generateNgRouterState(e, i) {
        return this.canceledNavigationResolution === 'computed' ?
            {navigationId: e, \u0275routerPageId: i} :
            {navigationId: e}
      }
      static \u0275fac = (() => {
        let e;
        return function(r) {
          return (e || (e = Te(n)))(r || n)
        }
      })();
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })();
function tk(n, t) {
  n.events
      .pipe(
          me(e => e instanceof Hn || e instanceof Qi || e instanceof Ol ||
                 e instanceof Rr),
          Q(e => e instanceof Hn || e instanceof Rr ? 0 :
                (e instanceof Qi ? e.code === dn.Redirect ||
                         e.code === dn.SupersededByNewNavigation :
                                   !1) ?
                                                      2 :
                                                      1),
          me(e => e !== 2), Ye(1))
      .subscribe(() => {t()})
}
var C2 = {
  paths: 'exact',
  fragment: 'ignored',
  matrixParams: 'ignored',
  queryParams: 'exact'
},
    D2 = {
      paths: 'subset',
      fragment: 'ignored',
      matrixParams: 'ignored',
      queryParams: 'subset'
    },
    Or = (() => {
      class n {
        get currentUrlTree() {
          return this.stateManager.getCurrentUrlTree()
        }
        get rawUrlTree() {
          return this.stateManager.getRawUrlTree()
        }
        disposed = !1;
        nonRouterCurrentEntryChangeSubscription;
        console = u(Og);
        stateManager = u(ek);
        options = u($l, {optional: !0}) || {};
        pendingTasks = u(zi);
        urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';
        navigationTransitions = u(eb);
        urlSerializer = u(Bl);
        location = u(Dr);
        urlHandlingStrategy = u(J_);
        _events = new I;
        get events() {
          return this._events
        }
        get routerState() {
          return this.stateManager.getRouterState()
        }
        navigated = !1;
        routeReuseStrategy = u(y2);
        onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';
        config = u(km, {optional: !0})?.flat() ?? [];
        componentInputBindingEnabled = !!u(Im, {optional: !0});
        constructor() {
          this.resetConfig(this.config),
              this.navigationTransitions.setupNavigations(this).subscribe({
                error: e => {
                  this.console.warn(e)
                }
              }),
              this.subscribeToNavigationEvents()
        }
        eventsSubscription = new ge;
        subscribeToNavigationEvents() {
          let e = this.navigationTransitions.events.subscribe(i => {
            try {
              let r = this.navigationTransitions.currentTransition,
                  o = this.navigationTransitions.currentNavigation;
              if (r !== null && o !== null) {
                if (this.stateManager.handleRouterEvent(i, o),
                    i instanceof Qi && i.code !== dn.Redirect &&
                        i.code !== dn.SupersededByNewNavigation)
                  this.navigated = !0;
                else if (i instanceof Hn)
                  this.navigated = !0;
                else if (i instanceof Gs) {
                  let s = i.navigationBehaviorOptions,
                      a = this.urlHandlingStrategy.merge(
                          i.url, r.currentRawUrl),
                      l =
                          y({
                            browserUrl: r.extras.browserUrl,
                            info: r.extras.info,
                            skipLocationChange: r.extras.skipLocationChange,
                            replaceUrl: r.extras.replaceUrl ||
                                this.urlUpdateStrategy === 'eager' ||
                                v2(r.source)
                          },
                            s);
                  this.scheduleNavigation(a, fm, null, l, {
                    resolve: r.resolve,
                    reject: r.reject,
                    promise: r.promise
                  })
                }
              }
              k2(i) && this._events.next(i)
            } catch (r) {
              this.navigationTransitions.transitionAbortSubject.next(r)
            }
          });
          this.eventsSubscription.add(e)
        }
        resetRootComponentType(e) {
          this.routerState.root.component = e,
          this.navigationTransitions.rootComponentType = e
        }
        initialNavigation() {
          this.setUpLocationChangeListener(),
              this.navigationTransitions.hasRequestedNavigation ||
              this.navigateToSyncWithBrowser(
                  this.location.path(!0), fm, this.stateManager.restoredState())
        }
        setUpLocationChangeListener() {
          this.nonRouterCurrentEntryChangeSubscription ??=
              this.stateManager.registerNonRouterCurrentEntryChangeListener(
                  (e, i) => {setTimeout(
                      () => {this.navigateToSyncWithBrowser(e, 'popstate', i)},
                      0)})
        }
        navigateToSyncWithBrowser(e, i, r) {
          let o = {replaceUrl: !0}, s = r?.navigationId ? r : null;
          if (r) {
            let l = y({}, r);
            delete l.navigationId, delete l.\u0275routerPageId,
                Object.keys(l).length !== 0 && (o.state = l)
          }
          let a = this.parseUrl(e);
          this.scheduleNavigation(a, i, s, o)
        }
        get url() {
          return this.serializeUrl(this.currentUrlTree)
        }
        getCurrentNavigation() {
          return this.navigationTransitions.currentNavigation
        }
        get lastSuccessfulNavigation() {
          return this.navigationTransitions.lastSuccessfulNavigation
        }
        resetConfig(e) {
          this.config = e.map(K_), this.navigated = !1
        }
        ngOnDestroy() {
          this.dispose()
        }
        dispose() {
          this._events.unsubscribe(), this.navigationTransitions.complete(),
              this.nonRouterCurrentEntryChangeSubscription &&
              (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),
               this.nonRouterCurrentEntryChangeSubscription = void 0),
              this.disposed = !0, this.eventsSubscription.unsubscribe()
        }
        createUrlTree(e, i = {}) {
          let {
            relativeTo: r,
            queryParams: o,
            fragment: s,
            queryParamsHandling: a,
            preserveFragment: l
          } = i,
         c = l ? this.currentUrlTree.fragment : s, d = null;
          switch (a ?? this.options.defaultQueryParamsHandling) {
            case 'merge':
              d = y(y({}, this.currentUrlTree.queryParams), o);
              break;
            case 'preserve':
              d = this.currentUrlTree.queryParams;
              break;
            default:
              d = o || null
          }
          d !== null && (d = this.removeEmptyProps(d));
          let m;
          try {
            let p = r ? r.snapshot : this.routerState.snapshot.root;
            m = NE(p)
          } catch {
            (typeof e[0] != 'string' || e[0][0] !== '/') && (e = []),
                m = this.currentUrlTree.root
          }
          return PE(m, e, d, c ?? null)
        }
        navigateByUrl(e, i = {skipLocationChange: !1}) {
          let r = Rl(e) ? e : this.parseUrl(e),
              o = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
          return this.scheduleNavigation(o, fm, null, i)
        }
        navigate(e, i = {skipLocationChange: !1}) {
          return E2(e), this.navigateByUrl(this.createUrlTree(e, i), i)
        }
        serializeUrl(e) {
          return this.urlSerializer.serialize(e)
        }
        parseUrl(e) {
          try {
            return this.urlSerializer.parse(e)
          } catch {
            return this.urlSerializer.parse('/')
          }
        }
        isActive(e, i) {
          let r;
          if (i === !0     ? r = y({}, C2) :
                  i === !1 ? r = y({}, D2) :
                             r = i,
              Rl(e))
            return pE(this.currentUrlTree, e, r);
          let o = this.parseUrl(e);
          return pE(this.currentUrlTree, o, r)
        }
        removeEmptyProps(e) {
          return Object.entries(e).reduce(
              (i, [r, o]) => (o != null && (i[r] = o), i), {})
        }
        scheduleNavigation(e, i, r, o, s) {
          if (this.disposed) return Promise.resolve(!1);
          let a, l, c;
          s ? (a = s.resolve, l = s.reject, c = s.promise) :
              c = new Promise((m, p) => {a = m, l = p});
          let d = this.pendingTasks.add();
          return tk(this,
                    () => {queueMicrotask(() => this.pendingTasks.remove(d))}),
                 this.navigationTransitions.handleNavigationRequest({
                   source: i,
                   restoredState: r,
                   currentUrlTree: this.currentUrlTree,
                   currentRawUrl: this.currentUrlTree,
                   rawUrl: e,
                   extras: o,
                   resolve: a,
                   reject: l,
                   promise: c,
                   currentSnapshot: this.routerState.snapshot,
                   currentRouterState: this.routerState
                 }),
                 c.catch(m => Promise.reject(m))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function E2(n) {
  for (let t = 0; t < n.length; t++)
    if (n[t] == null) throw new S(4008, !1)
}
function k2(n) {
  return !(n instanceof Nl) && !(n instanceof Gs)
}
var Sm = class {};
var S2 = (() => {
  class n {
    router;
    injector;
    preloadingStrategy;
    loader;
    subscription;
    constructor(e, i, r, o, s) {
      this.router = e, this.injector = r, this.preloadingStrategy = o,
      this.loader = s
    }
    setUpPreloading() {
      this.subscription =
          this.router.events
              .pipe(me(e => e instanceof Hn), Oi(() => this.preload()))
              .subscribe(() => {})
    }
    preload() {
      return this.processRoutes(this.injector, this.router.config)
    }
    ngOnDestroy() {
      this.subscription && this.subscription.unsubscribe()
    }
    processRoutes(e, i) {
      let r = [];
      for (let o of i) {
        o.providers && !o._injector &&
            (o._injector = Cu(o.providers, e, `Route: ${o.path}`));
        let s = o._injector ?? e, a = o._loadedInjector ?? s;
        (o.loadChildren && !o._loadedRoutes && o.canLoad === void 0 ||
         o.loadComponent && !o._loadedComponent) &&
            r.push(this.preloadConfig(s, o)),
            (o.children || o._loadedRoutes) &&
            r.push(this.processRoutes(a, o.children ?? o._loadedRoutes))
      }
      return Ue(r).pipe(cr())
    }
    preloadConfig(e, i) {
      return this.preloadingStrategy.preload(i, () => {
        let r;
        i.loadChildren&& i.canLoad === void 0 ?
            r = this.loader.loadChildren(e, i) :
            r = G(null);
        let o = r.pipe(
            ot(s => s === null ?
                   G(void 0) :
                   (i._loadedRoutes = s.routes, i._loadedInjector = s.injector,
                    this.processRoutes(s.injector ?? e, s.routes))));
        if (i.loadComponent && !i._loadedComponent) {
          let s = this.loader.loadComponent(i);
          return Ue([o, s]).pipe(cr())
        } else
          return o
      })
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(Or), A(Mu), A(_t), A(Sm), A(X_))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})(),
    nk = new w(''),
    I2 = (() => {
      class n {
        urlSerializer;
        transitions;
        viewportScroller;
        zone;
        options;
        routerEventsSubscription;
        scrollEventsSubscription;
        lastId = 0;
        lastSource = 'imperative';
        restoredId = 0;
        store = {};
        constructor(e, i, r, o, s = {}) {
          this.urlSerializer = e, this.transitions = i,
          this.viewportScroller = r, this.zone = o, this.options = s,
          s.scrollPositionRestoration ||= 'disabled',
          s.anchorScrolling ||= 'disabled'
        }
        init() {
          this.options.scrollPositionRestoration !== 'disabled' &&
              this.viewportScroller.setHistoryScrollRestoration('manual'),
              this.routerEventsSubscription = this.createScrollEvents(),
              this.scrollEventsSubscription = this.consumeScrollEvents()
        }
        createScrollEvents() {
          return this.transitions.events.subscribe(
              e => {
                  e instanceof qs ?
                      (this.store[this.lastId] =
                           this.viewportScroller.getScrollPosition(),
                       this.lastSource = e.navigationTrigger,
                       this.restoredId =
                           e.restoredState ? e.restoredState.navigationId : 0) :
                      e instanceof Hn ?
                      (this.lastId = e.id,
                       this.scheduleScrollEvent(
                           e,
                           this.urlSerializer.parse(e.urlAfterRedirects)
                               .fragment)) :
                      e instanceof Rr &&
                          e.code === _m.IgnoredSameUrlNavigation &&
                          (this.lastSource = void 0, this.restoredId = 0,
                           this.scheduleScrollEvent(
                               e, this.urlSerializer.parse(e.url).fragment))})
        }
        consumeScrollEvents() {
          return this.transitions.events.subscribe(
              e => {
                  e instanceof vm &&
                  (e.position ?
                       this.options.scrollPositionRestoration === 'top' ?
                       this.viewportScroller.scrollToPosition([0, 0]) :
                       this.options.scrollPositionRestoration === 'enabled' &&
                               this.viewportScroller.scrollToPosition(
                                   e.position) :
                       e.anchor && this.options.anchorScrolling === 'enabled' ?
                       this.viewportScroller.scrollToAnchor(e.anchor) :
                       this.options.scrollPositionRestoration !== 'disabled' &&
                           this.viewportScroller.scrollToPosition([0, 0]))})
        }
        scheduleScrollEvent(e, i) {
          this.zone.runOutsideAngular(
              () => {setTimeout(
                  () => {this.zone.run(
                      () => {this.transitions.events.next(new vm(
                          e,
                          this.lastSource === 'popstate' ?
                              this.store[this.restoredId] :
                              null,
                          i))})},
                  0)})
        }
        ngOnDestroy() {
          this.routerEventsSubscription?.unsubscribe(),
              this.scrollEventsSubscription?.unsubscribe()
        }
        static \u0275fac = function(i) {
          sC()
        };
        static \u0275prov = C({token: n, factory: n.\u0275fac})
      } return n
    })();
function M2(n) {
  return n.routerState.root
}
function Wl(n, t) {
  return {
    \u0275kind: n, \u0275providers: t
  }
}
function T2() {
  let n = u(he);
  return t => {
    let e = n.get(Yt);
    if (t !== e.components[0]) return;
    let i = n.get(Or), r = n.get(ik);
    n.get(tb) === 1 && i.initialNavigation(),
        n.get(rk, null, ke.Optional)?.setUpPreloading(),
        n.get(nk, null, ke.Optional)?.init(),
        i.resetRootComponentType(e.componentTypes[0]),
        r.closed || (r.next(), r.complete(), r.unsubscribe())
  }
}
var ik = new w('', {factory: () => new I}),
    tb = new w('', {providedIn: 'root', factory: () => 1});
function R2() {
  return Wl(2, [
    {provide: tb, useValue: 0}, {
      provide: Su,
      multi: !0,
      deps: [he],
      useFactory: t => {
        let e = t.get(dD, Promise.resolve());
        return () => e.then(() => new Promise(i => {
                              let r = t.get(Or), o = t.get(ik);
                              tk(r, () => {i(!0)}),
                                  t.get(eb).afterPreactivation = () =>
                                      (i(!0), o.closed ? G(void 0) : o),
                                  r.initialNavigation()
                            }))
      }
    }
  ])
}
function A2() {
  return Wl(3, [
    {
      provide: Su,
      multi: !0,
      useFactory: () => {
        let t = u(Or);
        return () => {
          t.setUpLocationChangeListener()
        }
      }
    },
    {provide: tb, useValue: 2}
  ])
}
var rk = new w('');
function O2(n) {
  return Wl(0, [{provide: rk, useExisting: S2}, {provide: Sm, useExisting: n}])
}
function N2() {
  return Wl(8, [vE, {provide: Im, useExisting: vE}])
}
function P2(n) {
  let t = [
    {provide: KE, useValue: _2}, {
      provide: XE,
      useValue: y({skipNextTransition: !!n?.skipInitialTransition}, n)
    }
  ];
  return Wl(9, t)
}
var F2 =
        [
          Dr, {provide: Bl, useClass: Ws}, Or, Hl,
          {provide: Ar, useFactory: M2, deps: [Or]}, X_, []
        ],
    nb = (() => {
      class n {
        constructor() {}
        static forRoot(e, i) {
          return {
            ngModule: n, providers: [
              F2, [], {provide: km, multi: !0, useValue: e}, [],
              i?.errorHandler ? {provide: JE, useValue: i.errorHandler} : [],
              {provide: $l, useValue: i || {}}, i?.useHash ? V2() : j2(), L2(),
              i?.preloadingStrategy ? O2(i.preloadingStrategy).\u0275providers :
                                      [],
              i?.initialNavigation ? B2(i) : [],
              i?.bindToComponentInputs ? N2().\u0275providers : [],
              i?.enableViewTransitions ? P2().\u0275providers : [], z2()
            ]
          }
        }
        static forChild(e) {
          return {
            ngModule: n, providers: [{provide: km, multi: !0, useValue: e}]
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({})
      } return n
    })();
function L2() {
  return {
    provide: nk, useFactory: () => {
      let n = u(pD), t = u(U), e = u($l), i = u(eb), r = u(Bl);
      return e.scrollOffset && n.setOffset(e.scrollOffset),
             new I2(r, i, n, t, e)
    }
  }
}
function V2() {
  return {
    provide: So, useClass: mD
  }
}
function j2() {
  return {
    provide: So, useClass: Gg
  }
}
function B2(n) {
  return [
    n.initialNavigation === 'disabled' ? A2().\u0275providers : [],
    n.initialNavigation === 'enabledBlocking' ? R2().\u0275providers : []
  ]
}
var CE = new w('');
function z2() {
  return [
    {provide: CE, useFactory: T2}, {provide: Iu, multi: !0, useExisting: CE}
  ]
}
var rb;
try {
  rb = typeof Intl < 'u' && Intl.v8BreakIterator
} catch {
  rb = !1
}
var Ie = (() => {
  class n {
    _platformId = u(Fn);
    isBrowser = this._platformId ? qi(this._platformId) :
                                   typeof document == 'object' && !!document;
    EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
    TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
    BLINK = this.isBrowser && !!(window.chrome || rb) && typeof CSS < 'u' &&
        !this.EDGE && !this.TRIDENT;
    WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) &&
        !this.BLINK && !this.EDGE && !this.TRIDENT;
    IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&
        !('MSStream' in window);
    FIREFOX =
        this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
    ANDROID =
        this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
    SAFARI =
        this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
    constructor() {}
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
var Zs, ok = [
  'color', 'button', 'checkbox', 'date',   'datetime-local', 'email',
  'file',  'hidden', 'image',    'month',  'number',         'password',
  'radio', 'range',  'reset',    'search', 'submit',         'tel',
  'text',  'time',   'url',      'week'
];
function ob() {
  if (Zs) return Zs;
  if (typeof document != 'object' || !document) return Zs = new Set(ok), Zs;
  let n = document.createElement('input');
  return Zs =
             new Set(ok.filter(t => (n.setAttribute('type', t), n.type === t))),
         Zs
}
var ql;
function H2() {
  if (ql == null && typeof window < 'u') try {
      window.addEventListener(
          'test', null,
          Object.defineProperty({}, 'passive', {get: () => ql = !0}))
    } finally {
      ql = ql || !1
    }
  return ql
}
function _i(n) {
  return H2() ? n : !!n.capture
}
var Un = function(n) {
  return n[n.NORMAL = 0] = 'NORMAL', n[n.NEGATED = 1] = 'NEGATED',
                      n[n.INVERTED = 2] = 'INVERTED', n
}(Un || {}), Tm, No;
function Rm() {
  if (No == null) {
    if (typeof document != 'object' || !document ||
        typeof Element != 'function' || !Element)
      return No = !1, No;
    if ('scrollBehavior' in document.documentElement.style)
      No = !0;
    else {
      let n = Element.prototype.scrollTo;
      n ? No = !/\{\s*\[native code\]\s*\}/.test(n.toString()) : No = !1
    }
  }
  return No
}
function Ks() {
  if (typeof document != 'object' || !document) return Un.NORMAL;
  if (Tm == null) {
    let n = document.createElement('div'), t = n.style;
    n.dir = 'rtl', t.width = '1px', t.overflow = 'auto',
    t.visibility = 'hidden', t.pointerEvents = 'none', t.position = 'absolute';
    let e = document.createElement('div'), i = e.style;
    i.width = '2px', i.height = '1px', n.appendChild(e),
    document.body.appendChild(n), Tm = Un.NORMAL,
    n.scrollLeft === 0 &&
        (n.scrollLeft = 1, Tm = n.scrollLeft === 0 ? Un.NEGATED : Un.INVERTED),
    n.remove()
  }
  return Tm
}
var ib;
function U2() {
  if (ib == null) {
    let n = typeof document < 'u' ? document.head : null;
    ib = !!(n && (n.createShadowRoot || n.attachShadow))
  }
  return ib
}
function sk(n) {
  if (U2()) {
    let t = n.getRootNode ? n.getRootNode() : null;
    if (typeof ShadowRoot < 'u' && ShadowRoot && t instanceof ShadowRoot)
      return t
  }
  return null
}
function Xs() {
  let n = typeof document < 'u' && document ? document.activeElement : null;
  for (; n && n.shadowRoot;) {
    let t = n.shadowRoot.activeElement;
    if (t === n) break;
    n = t
  }
  return n
}
function un(n) {
  return n.composedPath ? n.composedPath()[0] : n.target
}
function sb() {
  return typeof __karma__ < 'u' && !!__karma__ ||
      typeof jasmine < 'u' && !!jasmine || typeof jest < 'u' && !!jest ||
      typeof Mocha < 'u' && !!Mocha
}
function ab(n, t, e, i, r) {
  let o = parseInt(Lg.major), s = parseInt(Lg.minor);
  return o > 19 || o === 19 && s > 0 || o === 0 && s === 0 ?
      n.listen(t, e, i, r) :
      (t.addEventListener(e, i, r), () => {t.removeEventListener(e, i, r)})
}
var Am = new WeakMap,
    lt = (() => {
      class n {
        _appRef;
        _injector = u(he);
        _environmentInjector = u(_t);
        load(e) {
          let i = this._appRef = this._appRef || this._injector.get(Yt),
              r = Am.get(i);
          r ||
              (r = {loaders: new Set, refs: []}, Am.set(i, r),
               i.onDestroy(() => {
                 Am.get(i)?.refs.forEach(o => o.destroy()),
                 Am.delete(i)
               })),
              r.loaders.has(e) ||
              (r.loaders.add(e),
               r.refs.push(
                   Au(e, {environmentInjector: this._environmentInjector})))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    Gl = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['ng-component']],
          exportAs: ['cdkVisuallyHidden'],
          decls: 0,
          vars: 0,
          template: function(i, r) {},
          styles: [
            '.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
function wt(n, ...t) {
  return t.length ? t.some(e => n[e]) :
                    n.altKey || n.shiftKey || n.ctrlKey || n.metaKey
}
function Je(n) {
  return n != null && `${n}` != 'false'
}
function mn(n, t = 0) {
  return lb(n) ? Number(n) : arguments.length === 2 ? t : 0
}
function lb(n) {
  return !isNaN(parseFloat(n)) && !isNaN(Number(n))
}
function Js(n) {
  return Array.isArray(n) ? n : [n]
}
function ct(n) {
  return n == null ? '' : typeof n == 'string' ? n : `${n}px`
}
function nn(n) {
  return n instanceof L ? n.nativeElement : n
}
function $2(n) {
  if (n.type === 'characterData' && n.target instanceof Comment) return !0;
  if (n.type === 'childList') {
    for (let t = 0; t < n.addedNodes.length; t++)
      if (!(n.addedNodes[t] instanceof Comment)) return !1;
    for (let t = 0; t < n.removedNodes.length; t++)
      if (!(n.removedNodes[t] instanceof Comment)) return !1;
    return !0
  }
  return !1
}
var ak = (() => {
  class n {
    create(e) {
      return typeof MutationObserver > 'u' ? null : new MutationObserver(e)
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})(),
    lk = (() => {
      class n {
        _mutationObserverFactory = u(ak);
        _observedElements = new Map;
        _ngZone = u(U);
        constructor() {}
        ngOnDestroy() {
          this._observedElements.forEach((e, i) => this._cleanupObserver(i))
        }
        observe(e) {
          let i = nn(e);
          return new ie(r => {
            let s =
                this._observeElement(i)
                    .pipe(Q(a => a.filter(l => !$2(l))), me(a => !!a.length))
                    .subscribe(a => {this._ngZone.run(() => {r.next(a)})});
            return () => {
              s.unsubscribe(), this._unobserveElement(i)
            }
          })
        }
        _observeElement(e) {
          return this._ngZone.runOutsideAngular(() => {
            if (this._observedElements.has(e))
              this._observedElements.get(e).count++;
            else {
              let i = new I,
                  r = this._mutationObserverFactory.create(o => i.next(o));
              r &&
                  r.observe(e, {characterData: !0, childList: !0, subtree: !0}),
                  this._observedElements.set(
                      e, {observer: r, stream: i, count: 1})
            }
            return this._observedElements.get(e).stream
          })
        }
        _unobserveElement(e) {
          this._observedElements.has(e) &&
              (this._observedElements.get(e).count--,
               this._observedElements.get(e).count || this._cleanupObserver(e))
        }
        _cleanupObserver(e) {
          if (this._observedElements.has(e)) {
            let {observer: i, stream: r} = this._observedElements.get(e);
            i && i.disconnect(), r.complete(), this._observedElements.delete(e)
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    Om = (() => {
      class n {
        _contentObserver = u(lk);
        _elementRef = u(L);
        event = new H;
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          this._disabled = e,
          this._disabled ? this._unsubscribe() : this._subscribe()
        }
        _disabled = !1;
        get debounce() {
          return this._debounce
        }
        set debounce(e) {
          this._debounce = mn(e), this._subscribe()
        }
        _debounce;
        _currentSubscription = null;
        constructor() {}
        ngAfterContentInit() {
          !this._currentSubscription && !this.disabled && this._subscribe()
        }
        ngOnDestroy() {
          this._unsubscribe()
        }
        _subscribe() {
          this._unsubscribe();
          let e = this._contentObserver.observe(this._elementRef);
          this._currentSubscription =
              (this.debounce ? e.pipe(Tn(this.debounce)) : e)
                  .subscribe(this.event)
        }
        _unsubscribe() {
          this._currentSubscription?.unsubscribe()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdkObserveContent', '']],
          inputs: {
            disabled: [2, 'cdkObserveContentDisabled', 'disabled', q],
            debounce: 'debounce'
          },
          outputs: {event: 'cdkObserveContent'},
          exportAs: ['cdkObserveContent']
        })
      } return n
    })(),
    ea = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({providers: [ak]})
      } return n
    })();
var ck = new Set, Po,
    W2 = (() => {
      class n {
        _platform = u(Ie);
        _nonce = u(il, {optional: !0});
        _matchMedia;
        constructor() {
          this._matchMedia = this._platform.isBrowser && window.matchMedia ?
              window.matchMedia.bind(window) :
              G2
        }
        matchMedia(e) {
          return (this._platform.WEBKIT || this._platform.BLINK) &&
                     q2(e, this._nonce),
                 this._matchMedia(e)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function q2(n, t) {
  if (!ck.has(n)) try {
      Po ||
          (Po = document.createElement('style'),
           t && Po.setAttribute('nonce', t),
           Po.setAttribute('type', 'text/css'), document.head.appendChild(Po)),
          Po.sheet &&
          (Po.sheet.insertRule(`@media ${n} {body{ }}`, 0), ck.add(n))
    } catch (e) {
      console.error(e)
    }
}
function G2(n) {
  return {
    matches: n === 'all' || n === '', media: n,
        addListener: () => {}, removeListener: () => {}
  }
}
var uk = (() => {
  class n {
    _mediaMatcher = u(W2);
    _zone = u(U);
    _queries = new Map;
    _destroySubject = new I;
    constructor() {}
    ngOnDestroy() {
      this._destroySubject.next(), this._destroySubject.complete()
    }
    isMatched(e) {
      return dk(Js(e)).some(r => this._registerQuery(r).mql.matches)
    }
    observe(e) {
      let r = dk(Js(e)).map(s => this._registerQuery(s).observable), o = Mn(r);
      return o = dr(o.pipe(Ye(1)), o.pipe(ro(1), Tn(0))), o.pipe(Q(s => {
        let a = {matches: !1, breakpoints: {}};
        return s.forEach(({matches: l, query: c}) => {
          a.matches = a.matches || l,
          a.breakpoints[c] = l
        }),
               a
      }))
    }
    _registerQuery(e) {
      if (this._queries.has(e)) return this._queries.get(e);
      let i = this._mediaMatcher.matchMedia(e), o = {
        observable:
            new ie(s => {
              let a = l => this._zone.run(() => s.next(l));
              return i.addListener(a), () => {
                i.removeListener(a)
              }
            })
                .pipe(
                    Xe(i), Q(({matches: s}) => ({query: e, matches: s})),
                    re(this._destroySubject)),
        mql: i
      };
      return this._queries.set(e, o), o
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function dk(n) {
  return n.map(t => t.split(','))
      .reduce((t, e) => t.concat(e))
      .map(t => t.trim())
}
var gk = ' ';
function bb(n, t, e) {
  let i = Lm(n, t);
  e = e.trim(),
  !i.some(r => r.trim() === e) && (i.push(e), n.setAttribute(t, i.join(gk)))
}
function Um(n, t, e) {
  let i = Lm(n, t);
  e = e.trim();
  let r = i.filter(o => o !== e);
  r.length ? n.setAttribute(t, r.join(gk)) : n.removeAttribute(t)
}
function Lm(n, t) {
  return n.getAttribute(t)?.match(/\S+/g) ?? []
}
var _k = 'cdk-describedby-message', Nm = 'cdk-describedby-host', mb = 0,
    bk = (() => {
      class n {
        _platform = u(Ie);
        _document = u(ce);
        _messageRegistry = new Map;
        _messagesContainer = null;
        _id = `${mb++}`;
        constructor() {
          u(lt).load(Gl), this._id = u(Ms) + '-' + mb++
        }
        describe(e, i, r) {
          if (!this._canBeDescribed(e, i)) return;
          let o = cb(i, r);
          typeof i != 'string' ?
              (mk(i, this._id),
               this._messageRegistry.set(
                   o, {messageElement: i, referenceCount: 0})) :
              this._messageRegistry.has(o) || this._createMessageElement(i, r),
              this._isElementDescribedByMessage(e, o) ||
              this._addMessageReference(e, o)
        }
        removeDescription(e, i, r) {
          if (!i || !this._isElementNode(e)) return;
          let o = cb(i, r);
          if (this._isElementDescribedByMessage(e, o) &&
                  this._removeMessageReference(e, o),
              typeof i == 'string') {
            let s = this._messageRegistry.get(o);
            s && s.referenceCount === 0 && this._deleteMessageElement(o)
          }
          this._messagesContainer?.childNodes.length === 0 &&
              (this._messagesContainer.remove(), this._messagesContainer = null)
        }
        ngOnDestroy() {
          let e = this._document.querySelectorAll(`[${Nm}="${this._id}"]`);
          for (let i = 0; i < e.length; i++)
            this._removeCdkDescribedByReferenceIds(e[i]),
                e[i].removeAttribute(Nm);
          this._messagesContainer?.remove(), this._messagesContainer = null,
                                             this._messageRegistry.clear()
        }
        _createMessageElement(e, i) {
          let r = this._document.createElement('div');
          mk(r, this._id), r.textContent = e, i && r.setAttribute('role', i),
                           this._createMessagesContainer(),
                           this._messagesContainer.appendChild(r),
                           this._messageRegistry.set(
                               cb(e, i), {messageElement: r, referenceCount: 0})
        }
        _deleteMessageElement(e) {
          this._messageRegistry.get(e)?.messageElement?.remove(),
              this._messageRegistry.delete(e)
        }
        _createMessagesContainer() {
          if (this._messagesContainer) return;
          let e = 'cdk-describedby-message-container',
              i = this._document.querySelectorAll(`.${e}[platform="server"]`);
          for (let o = 0; o < i.length; o++) i[o].remove();
          let r = this._document.createElement('div');
          r.style.visibility = 'hidden', r.classList.add(e),
          r.classList.add('cdk-visually-hidden'),
          this._platform.isBrowser || r.setAttribute('platform', 'server'),
          this._document.body.appendChild(r), this._messagesContainer = r
        }
        _removeCdkDescribedByReferenceIds(e) {
          let i = Lm(e, 'aria-describedby').filter(r => r.indexOf(_k) != 0);
          e.setAttribute('aria-describedby', i.join(' '))
        }
        _addMessageReference(e, i) {
          let r = this._messageRegistry.get(i);
          bb(e, 'aria-describedby', r.messageElement.id),
              e.setAttribute(Nm, this._id), r.referenceCount++
        }
        _removeMessageReference(e, i) {
          let r = this._messageRegistry.get(i);
          r.referenceCount--, Um(e, 'aria-describedby', r.messageElement.id),
              e.removeAttribute(Nm)
        }
        _isElementDescribedByMessage(e, i) {
          let r = Lm(e, 'aria-describedby'), o = this._messageRegistry.get(i),
              s = o && o.messageElement.id;
          return !!s && r.indexOf(s) != -1
        }
        _canBeDescribed(e, i) {
          if (!this._isElementNode(e)) return !1;
          if (i && typeof i == 'object') return !0;
          let r = i == null ? '' : `${i}`.trim(),
              o = e.getAttribute('aria-label');
          return r ? !o || o.trim() !== r : !1
        }
        _isElementNode(e) {
          return e.nodeType === this._document.ELEMENT_NODE
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function cb(n, t) {
  return typeof n == 'string' ? `${t || ''}/${n}` : n
}
function mk(n, t) {
  n.id || (n.id = `${_k}-${t}-${mb++}`)
}
var aV = 200, hb = class {
  _letterKeyStream = new I;
  _items = [];
  _selectedItemIndex = -1;
  _pressedLetters = [];
  _skipPredicateFn;
  _selectedItem = new I;
  selectedItem = this._selectedItem;
  constructor(t, e) {
    let i = typeof e?.debounceInterval == 'number' ? e.debounceInterval : aV;
    e?.skipPredicate && (this._skipPredicateFn = e.skipPredicate),
        this.setItems(t), this._setupKeyHandler(i)
  }
  destroy() {
    this._pressedLetters = [], this._letterKeyStream.complete(),
    this._selectedItem.complete()
  }
  setCurrentSelectedItemIndex(t) {
    this._selectedItemIndex = t
  }
  setItems(t) {
    this._items = t
  }
  handleKey(t) {
    let e = t.keyCode;
    t.key && t.key.length === 1 ?
        this._letterKeyStream.next(t.key.toLocaleUpperCase()) :
        (e >= 65 && e <= 90 || e >= 48 && e <= 57) &&
            this._letterKeyStream.next(String.fromCharCode(e))
  }
  isTyping() {
    return this._pressedLetters.length > 0
  }
  reset() {
    this._pressedLetters = []
  }
  _setupKeyHandler(t) {
    this._letterKeyStream
        .pipe(
            He(e => this._pressedLetters.push(e)), Tn(t),
            me(() => this._pressedLetters.length > 0),
            Q(() => this._pressedLetters.join('').toLocaleUpperCase()))
        .subscribe(e => {
          for (let i = 1; i < this._items.length + 1; i++) {
            let r = (this._selectedItemIndex + i) % this._items.length,
                o = this._items[r];
            if (!this._skipPredicateFn?.(o) &&
                o.getLabel?.().toLocaleUpperCase().trim().indexOf(e) === 0) {
              this._selectedItem.next(o);
              break
            }
          }
          this._pressedLetters = []
        })
  }
}
, Vm = class {
  _items;
  _activeItemIndex = -1;
  _activeItem = Jt(null);
  _wrap = !1;
  _typeaheadSubscription = ge.EMPTY;
  _itemChangesSubscription;
  _vertical = !0;
  _horizontal;
  _allowedModifierKeys = [];
  _homeAndEnd = !1;
  _pageUpAndDown = {enabled: !1, delta: 10};
  _effectRef;
  _typeahead;
  _skipPredicateFn = t => t.disabled;
  constructor(t, e) {
    this._items = t,
    t instanceof si ?
        this._itemChangesSubscription =
            t.changes.subscribe(i => this._itemsChanged(i.toArray())) :
        br(t) &&
            (this._effectRef = ul(() => this._itemsChanged(t()), {injector: e}))
  }
  tabOut = new I;
  change = new I;
  skipPredicate(t) {
    return this._skipPredicateFn = t, this
  }
  withWrap(t = !0) {
    return this._wrap = t, this
  }
  withVerticalOrientation(t = !0) {
    return this._vertical = t, this
  }
  withHorizontalOrientation(t) {
    return this._horizontal = t, this
  }
  withAllowedModifierKeys(t) {
    return this._allowedModifierKeys = t, this
  }
  withTypeAhead(t = 200) {
    this._typeaheadSubscription.unsubscribe();
    let e = this._getItemsArray();
    return this._typeahead = new hb(e, {
             debounceInterval: typeof t == 'number' ? t : void 0,
             skipPredicate: i => this._skipPredicateFn(i)
           }),
           this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(
               i => {this.setActiveItem(i)}),
           this
  }
  cancelTypeahead() {
    return this._typeahead?.reset(), this
  }
  withHomeAndEnd(t = !0) {
    return this._homeAndEnd = t, this
  }
  withPageUpDown(t = !0, e = 10) {
    return this._pageUpAndDown = {enabled: t, delta: e}, this
  }
  setActiveItem(t) {
    let e = this._activeItem();
    this.updateActiveItem(t),
        this._activeItem() !== e && this.change.next(this._activeItemIndex)
  }
  onKeydown(t) {
    let e = t.keyCode, r = [
      'altKey', 'ctrlKey', 'metaKey', 'shiftKey'
    ].every(o => !t[o] || this._allowedModifierKeys.indexOf(o) > -1);
    switch (e) {
      case 9:
        this.tabOut.next();
        return;
      case 40:
        if (this._vertical && r) {
          this.setNextItemActive();
          break
        } else
          return;
      case 38:
        if (this._vertical && r) {
          this.setPreviousItemActive();
          break
        } else
          return;
      case 39:
        if (this._horizontal && r) {
          this._horizontal === 'rtl' ? this.setPreviousItemActive() :
                                       this.setNextItemActive();
          break
        } else
          return;
      case 37:
        if (this._horizontal && r) {
          this._horizontal === 'rtl' ? this.setNextItemActive() :
                                       this.setPreviousItemActive();
          break
        } else
          return;
      case 36:
        if (this._homeAndEnd && r) {
          this.setFirstItemActive();
          break
        } else
          return;
      case 35:
        if (this._homeAndEnd && r) {
          this.setLastItemActive();
          break
        } else
          return;
      case 33:
        if (this._pageUpAndDown.enabled && r) {
          let o = this._activeItemIndex - this._pageUpAndDown.delta;
          this._setActiveItemByIndex(o > 0 ? o : 0, 1);
          break
        } else
          return;
      case 34:
        if (this._pageUpAndDown.enabled && r) {
          let o = this._activeItemIndex + this._pageUpAndDown.delta,
              s = this._getItemsArray().length;
          this._setActiveItemByIndex(o < s ? o : s - 1, -1);
          break
        } else
          return;
      default:
        (r || wt(t, 'shiftKey')) && this._typeahead?.handleKey(t);
        return
    }
    this._typeahead?.reset(), t.preventDefault()
  }
  get activeItemIndex() {
    return this._activeItemIndex
  }
  get activeItem() {
    return this._activeItem()
  }
  isTyping() {
    return !!this._typeahead && this._typeahead.isTyping()
  }
  setFirstItemActive() {
    this._setActiveItemByIndex(0, 1)
  }
  setLastItemActive() {
    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1)
  }
  setNextItemActive() {
    this._activeItemIndex < 0 ? this.setFirstItemActive() :
                                this._setActiveItemByDelta(1)
  }
  setPreviousItemActive() {
    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() :
                                              this._setActiveItemByDelta(-1)
  }
  updateActiveItem(t) {
    let e = this._getItemsArray(), i = typeof t == 'number' ? t : e.indexOf(t),
        r = e[i];
    this._activeItem.set(r ?? null),
        this._activeItemIndex = i,
        this._typeahead?.setCurrentSelectedItemIndex(i)
  }
  destroy() {
    this._typeaheadSubscription.unsubscribe(),
        this._itemChangesSubscription?.unsubscribe(),
        this._effectRef?.destroy(), this._typeahead?.destroy(),
        this.tabOut.complete(), this.change.complete()
  }
  _setActiveItemByDelta(t) {
    this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t)
  }
  _setActiveInWrapMode(t) {
    let e = this._getItemsArray();
    for (let i = 1; i <= e.length; i++) {
      let r = (this._activeItemIndex + t * i + e.length) % e.length, o = e[r];
      if (!this._skipPredicateFn(o)) {
        this.setActiveItem(r);
        return
      }
    }
  }
  _setActiveInDefaultMode(t) {
    this._setActiveItemByIndex(this._activeItemIndex + t, t)
  }
  _setActiveItemByIndex(t, e) {
    let i = this._getItemsArray();
    if (i[t]) {
      for (; this._skipPredicateFn(i[t]);)
        if (t += e, !i[t]) return;
      this.setActiveItem(t)
    }
  }
  _getItemsArray() {
    return br(this._items)        ? this._items() :
        this._items instanceof si ? this._items.toArray() :
                                    this._items
  }
  _itemsChanged(t) {
    this._typeahead?.setItems(t);
    let e = this._activeItem();
    if (e) {
      let i = t.indexOf(e);
      i > -1 && i !== this._activeItemIndex &&
          (this._activeItemIndex = i,
           this._typeahead?.setCurrentSelectedItemIndex(i))
    }
  }
}
, jm = class extends Vm {
  setActiveItem(t) {
    this.activeItem && this.activeItem.setInactiveStyles(),
        super.setActiveItem(t),
        this.activeItem && this.activeItem.setActiveStyles()
  }
}
, Bm = class extends Vm {
  _origin = 'program';
  setFocusOrigin(t) {
    return this._origin = t, this
  }
  setActiveItem(t) {
    super.setActiveItem(t),
        this.activeItem && this.activeItem.focus(this._origin)
  }
};
var Ql = (() => {
  class n {
    _platform = u(Ie);
    constructor() {}
    isDisabled(e) {
      return e.hasAttribute('disabled')
    }
    isVisible(e) {
      return cV(e) && getComputedStyle(e).visibility === 'visible'
    }
    isTabbable(e) {
      if (!this._platform.isBrowser) return !1;
      let i = lV(_V(e));
      if (i && (hk(i) === -1 || !this.isVisible(i))) return !1;
      let r = e.nodeName.toLowerCase(), o = hk(e);
      return e.hasAttribute('contenteditable') ? o !== -1 :
          r === 'iframe' || r === 'object' ||
              this._platform.WEBKIT && this._platform.IOS && !pV(e) ?
                                                 !1 :
          r === 'audio' ? e.hasAttribute('controls') ? o !== -1 : !1 :
          r === 'video' ? o === -1 ? !1 :
              o !== null           ? !0 :
                                     this._platform.FIREFOX ||
                  e.hasAttribute('controls') :
                          e.tabIndex >= 0
    }
    isFocusable(e, i) {
      return gV(e) && !this.isDisabled(e) &&
          (i?.ignoreVisibility || this.isVisible(e))
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function lV(n) {
  try {
    return n.frameElement
  } catch {
    return null
  }
}
function cV(n) {
  return !!(
      n.offsetWidth || n.offsetHeight ||
      typeof n.getClientRects == 'function' && n.getClientRects().length)
}
function dV(n) {
  let t = n.nodeName.toLowerCase();
  return t === 'input' || t === 'select' || t === 'button' || t === 'textarea'
}
function uV(n) {
  return hV(n) && n.type == 'hidden'
}
function mV(n) {
  return fV(n) && n.hasAttribute('href')
}
function hV(n) {
  return n.nodeName.toLowerCase() == 'input'
}
function fV(n) {
  return n.nodeName.toLowerCase() == 'a'
}
function vk(n) {
  if (!n.hasAttribute('tabindex') || n.tabIndex === void 0) return !1;
  let t = n.getAttribute('tabindex');
  return !!(t && !isNaN(parseInt(t, 10)))
}
function hk(n) {
  if (!vk(n)) return null;
  let t = parseInt(n.getAttribute('tabindex') || '', 10);
  return isNaN(t) ? -1 : t
}
function pV(n) {
  let t = n.nodeName.toLowerCase(), e = t === 'input' && n.type;
  return e === 'text' || e === 'password' || t === 'select' || t === 'textarea'
}
function gV(n) {
  return uV(n) ? !1 :
                 dV(n) || mV(n) || n.hasAttribute('contenteditable') || vk(n)
}
function _V(n) {
  return n.ownerDocument && n.ownerDocument.defaultView || window
}
var fb = class {
  _element;
  _checker;
  _ngZone;
  _document;
  _injector;
  _startAnchor;
  _endAnchor;
  _hasAttached = !1;
  startAnchorListener = () => this.focusLastTabbableElement();
  endAnchorListener = () => this.focusFirstTabbableElement();
  get enabled() {
    return this._enabled
  }
  set enabled(t) {
    this._enabled = t,
    this._startAnchor && this._endAnchor &&
        (this._toggleAnchorTabIndex(t, this._startAnchor),
         this._toggleAnchorTabIndex(t, this._endAnchor))
  }
  _enabled = !0;
  constructor(t, e, i, r, o = !1, s) {
    this._element = t, this._checker = e, this._ngZone = i, this._document = r,
    this._injector = s, o || this.attachAnchors()
  }
  destroy() {
    let t = this._startAnchor, e = this._endAnchor;
    t && (t.removeEventListener('focus', this.startAnchorListener), t.remove()),
        e &&
        (e.removeEventListener('focus', this.endAnchorListener), e.remove()),
        this._startAnchor = this._endAnchor = null, this._hasAttached = !1
  }
  attachAnchors() {
    return this._hasAttached ?
        !0 :
        (this._ngZone.runOutsideAngular(() => {
          this._startAnchor ||
              (this._startAnchor = this._createAnchor(),
               this._startAnchor.addEventListener(
                   'focus', this.startAnchorListener)),
          this._endAnchor ||
              (this._endAnchor = this._createAnchor(),
               this._endAnchor.addEventListener(
                   'focus', this.endAnchorListener))
        }),
         this._element.parentNode &&
             (this._element.parentNode.insertBefore(
                  this._startAnchor, this._element),
              this._element.parentNode.insertBefore(
                  this._endAnchor, this._element.nextSibling),
              this._hasAttached = !0),
         this._hasAttached)
  }
  focusInitialElementWhenReady(t) {
    return new Promise(
        e => {this._executeOnStable(() => e(this.focusInitialElement(t)))})
  }
  focusFirstTabbableElementWhenReady(t) {
    return new Promise(
        e => {
            this._executeOnStable(() => e(this.focusFirstTabbableElement(t)))})
  }
  focusLastTabbableElementWhenReady(t) {
    return new Promise(
        e => {this._executeOnStable(() => e(this.focusLastTabbableElement(t)))})
  }
  _getRegionBoundary(t) {
    let e = this._element.querySelectorAll(
        `[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);
    return t == 'start' ?
        e.length ? e[0] : this._getFirstTabbableElement(this._element) :
        e.length ? e[e.length - 1] :
                   this._getLastTabbableElement(this._element)
  }
  focusInitialElement(t) {
    let e =
        this._element.querySelector('[cdk-focus-initial], [cdkFocusInitial]');
    if (e) {
      if (!this._checker.isFocusable(e)) {
        let i = this._getFirstTabbableElement(e);
        return i?.focus(t), !!i
      }
      return e.focus(t), !0
    }
    return this.focusFirstTabbableElement(t)
  }
  focusFirstTabbableElement(t) {
    let e = this._getRegionBoundary('start');
    return e && e.focus(t), !!e
  }
  focusLastTabbableElement(t) {
    let e = this._getRegionBoundary('end');
    return e && e.focus(t), !!e
  }
  hasAttached() {
    return this._hasAttached
  }
  _getFirstTabbableElement(t) {
    if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
    let e = t.children;
    for (let i = 0; i < e.length; i++) {
      let r = e[i].nodeType === this._document.ELEMENT_NODE ?
          this._getFirstTabbableElement(e[i]) :
          null;
      if (r) return r
    }
    return null
  }
  _getLastTabbableElement(t) {
    if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
    let e = t.children;
    for (let i = e.length - 1; i >= 0; i--) {
      let r = e[i].nodeType === this._document.ELEMENT_NODE ?
          this._getLastTabbableElement(e[i]) :
          null;
      if (r) return r
    }
    return null
  }
  _createAnchor() {
    let t = this._document.createElement('div');
    return this._toggleAnchorTabIndex(this._enabled, t),
           t.classList.add('cdk-visually-hidden'),
           t.classList.add('cdk-focus-trap-anchor'),
           t.setAttribute('aria-hidden', 'true'), t
  }
  _toggleAnchorTabIndex(t, e) {
    t ? e.setAttribute('tabindex', '0') : e.removeAttribute('tabindex')
  }
  toggleAnchors(t) {
    this._startAnchor && this._endAnchor &&
        (this._toggleAnchorTabIndex(t, this._startAnchor),
         this._toggleAnchorTabIndex(t, this._endAnchor))
  }
  _executeOnStable(t) {
    this._injector ? ht(t, {injector: this._injector}) : setTimeout(t)
  }
}
, $m = (() => {
    class n {
      _checker = u(Ql);
      _ngZone = u(U);
      _document = u(ce);
      _injector = u(he);
      constructor() {
        u(lt).load(Gl)
      }
      create(e, i = !1) {
        return new fb(
            e, this._checker, this._ngZone, this._document, i, this._injector)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })();
function vb(n) {
  return n.buttons === 0 || n.detail === 0
}
function yb(n) {
  let t = n.touches && n.touches[0] || n.changedTouches && n.changedTouches[0];
  return !!t && t.identifier === -1 && (t.radiusX == null || t.radiusX === 1) &&
      (t.radiusY == null || t.radiusY === 1)
}
var bV = new w('cdk-input-modality-detector-options'),
    vV = {ignoreKeys: [18, 17, 224, 91, 16]}, yk = 650,
    ta = _i({passive: !0, capture: !0}),
    yV = (() => {
      class n {
        _platform = u(Ie);
        modalityDetected;
        modalityChanged;
        get mostRecentModality() {
          return this._modality.value
        }
        _mostRecentTarget = null;
        _modality = new Le(null);
        _options;
        _lastTouchMs = 0;
        _onKeydown = e => {
          this._options?.ignoreKeys?.some(i => i === e.keyCode) ||
              (this._modality.next('keyboard'), this._mostRecentTarget = un(e))
        };
        _onMousedown = e => {
          Date.now() - this._lastTouchMs < yk ||
              (this._modality.next(vb(e) ? 'keyboard' : 'mouse'),
               this._mostRecentTarget = un(e))
        };
        _onTouchstart = e => {
          if (yb(e)) {
            this._modality.next('keyboard');
            return
          }
          this._lastTouchMs = Date.now(), this._modality.next('touch'),
          this._mostRecentTarget = un(e)
        };
        constructor() {
          let e = u(U), i = u(ce), r = u(bV, {optional: !0});
          this._options = y(y({}, vV), r),
          this.modalityDetected = this._modality.pipe(ro(1)),
          this.modalityChanged = this.modalityDetected.pipe(Rn()),
          this._platform.isBrowser && e.runOutsideAngular(() => {
            i.addEventListener('keydown', this._onKeydown, ta),
            i.addEventListener('mousedown', this._onMousedown, ta),
            i.addEventListener('touchstart', this._onTouchstart, ta)
          })
        }
        ngOnDestroy() {
          this._modality.complete(),
              this._platform.isBrowser &&
              (document.removeEventListener('keydown', this._onKeydown, ta),
               document.removeEventListener('mousedown', this._onMousedown, ta),
               document.removeEventListener(
                   'touchstart', this._onTouchstart, ta))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    wV = new w('liveAnnouncerElement', {providedIn: 'root', factory: xV});
function xV() {
  return null
}
var CV = new w('LIVE_ANNOUNCER_DEFAULT_OPTIONS'), DV = 0,
    wk = (() => {
      class n {
        _ngZone = u(U);
        _defaultOptions = u(CV, {optional: !0});
        _liveElement;
        _document = u(ce);
        _previousTimeout;
        _currentPromise;
        _currentResolve;
        constructor() {
          let e = u(wV, {optional: !0});
          this._liveElement = e || this._createLiveElement()
        }
        announce(e, ...i) {
          let r = this._defaultOptions, o, s;
          return i.length === 1 && typeof i[0] == 'number' ?
                     s = i[0] :
                     [o, s] = i,
                     this.clear(), clearTimeout(this._previousTimeout),
                     o || (o = r && r.politeness ? r.politeness : 'polite'),
                     s == null && r && (s = r.duration),
                     this._liveElement.setAttribute('aria-live', o),
                     this._liveElement.id &&
                     this._exposeAnnouncerToModals(this._liveElement.id),
                     this._ngZone.runOutsideAngular(
                         () =>
                             (this._currentPromise ||
                                  (this._currentPromise = new Promise(
                                       a => this._currentResolve = a)),
                              clearTimeout(this._previousTimeout),
                              this._previousTimeout = setTimeout(
                                  () => {
                                    this._liveElement.textContent = e,
                                    typeof s == 'number' &&
                                        (this._previousTimeout =
                                             setTimeout(() => this.clear(), s)),
                                    this._currentResolve?.(),
                                    this._currentPromise =
                                        this._currentResolve = void 0
                                  },
                                  100),
                              this._currentPromise))
        }
        clear() {
          this._liveElement && (this._liveElement.textContent = '')
        }
        ngOnDestroy() {
          clearTimeout(this._previousTimeout), this._liveElement?.remove(),
              this._liveElement = null, this._currentResolve?.(),
              this._currentPromise = this._currentResolve = void 0
        }
        _createLiveElement() {
          let e = 'cdk-live-announcer-element',
              i = this._document.getElementsByClassName(e),
              r = this._document.createElement('div');
          for (let o = 0; o < i.length; o++) i[o].remove();
          return r.classList.add(e), r.classList.add('cdk-visually-hidden'),
                 r.setAttribute('aria-atomic', 'true'),
                 r.setAttribute('aria-live', 'polite'),
                 r.id = `cdk-live-announcer-${DV++}`,
                 this._document.body.appendChild(r), r
        }
        _exposeAnnouncerToModals(e) {
          let i = this._document.querySelectorAll(
              'body > .cdk-overlay-container [aria-modal="true"]');
          for (let r = 0; r < i.length; r++) {
            let o = i[r], s = o.getAttribute('aria-owns');
            s ? s.indexOf(e) === -1 &&
                    o.setAttribute('aria-owns', s + ' ' + e) :
                o.setAttribute('aria-owns', e)
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
var Fm =
        function(n) {
  return n[n.IMMEDIATE = 0] = 'IMMEDIATE', n[n.EVENTUAL = 1] = 'EVENTUAL', n
}(Fm || {}),
    EV = new w('cdk-focus-monitor-default-options'),
    Pm = _i({passive: !0, capture: !0}),
    xn = (() => {
      class n {
        _ngZone = u(U);
        _platform = u(Ie);
        _inputModalityDetector = u(yV);
        _origin = null;
        _lastFocusOrigin;
        _windowFocused = !1;
        _windowFocusTimeoutId;
        _originTimeoutId;
        _originFromTouchInteraction = !1;
        _elementInfo = new Map;
        _monitoredElementCount = 0;
        _rootNodeFocusListenerCount = new Map;
        _detectionMode;
        _windowFocusListener = () => {
          this._windowFocused = !0,
          this._windowFocusTimeoutId =
              setTimeout(() => this._windowFocused = !1)
        };
        _document = u(ce, {optional: !0});
        _stopInputModalityDetector = new I;
        constructor() {
          let e = u(EV, {optional: !0});
          this._detectionMode = e?.detectionMode || Fm.IMMEDIATE
        }
        _rootNodeFocusAndBlurListener = e => {
          let i = un(e);
          for (let r = i; r; r = r.parentElement)
            e.type === 'focus' ? this._onFocus(e, r) : this._onBlur(e, r)
        };
        monitor(e, i = !1) {
          let r = nn(e);
          if (!this._platform.isBrowser || r.nodeType !== 1) return G();
          let o = sk(r) || this._getDocument(), s = this._elementInfo.get(r);
          if (s) return i && (s.checkChildren = !0), s.subject;
          let a = {checkChildren: i, subject: new I, rootNode: o};
          return this._elementInfo.set(r, a), this._registerGlobalListeners(a),
                 a.subject
        }
        stopMonitoring(e) {
          let i = nn(e), r = this._elementInfo.get(i);
          r &&
              (r.subject.complete(), this._setClasses(i),
               this._elementInfo.delete(i), this._removeGlobalListeners(r))
        }
        focusVia(e, i, r) {
          let o = nn(e), s = this._getDocument().activeElement;
          o === s ?
              this._getClosestElementsInfo(o).forEach(
                  ([a, l]) => this._originChanged(a, i, l)) :
              (this._setOrigin(i), typeof o.focus == 'function' && o.focus(r))
        }
        ngOnDestroy() {
          this._elementInfo.forEach((e, i) => this.stopMonitoring(i))
        }
        _getDocument() {
          return this._document || document
        }
        _getWindow() {
          return this._getDocument().defaultView || window
        }
        _getFocusOrigin(e) {
          return this._origin ?
              this._originFromTouchInteraction ?
              this._shouldBeAttributedToTouch(e) ? 'touch' : 'program' :
              this._origin :
              this._windowFocused && this._lastFocusOrigin ?
              this._lastFocusOrigin :
              e && this._isLastInteractionFromInputLabel(e) ? 'mouse' :
                                                              'program'
        }
        _shouldBeAttributedToTouch(e) {
          return this._detectionMode === Fm.EVENTUAL ||
              !!e?.contains(this._inputModalityDetector._mostRecentTarget)
        }
        _setClasses(e, i) {
          e.classList.toggle('cdk-focused', !!i),
              e.classList.toggle('cdk-touch-focused', i === 'touch'),
              e.classList.toggle('cdk-keyboard-focused', i === 'keyboard'),
              e.classList.toggle('cdk-mouse-focused', i === 'mouse'),
              e.classList.toggle('cdk-program-focused', i === 'program')
        }
        _setOrigin(e, i = !1) {
          this._ngZone.runOutsideAngular(() => {
            if (this._origin = e,
                this._originFromTouchInteraction = e === 'touch' && i,
                this._detectionMode === Fm.IMMEDIATE) {
              clearTimeout(this._originTimeoutId);
              let r = this._originFromTouchInteraction ? yk : 1;
              this._originTimeoutId = setTimeout(() => this._origin = null, r)
            }
          })
        }
        _onFocus(e, i) {
          let r = this._elementInfo.get(i), o = un(e);
          !r || !r.checkChildren && i !== o ||
              this._originChanged(i, this._getFocusOrigin(o), r)
        }
        _onBlur(e, i) {
          let r = this._elementInfo.get(i);
          !r ||
              r.checkChildren && e.relatedTarget instanceof Node &&
                  i.contains(e.relatedTarget) ||
              (this._setClasses(i), this._emitOrigin(r, null))
        }
        _emitOrigin(e, i) {
          e.subject.observers.length &&
              this._ngZone.run(() => e.subject.next(i))
        }
        _registerGlobalListeners(e) {
          if (!this._platform.isBrowser) return;
          let i = e.rootNode, r = this._rootNodeFocusListenerCount.get(i) || 0;
          r || this._ngZone.runOutsideAngular(() => {
            i.addEventListener('focus', this._rootNodeFocusAndBlurListener, Pm),
            i.addEventListener('blur', this._rootNodeFocusAndBlurListener, Pm)
          }),
              this._rootNodeFocusListenerCount.set(i, r + 1),
              ++this._monitoredElementCount === 1 &&
              (this._ngZone.runOutsideAngular(
                   () => {this._getWindow().addEventListener(
                       'focus', this._windowFocusListener)}),
               this._inputModalityDetector.modalityDetected
                   .pipe(re(this._stopInputModalityDetector))
                   .subscribe(o => {this._setOrigin(o, !0)}))
        }
        _removeGlobalListeners(e) {
          let i = e.rootNode;
          if (this._rootNodeFocusListenerCount.has(i)) {
            let r = this._rootNodeFocusListenerCount.get(i);
            r > 1 ? this._rootNodeFocusListenerCount.set(i, r - 1) :
                    (i.removeEventListener(
                         'focus', this._rootNodeFocusAndBlurListener, Pm),
                     i.removeEventListener(
                         'blur', this._rootNodeFocusAndBlurListener, Pm),
                     this._rootNodeFocusListenerCount.delete(i))
          }
          --this._monitoredElementCount ||
              (this._getWindow().removeEventListener(
                   'focus', this._windowFocusListener),
               this._stopInputModalityDetector.next(),
               clearTimeout(this._windowFocusTimeoutId),
               clearTimeout(this._originTimeoutId))
        }
        _originChanged(e, i, r) {
          this._setClasses(e, i), this._emitOrigin(r, i),
              this._lastFocusOrigin = i
        }
        _getClosestElementsInfo(e) {
          let i = [];
          return this._elementInfo.forEach(
                     (r, o) => {
                         (o === e || r.checkChildren && o.contains(e)) &&
                         i.push([o, r])}),
                 i
        }
        _isLastInteractionFromInputLabel(e) {
          let {_mostRecentTarget: i, mostRecentModality: r} =
              this._inputModalityDetector;
          if (r !== 'mouse' || !i || i === e ||
              e.nodeName !== 'INPUT' && e.nodeName !== 'TEXTAREA' || e.disabled)
            return !1;
          let o = e.labels;
          if (o) {
            for (let s = 0; s < o.length; s++)
              if (o[s].contains(i)) return !0
          }
          return !1
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    xk = (() => {
      class n {
        _elementRef = u(L);
        _focusMonitor = u(xn);
        _monitorSubscription;
        _focusOrigin = null;
        cdkFocusChange = new H;
        constructor() {}
        get focusOrigin() {
          return this._focusOrigin
        }
        ngAfterViewInit() {
          let e = this._elementRef.nativeElement;
          this._monitorSubscription =
              this._focusMonitor
                  .monitor(
                      e,
                      e.nodeType === 1 &&
                          e.hasAttribute('cdkMonitorSubtreeFocus'))
                  .subscribe(
                      i => {this._focusOrigin = i, this.cdkFocusChange.emit(i)})
        }
        ngOnDestroy() {
          this._focusMonitor.stopMonitoring(this._elementRef),
              this._monitorSubscription &&
              this._monitorSubscription.unsubscribe()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['', 'cdkMonitorElementFocus', ''],
            ['', 'cdkMonitorSubtreeFocus', '']
          ],
          outputs: {cdkFocusChange: 'cdkFocusChange'},
          exportAs: ['cdkMonitorFocus']
        })
      } return n
    })(),
    Fo =
        function(n) {
      return n[n.NONE = 0] = 'NONE', n[n.BLACK_ON_WHITE = 1] = 'BLACK_ON_WHITE',
                        n[n.WHITE_ON_BLACK = 2] = 'WHITE_ON_BLACK', n
    }(Fo || {}),
    fk = 'cdk-high-contrast-black-on-white',
    pk = 'cdk-high-contrast-white-on-black', db = 'cdk-high-contrast-active',
    wb = (() => {
      class n {
        _platform = u(Ie);
        _hasCheckedHighContrastMode;
        _document = u(ce);
        _breakpointSubscription;
        constructor() {
          this._breakpointSubscription =
              u(uk)
                  .observe('(forced-colors: active)')
                  .subscribe(
                      () => {
                          this._hasCheckedHighContrastMode &&
                          (this._hasCheckedHighContrastMode = !1,
                           this._applyBodyHighContrastModeCssClasses())})
        }
        getHighContrastMode() {
          if (!this._platform.isBrowser) return Fo.NONE;
          let e = this._document.createElement('div');
          e.style.backgroundColor = 'rgb(1,2,3)', e.style.position = 'absolute',
          this._document.body.appendChild(e);
          let i = this._document.defaultView || window,
              r = i && i.getComputedStyle ? i.getComputedStyle(e) : null,
              o = (r && r.backgroundColor || '').replace(/ /g, '');
          switch (e.remove(), o) {
            case 'rgb(0,0,0)':
            case 'rgb(45,50,54)':
            case 'rgb(32,32,32)':
              return Fo.WHITE_ON_BLACK;
            case 'rgb(255,255,255)':
            case 'rgb(255,250,239)':
              return Fo.BLACK_ON_WHITE
          }
          return Fo.NONE
        }
        ngOnDestroy() {
          this._breakpointSubscription.unsubscribe()
        }
        _applyBodyHighContrastModeCssClasses() {
          if (!this._hasCheckedHighContrastMode && this._platform.isBrowser &&
              this._document.body) {
            let e = this._document.body.classList;
            e.remove(db, fk, pk), this._hasCheckedHighContrastMode = !0;
            let i = this.getHighContrastMode();
            i === Fo.BLACK_ON_WHITE ? e.add(db, fk) :
                                      i === Fo.WHITE_ON_BLACK && e.add(db, pk)
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    xb = (() => {
      class n {
        constructor() {
          u(wb)._applyBodyHighContrastModeCssClasses()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [ea]})
      } return n
    })(),
    ub = {}, et = (() => {
               class n {
                 _appId = u(Ms);
                 getId(e) {
                   return this._appId !== 'ng' && (e += this._appId),
                          ub.hasOwnProperty(e) || (ub[e] = 0), `${e}${ub[e]++}`
                 }
                 static \u0275fac = function(i) {
                   return new (i || n)
                 };
                 static \u0275prov =
                     C({token: n, factory: n.\u0275fac, providedIn: 'root'})
               } return n
             })();
var kV = new w('cdk-dir-doc', {providedIn: 'root', factory: SV});
function SV() {
  return u(ce)
}
var IV =
    /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function MV(n) {
  let t = n?.toLowerCase() || '';
  return t === 'auto' && typeof navigator < 'u' && navigator?.language ?
      IV.test(navigator.language) ? 'rtl' : 'ltr' :
      t === 'rtl' ? 'rtl' :
                    'ltr'
}
var dt = (() => {
  class n {
    value = 'ltr';
    change = new H;
    constructor() {
      let e = u(kV, {optional: !0});
      if (e) {
        let i = e.body ? e.body.dir : null,
            r = e.documentElement ? e.documentElement.dir : null;
        this.value = MV(i || r || 'ltr')
      }
    }
    ngOnDestroy() {
      this.change.complete()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
var Pr = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})();
var TV = ['text'], RV = [[['mat-icon']], '*'], AV = ['mat-icon', '*'];
function OV(n, t) {
  if (n & 1 && B(0, 'mat-pseudo-checkbox', 1), n & 2) {
    let e = D();
    x('disabled', e.disabled)('state', e.selected ? 'checked' : 'unchecked')
  }
}
function NV(n, t) {
  if (n & 1 && B(0, 'mat-pseudo-checkbox', 3), n & 2) {
    let e = D();
    x('disabled', e.disabled)
  }
}
function PV(n, t) {
  if (n & 1 && (f(0, 'span', 4), E(1), g()), n & 2) {
    let e = D();
    b(), at('(', e.group.label, ')')
  }
}
var FV = ['mat-internal-form-field', ''], LV = ['*'];
var pe = (() => {
  class n {
    constructor() {
      u(wb)._applyBodyHighContrastModeCssClasses()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [Pr, Pr]})
  } return n
})(),
    na = class {
  _defaultMatcher;
  ngControl;
  _parentFormGroup;
  _parentForm;
  _stateChanges;
  errorState = !1;
  matcher;
  constructor(t, e, i, r, o) {
    this._defaultMatcher = t, this.ngControl = e, this._parentFormGroup = i,
    this._parentForm = r, this._stateChanges = o
  }
  updateErrorState() {
    let t = this.errorState, e = this._parentFormGroup || this._parentForm,
        i = this.matcher || this._defaultMatcher,
        r = this.ngControl ? this.ngControl.control : null,
        o = i?.isErrorState(r, e) ?? !1;
    o !== t && (this.errorState = o, this._stateChanges.next())
  }
};
var Gm = (() => {
  class n {
    isErrorState(e, i) {
      return !!(e && e.invalid && (e.touched || i && i.submitted))
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})(),
    $n = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['structural-styles']],
          decls: 0,
          vars: 0,
          template: function(i, r) {},
          styles: [
            '.mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:""}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var Cn = function(n) {
  return n[n.FADING_IN = 0] = 'FADING_IN', n[n.VISIBLE = 1] = 'VISIBLE',
                         n[n.FADING_OUT = 2] = 'FADING_OUT',
                         n[n.HIDDEN = 3] = 'HIDDEN', n
}(Cn || {}), Eb = class {
  _renderer;
  element;
  config;
  _animationForciblyDisabledThroughCss;
  state = Cn.HIDDEN;
  constructor(t, e, i, r = !1) {
    this._renderer = t, this.element = e, this.config = i,
    this._animationForciblyDisabledThroughCss = r
  }
  fadeOut() {
    this._renderer.fadeOutRipple(this)
  }
}
, Ck = _i({passive: !0, capture: !0}), kb = class {
  _events = new Map;
  addHandler(t, e, i, r) {
    let o = this._events.get(e);
    if (o) {
      let s = o.get(i);
      s ? s.add(r) : o.set(i, new Set([r]))
    } else
      this._events.set(e, new Map([[i, new Set([r])]])),
          t.runOutsideAngular(
              () => {
                  document.addEventListener(e, this._delegateEventHandler, Ck)})
  }
  removeHandler(t, e, i) {
    let r = this._events.get(t);
    if (!r) return;
    let o = r.get(e);
    o &&
        (o.delete(i), o.size === 0 && r.delete(e),
         r.size === 0 &&
             (this._events.delete(t),
              document.removeEventListener(t, this._delegateEventHandler, Ck)))
  }
  _delegateEventHandler = t => {
    let e = un(t);
    e &&
        this._events.get(t.type)?.forEach(
            (i, r) => {
                (r === e || r.contains(e)) && i.forEach(o => o.handleEvent(t))})
  }
}
, qm = {enterDuration: 225, exitDuration: 150}, VV = 800,
  Dk = _i({passive: !0, capture: !0}), Ek = ['mousedown', 'touchstart'],
  kk = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'],
  jV = (() => {
    class n {
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275cmp = O({
        type: n,
        selectors: [['ng-component']],
        hostAttrs: ['mat-ripple-style-loader', ''],
        decls: 0,
        vars: 0,
        template: function(i, r) {},
        styles: [
          '.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}'
        ],
        encapsulation: 2,
        changeDetection: 0
      })
    } return n
  })(),
  ia = class n {
  _target;
  _ngZone;
  _platform;
  _containerElement;
  _triggerElement;
  _isPointerDown = !1;
  _activeRipples = new Map;
  _mostRecentTransientRipple;
  _lastTouchStartEvent;
  _pointerUpEventsRegistered = !1;
  _containerRect;
  static _eventManager = new kb;
  constructor(t, e, i, r, o) {
    this._target = t, this._ngZone = e, this._platform = r,
    r.isBrowser && (this._containerElement = nn(i)), o && o.get(lt).load(jV)
  }
  fadeInRipple(t, e, i = {}) {
    let r = this._containerRect = this._containerRect ||
        this._containerElement.getBoundingClientRect(),
        o = y(y({}, qm), i.animation);
    i.centered && (t = r.left + r.width / 2, e = r.top + r.height / 2);
    let s = i.radius || BV(t, e, r), a = t - r.left, l = e - r.top,
        c = o.enterDuration, d = document.createElement('div');
    d.classList.add('mat-ripple-element'),
        d.style.left = `${a - s}px`, d.style.top = `${l - s}px`,
        d.style.height = `${s * 2}px`, d.style.width = `${s * 2}px`,
        i.color != null && (d.style.backgroundColor = i.color),
        d.style.transitionDuration = `${c}ms`,
        this._containerElement.appendChild(d);
    let m = window.getComputedStyle(d), p = m.transitionProperty,
        h = m.transitionDuration,
        _ = p === 'none' || h === '0s' || h === '0s, 0s' ||
        r.width === 0 && r.height === 0,
        v = new Eb(this, d, i, _);
    d.style.transform = 'scale3d(1, 1, 1)', v.state = Cn.FADING_IN,
    i.persistent || (this._mostRecentTransientRipple = v);
    let k = null;
    return !_ && (c || o.exitDuration) && this._ngZone.runOutsideAngular(() => {
      let F = () => {
        k && (k.fallbackTimer = null), clearTimeout(Ce),
            this._finishRippleTransition(v)
      }, se = () => this._destroyRipple(v), Ce = setTimeout(se, c + 100);
      d.addEventListener('transitionend', F),
          d.addEventListener('transitioncancel', se), k = {
            onTransitionEnd: F,
            onTransitionCancel: se,
            fallbackTimer: Ce
          }
    }),
           this._activeRipples.set(v, k),
           (_ || !c) && this._finishRippleTransition(v), v
  }
  fadeOutRipple(t) {
    if (t.state === Cn.FADING_OUT || t.state === Cn.HIDDEN) return;
    let e = t.element, i = y(y({}, qm), t.config.animation);
    e.style.transitionDuration = `${i.exitDuration}ms`, e.style.opacity = '0',
    t.state = Cn.FADING_OUT,
    (t._animationForciblyDisabledThroughCss || !i.exitDuration) &&
        this._finishRippleTransition(t)
  }
  fadeOutAll() {
    this._getActiveRipples().forEach(t => t.fadeOut())
  }
  fadeOutAllNonPersistent() {
    this._getActiveRipples().forEach(t => {t.config.persistent || t.fadeOut()})
  }
  setupTriggerEvents(t) {
    let e = nn(t);
    !this._platform.isBrowser || !e || e === this._triggerElement ||
        (this._removeTriggerEvents(), this._triggerElement = e,
         Ek.forEach(
             i => {n._eventManager.addHandler(this._ngZone, i, e, this)}))
  }
  handleEvent(t) {
    t.type === 'mousedown'      ? this._onMousedown(t) :
        t.type === 'touchstart' ? this._onTouchStart(t) :
                                  this._onPointerUp(),
        this._pointerUpEventsRegistered ||
        (this._ngZone.runOutsideAngular(
             () => {kk.forEach(
                 e => {this._triggerElement.addEventListener(e, this, Dk)})}),
         this._pointerUpEventsRegistered = !0)
  }
  _finishRippleTransition(t) {
    t.state === Cn.FADING_IN ?
        this._startFadeOutTransition(t) :
        t.state === Cn.FADING_OUT && this._destroyRipple(t)
  }
  _startFadeOutTransition(t) {
    let e = t === this._mostRecentTransientRipple, {persistent: i} = t.config;
    t.state = Cn.VISIBLE, !i && (!e || !this._isPointerDown) && t.fadeOut()
  }
  _destroyRipple(t) {
    let e = this._activeRipples.get(t) ?? null;
    this._activeRipples.delete(t),
        this._activeRipples.size || (this._containerRect = null),
        t === this._mostRecentTransientRipple &&
        (this._mostRecentTransientRipple = null),
        t.state = Cn.HIDDEN,
        e !== null &&
        (t.element.removeEventListener('transitionend', e.onTransitionEnd),
         t.element.removeEventListener(
             'transitioncancel', e.onTransitionCancel),
         e.fallbackTimer !== null && clearTimeout(e.fallbackTimer)),
        t.element.remove()
  }
  _onMousedown(t) {
    let e = vb(t),
        i = this._lastTouchStartEvent &&
        Date.now() < this._lastTouchStartEvent + VV;
    !this._target.rippleDisabled && !e && !i &&
        (this._isPointerDown = !0,
         this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig))
  }
  _onTouchStart(t) {
    if (!this._target.rippleDisabled && !yb(t)) {
      this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0;
      let e = t.changedTouches;
      if (e)
        for (let i = 0; i < e.length; i++)
          this.fadeInRipple(
              e[i].clientX, e[i].clientY, this._target.rippleConfig)
    }
  }
  _onPointerUp() {
    this._isPointerDown &&
        (this._isPointerDown = !1, this._getActiveRipples().forEach(t => {
          let e = t.state === Cn.VISIBLE ||
              t.config.terminateOnPointerUp && t.state === Cn.FADING_IN;
          !t.config.persistent && e && t.fadeOut()
        }))
  }
  _getActiveRipples() {
    return Array.from(this._activeRipples.keys())
  }
  _removeTriggerEvents() {
    let t = this._triggerElement;
    t &&
        (Ek.forEach(e => n._eventManager.removeHandler(e, t, this)),
         this._pointerUpEventsRegistered &&
             (kk.forEach(e => t.removeEventListener(e, this, Dk)),
              this._pointerUpEventsRegistered = !1))
  }
};
function BV(n, t, e) {
  let i = Math.max(Math.abs(n - e.left), Math.abs(n - e.right)),
      r = Math.max(Math.abs(t - e.top), Math.abs(t - e.bottom));
  return Math.sqrt(i * i + r * r)
}
var Yl = new w('mat-ripple-global-options'),
    Fr = (() => {
      class n {
        _elementRef = u(L);
        _animationMode = u(Ve, {optional: !0});
        color;
        unbounded;
        centered;
        radius = 0;
        animation;
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          e && this.fadeOutAllNonPersistent(),
              this._disabled = e, this._setupTriggerEventsIfEnabled()
        }
        _disabled = !1;
        get trigger() {
          return this._trigger || this._elementRef.nativeElement
        }
        set trigger(e) {
          this._trigger = e, this._setupTriggerEventsIfEnabled()
        }
        _trigger;
        _rippleRenderer;
        _globalOptions;
        _isInitialized = !1;
        constructor() {
          let e = u(U), i = u(Ie), r = u(Yl, {optional: !0}), o = u(he);
          this._globalOptions = r || {},
          this._rippleRenderer = new ia(this, e, this._elementRef, i, o)
        }
        ngOnInit() {
          this._isInitialized = !0, this._setupTriggerEventsIfEnabled()
        }
        ngOnDestroy() {
          this._rippleRenderer._removeTriggerEvents()
        }
        fadeOutAll() {
          this._rippleRenderer.fadeOutAll()
        }
        fadeOutAllNonPersistent() {
          this._rippleRenderer.fadeOutAllNonPersistent()
        }
        get rippleConfig() {
          return {
            centered: this.centered, radius: this.radius, color: this.color,
                animation:
                    y(y(y({}, this._globalOptions.animation),
                        this._animationMode === 'NoopAnimations' ?
                            {enterDuration: 0, exitDuration: 0} :
                            {}),
                      this.animation),
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
          }
        }
        get rippleDisabled() {
          return this.disabled || !!this._globalOptions.disabled
        }
        _setupTriggerEventsIfEnabled() {
          !this.disabled && this._isInitialized &&
              this._rippleRenderer.setupTriggerEvents(this.trigger)
        }
        launch(e, i = 0, r) {
          return typeof e == 'number' ?
              this._rippleRenderer.fadeInRipple(
                  e, i, y(y({}, this.rippleConfig), r)) :
              this._rippleRenderer.fadeInRipple(
                  0, 0, y(y({}, this.rippleConfig), e))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'mat-ripple', ''], ['', 'matRipple', '']],
          hostAttrs: [1, 'mat-ripple'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 && Y('mat-ripple-unbounded', r.unbounded)
          },
          inputs: {
            color: [0, 'matRippleColor', 'color'],
            unbounded: [0, 'matRippleUnbounded', 'unbounded'],
            centered: [0, 'matRippleCentered', 'centered'],
            radius: [0, 'matRippleRadius', 'radius'],
            animation: [0, 'matRippleAnimation', 'animation'],
            disabled: [0, 'matRippleDisabled', 'disabled'],
            trigger: [0, 'matRippleTrigger', 'trigger']
          },
          exportAs: ['matRipple']
        })
      } return n
    })(),
    Zl = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe, pe]})
      } return n
    })(),
    zV = (() => {
      class n {
        _animationMode = u(Ve, {optional: !0});
        state = 'unchecked';
        disabled = !1;
        appearance = 'full';
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-pseudo-checkbox']],
          hostAttrs: [1, 'mat-pseudo-checkbox'],
          hostVars: 12,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mat-pseudo-checkbox-indeterminate',
                  r.state === 'indeterminate')(
                    'mat-pseudo-checkbox-checked', r.state === 'checked')(
                    'mat-pseudo-checkbox-disabled', r.disabled)(
                    'mat-pseudo-checkbox-minimal', r.appearance === 'minimal')(
                    'mat-pseudo-checkbox-full', r.appearance === 'full')(
                    '_mat-animation-noopable',
                    r._animationMode === 'NoopAnimations')
          },
          inputs:
              {state: 'state', disabled: 'disabled', appearance: 'appearance'},
          decls: 0,
          vars: 0,
          template: function(i, r) {},
          styles: [
            '.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after,.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{color:var(--mat-minimal-pseudo-checkbox-selected-checkmark-color, var(--mat-sys-primary))}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled::after,.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled::after{color:var(--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full{border-color:var(--mat-full-pseudo-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));border-width:2px;border-style:solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-disabled{border-color:var(--mat-full-pseudo-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{background-color:var(--mat-full-pseudo-checkbox-selected-icon-color, var(--mat-sys-primary));border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{color:var(--mat-full-pseudo-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background-color:var(--mat-full-pseudo-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled::after,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled::after{color:var(--mat-full-pseudo-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })(),
    Ib = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe]})
      } return n
    })(),
    Mb = new w('MAT_OPTION_PARENT_COMPONENT'), Tb = new w('MatOptgroup');
var Sb = class {
  source;
  isUserInput;
  constructor(t, e = !1) {
    this.source = t, this.isUserInput = e
  }
}
, sa = (() => {
    class n {
      _element = u(L);
      _changeDetectorRef = u(Ae);
      _parent = u(Mb, {optional: !0});
      group = u(Tb, {optional: !0});
      _signalDisableRipple = !1;
      _selected = !1;
      _active = !1;
      _disabled = !1;
      _mostRecentViewValue = '';
      get multiple() {
        return this._parent && this._parent.multiple
      }
      get selected() {
        return this._selected
      }
      value;
      id = u(et).getId('mat-option-');
      get disabled() {
        return this.group && this.group.disabled || this._disabled
      }
      set disabled(e) {
        this._disabled = e
      }
      get disableRipple() {
        return this._signalDisableRipple ? this._parent.disableRipple() :
                                           !!this._parent?.disableRipple
      }
      get hideSingleSelectionIndicator() {
        return !!(this._parent && this._parent.hideSingleSelectionIndicator)
      }
      onSelectionChange = new H;
      _text;
      _stateChanges = new I;
      constructor() {
        let e = u(lt);
        e.load($n), e.load(Gl),
            this._signalDisableRipple =
                !!this._parent && br(this._parent.disableRipple)
      }
      get active() {
        return this._active
      }
      get viewValue() {
        return (this._text?.nativeElement.textContent || '').trim()
      }
      select(e = !0) {
        this._selected ||
            (this._selected = !0, this._changeDetectorRef.markForCheck(),
             e && this._emitSelectionChangeEvent())
      }
      deselect(e = !0) {
        this._selected &&
            (this._selected = !1, this._changeDetectorRef.markForCheck(),
             e && this._emitSelectionChangeEvent())
      }
      focus(e, i) {
        let r = this._getHostElement();
        typeof r.focus == 'function' && r.focus(i)
      }
      setActiveStyles() {
        this._active ||
            (this._active = !0, this._changeDetectorRef.markForCheck())
      }
      setInactiveStyles() {
        this._active &&
            (this._active = !1, this._changeDetectorRef.markForCheck())
      }
      getLabel() {
        return this.viewValue
      }
      _handleKeydown(e) {
        (e.keyCode === 13 || e.keyCode === 32) && !wt(e) &&
            (this._selectViaInteraction(), e.preventDefault())
      }
      _selectViaInteraction() {
        this.disabled ||
            (this._selected = this.multiple ? !this._selected : !0,
             this._changeDetectorRef.markForCheck(),
             this._emitSelectionChangeEvent(!0))
      }
      _getTabIndex() {
        return this.disabled ? '-1' : '0'
      }
      _getHostElement() {
        return this._element.nativeElement
      }
      ngAfterViewChecked() {
        if (this._selected) {
          let e = this.viewValue;
          e !== this._mostRecentViewValue &&
              (this._mostRecentViewValue && this._stateChanges.next(),
               this._mostRecentViewValue = e)
        }
      }
      ngOnDestroy() {
        this._stateChanges.complete()
      }
      _emitSelectionChangeEvent(e = !1) {
        this.onSelectionChange.emit(new Sb(this, e))
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275cmp = O({
        type: n,
        selectors: [['mat-option']],
        viewQuery: function(i, r) {
          if (i & 1 && oe(TV, 7), i & 2) {
            let o;
            $(o = W()) && (r._text = o.first)
          }
        },
        hostAttrs: ['role', 'option', 1, 'mat-mdc-option', 'mdc-list-item'],
        hostVars: 11,
        hostBindings: function(i, r) {
          i&1 &&
              M('click',
                function() {
                  return r._selectViaInteraction()
                })(
                  'keydown',
                  function(s) {
                    return r._handleKeydown(s)
                  }),
              i&2 &&
              (en('id', r.id),
               J('aria-selected', r.selected)(
                   'aria-disabled', r.disabled.toString()),
               Y('mdc-list-item--selected', r.selected)(
                   'mat-mdc-option-multiple', r.multiple)(
                   'mat-mdc-option-active', r.active)(
                   'mdc-list-item--disabled', r.disabled))
        },
        inputs: {
          value: 'value',
          id: 'id',
          disabled: [2, 'disabled', 'disabled', q]
        },
        outputs: {onSelectionChange: 'onSelectionChange'},
        exportAs: ['matOption'],
        ngContentSelectors: AV,
        decls: 8,
        vars: 5,
        consts: [
          ['text', ''],
          [
            'aria-hidden', 'true', 1, 'mat-mdc-option-pseudo-checkbox', 3,
            'disabled', 'state'
          ],
          [1, 'mdc-list-item__primary-text'],
          [
            'state', 'checked', 'aria-hidden', 'true', 'appearance', 'minimal',
            1, 'mat-mdc-option-pseudo-checkbox', 3, 'disabled'
          ],
          [1, 'cdk-visually-hidden'],
          [
            'aria-hidden', 'true', 'mat-ripple', '', 1, 'mat-mdc-option-ripple',
            'mat-focus-indicator', 3, 'matRippleTrigger', 'matRippleDisabled'
          ]
        ],
        template: function(i, r) {
          i&1 &&
              (Se(RV), R(0, OV, 1, 2, 'mat-pseudo-checkbox', 1), Z(1),
               f(2, 'span', 2, 0), Z(4, 1), g(),
               R(5, NV, 1, 1, 'mat-pseudo-checkbox', 3)(6, PV, 2, 1, 'span', 4),
               B(7, 'div', 5)),
              i&2 &&
              (de(r.multiple ? 0 : -1), b(5),
               de(!r.multiple && r.selected && !r.hideSingleSelectionIndicator ?
                      5 :
                      -1),
               b(), de(r.group && r.group._inert ? 6 : -1), b(),
               x('matRippleTrigger', r._getHostElement())(
                   'matRippleDisabled', r.disabled || r.disableRipple))
        },
        dependencies: [zV, Fr],
        styles: [
          '.mat-mdc-option{-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-option-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-option-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-option-label-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-option-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-option-label-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent));outline:0}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color, var(--mat-sys-secondary-container))}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option.mdc-list-item{align-items:center;background:rgba(0,0,0,0)}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}@media(forced-colors: active){.mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{right:auto;left:16px}}.mat-mdc-option-multiple{--mdc-list-list-item-selected-container-color:var(--mdc-list-list-item-container-color, transparent)}.mat-mdc-option-active .mat-focus-indicator::before{content:""}'
        ],
        encapsulation: 2,
        changeDetection: 0
      })
    } return n
  })();
function Tk(n, t, e) {
  if (e.length) {
    let i = t.toArray(), r = e.toArray(), o = 0;
    for (let s = 0; s < n + 1; s++) i[s].group && i[s].group === r[o] && o++;
    return o
  }
  return 0
}
function Rk(n, t, e, i) {
  return n < e ? n : n + t > e + i ? Math.max(0, n - i + t) : e
}
var Rb = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [Zl, pe, Ib]})
  } return n
})(),
    Sk = {capture: !0}, Ik = ['focus', 'mousedown', 'mouseenter', 'touchstart'],
    Cb = 'mat-ripple-loader-uninitialized', Db = 'mat-ripple-loader-class-name',
    Mk = 'mat-ripple-loader-centered', Wm = 'mat-ripple-loader-disabled',
    Ak = (() => {
      class n {
        _document = u(ce, {optional: !0});
        _animationMode = u(Ve, {optional: !0});
        _globalRippleOptions = u(Yl, {optional: !0});
        _platform = u(Ie);
        _ngZone = u(U);
        _injector = u(he);
        _hosts = new Map;
        constructor() {
          this._ngZone.runOutsideAngular(() => {
            for (let e of Ik)
              this._document?.addEventListener(e, this._onInteraction, Sk)
          })
        }
        ngOnDestroy() {
          let e = this._hosts.keys();
          for (let i of e) this.destroyRipple(i);
          for (let i of Ik)
            this._document?.removeEventListener(i, this._onInteraction, Sk)
        }
        configureRipple(e, i) {
          e.setAttribute(Cb, this._globalRippleOptions?.namespace ?? ''),
              (i.className || !e.hasAttribute(Db)) &&
              e.setAttribute(Db, i.className || ''),
              i.centered && e.setAttribute(Mk, ''),
              i.disabled && e.setAttribute(Wm, '')
        }
        setDisabled(e, i) {
          let r = this._hosts.get(e);
          r     ? (r.target.rippleDisabled = i,
               !i && !r.hasSetUpEvents &&
                   (r.hasSetUpEvents = !0, r.renderer.setupTriggerEvents(e))) :
              i ? e.setAttribute(Wm, '') :
                  e.removeAttribute(Wm)
        }
        _onInteraction = e => {
          let i = un(e);
          if (i instanceof HTMLElement) {
            let r = i.closest(
                `[${Cb}="${this._globalRippleOptions?.namespace ?? ''}"]`);
            r && this._createRipple(r)
          }
        };
        _createRipple(e) {
          if (!this._document || this._hosts.has(e)) return;
          e.querySelector('.mat-ripple')?.remove();
          let i = this._document.createElement('span');
          i.classList.add('mat-ripple', e.getAttribute(Db)), e.append(i);
          let r = this._animationMode === 'NoopAnimations',
              o = this._globalRippleOptions,
              s = r ? 0 : o?.animation?.enterDuration ?? qm.enterDuration,
              a = r ? 0 : o?.animation?.exitDuration ?? qm.exitDuration, l = {
                rippleDisabled: r || o?.disabled || e.hasAttribute(Wm),
                rippleConfig: {
                  centered: e.hasAttribute(Mk),
                  terminateOnPointerUp: o?.terminateOnPointerUp,
                  animation: {enterDuration: s, exitDuration: a}
                }
              },
              c = new ia(l, this._ngZone, i, this._platform, this._injector),
              d = !l.rippleDisabled;
          d && c.setupTriggerEvents(e),
              this._hosts.set(e, {target: l, renderer: c, hasSetUpEvents: d}),
              e.removeAttribute(Cb)
        }
        destroyRipple(e) {
          let i = this._hosts.get(e);
          i && (i.renderer._removeTriggerEvents(), this._hosts.delete(e))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    Qm = (() => {
      class n {
        labelPosition;
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['div', 'mat-internal-form-field', '']],
          hostAttrs: [1, 'mdc-form-field', 'mat-internal-form-field'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 && Y('mdc-form-field--align-end', r.labelPosition === 'before')
          },
          inputs: {labelPosition: 'labelPosition'},
          attrs: FV,
          ngContentSelectors: LV,
          decls: 1,
          vars: 0,
          template: function(i, r) {
            i&1 && (Se(), Z(0))
          },
          styles: [
            '.mat-internal-form-field{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-flex;align-items:center;vertical-align:middle}.mat-internal-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mat-internal-form-field>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end .mdc-form-field--align-end label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var UV = ['mat-button', ''],
    Ab =
        [
          [
            ['', 8, 'material-icons', 3, 'iconPositionEnd', ''],
            ['mat-icon', 3, 'iconPositionEnd', ''],
            ['', 'matButtonIcon', '', 3, 'iconPositionEnd', '']
          ],
          '*',
          [
            ['', 'iconPositionEnd', '', 8, 'material-icons'],
            ['mat-icon', 'iconPositionEnd', ''],
            ['', 'matButtonIcon', '', 'iconPositionEnd', '']
          ]
        ],
    Ob = [
      '.material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])',
      '*',
      '.material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]'
    ];
var $V =
        '@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-icon-button.mat-mdc-icon-button{outline:solid 1px}}',
    WV = ['mat-fab', ''], qV = ['mat-mini-fab', ''],
    GV =
        '.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mdc-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mdc-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mdc-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mdc-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mdc-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mdc-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-fab-touch-target-display, block)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mdc-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mdc-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mdc-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mdc-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mdc-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mdc-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-fab-small-touch-target-display)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;height:var(--mdc-extended-fab-container-height, 56px);border-radius:var(--mdc-extended-fab-container-shape, var(--mat-sys-corner-large));font-family:var(--mdc-extended-fab-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-extended-fab-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-extended-fab-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-extended-fab-label-text-tracking, var(--mat-sys-label-large-tracking));box-shadow:var(--mdc-extended-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:hover{box-shadow:var(--mdc-extended-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mdc-extended-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mdc-extended-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}',
    QV = ['mat-icon-button', ''], YV = ['*'];
var ZV = new w('MAT_BUTTON_CONFIG');
var KV =
        [
          {
            attribute: 'mat-button',
            mdcClasses: ['mdc-button', 'mat-mdc-button']
          },
          {
            attribute: 'mat-flat-button',
            mdcClasses: [
              'mdc-button', 'mdc-button--unelevated',
              'mat-mdc-unelevated-button'
            ]
          },
          {
            attribute: 'mat-raised-button',
            mdcClasses:
                ['mdc-button', 'mdc-button--raised', 'mat-mdc-raised-button']
          },
          {
            attribute: 'mat-stroked-button',
            mdcClasses: [
              'mdc-button', 'mdc-button--outlined', 'mat-mdc-outlined-button'
            ]
          },
          {
            attribute: 'mat-fab',
            mdcClasses: ['mdc-fab', 'mat-mdc-fab-base', 'mat-mdc-fab']
          },
          {
            attribute: 'mat-mini-fab',
            mdcClasses: [
              'mdc-fab', 'mat-mdc-fab-base', 'mdc-fab--mini', 'mat-mdc-mini-fab'
            ]
          },
          {
            attribute: 'mat-icon-button',
            mdcClasses: ['mdc-icon-button', 'mat-mdc-icon-button']
          }
        ],
    Zm = (() => {
      class n {
        _elementRef = u(L);
        _ngZone = u(U);
        _animationMode = u(Ve, {optional: !0});
        _focusMonitor = u(xn);
        _rippleLoader = u(Ak);
        _isFab = !1;
        color;
        get disableRipple() {
          return this._disableRipple
        }
        set disableRipple(e) {
          this._disableRipple = e, this._updateRippleDisabled()
        }
        _disableRipple = !1;
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          this._disabled = e, this._updateRippleDisabled()
        }
        _disabled = !1;
        ariaDisabled;
        disabledInteractive;
        constructor() {
          u(lt).load($n);
          let e = u(ZV, {optional: !0}), i = this._elementRef.nativeElement,
              r = i.classList;
          this.disabledInteractive = e?.disabledInteractive ?? !1,
          this.color = e?.color ?? null,
          this._rippleLoader?.configureRipple(
              i, {className: 'mat-mdc-button-ripple'});
          for (let {attribute: o, mdcClasses: s} of KV)
            i.hasAttribute(o) && r.add(...s)
        }
        ngAfterViewInit() {
          this._focusMonitor.monitor(this._elementRef, !0)
        }
        ngOnDestroy() {
          this._focusMonitor.stopMonitoring(this._elementRef),
              this._rippleLoader?.destroyRipple(this._elementRef.nativeElement)
        }
        focus(e = 'program', i) {
          e ? this._focusMonitor.focusVia(
                  this._elementRef.nativeElement, e, i) :
              this._elementRef.nativeElement.focus(i)
        }
        _getAriaDisabled() {
          return this.ariaDisabled != null              ? this.ariaDisabled :
              this.disabled && this.disabledInteractive ? !0 :
                                                          null
        }
        _getDisabledAttribute() {
          return this.disabledInteractive || !this.disabled ? null : !0
        }
        _updateRippleDisabled() {
          this._rippleLoader?.setDisabled(
              this._elementRef.nativeElement,
              this.disableRipple || this.disabled)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          inputs: {
            color: 'color',
            disableRipple: [2, 'disableRipple', 'disableRipple', q],
            disabled: [2, 'disabled', 'disabled', q],
            ariaDisabled: [2, 'aria-disabled', 'ariaDisabled', q],
            disabledInteractive:
                [2, 'disabledInteractive', 'disabledInteractive', q]
          }
        })
      } return n
    })();
var bi = (() => {
  class n extends Zm {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275cmp = O({
      type: n,
      selectors: [
        ['button', 'mat-button', ''], ['button', 'mat-raised-button', ''],
        ['button', 'mat-flat-button', ''], ['button', 'mat-stroked-button', '']
      ],
      hostVars: 14,
      hostBindings: function(i, r) {
        i&2 &&
            (J('disabled', r._getDisabledAttribute())(
                 'aria-disabled', r._getAriaDisabled()),
             kt(r.color ? 'mat-' + r.color : ''),
             Y('mat-mdc-button-disabled', r.disabled)(
                 'mat-mdc-button-disabled-interactive', r.disabledInteractive)(
                 '_mat-animation-noopable',
                 r._animationMode === 'NoopAnimations')(
                 'mat-unthemed', !r.color)('mat-mdc-button-base', !0))
      },
      exportAs: ['matButton'],
      features: [te],
      attrs: UV,
      ngContentSelectors: Ob,
      decls: 7,
      vars: 4,
      consts: [
        [1, 'mat-mdc-button-persistent-ripple'], [1, 'mdc-button__label'],
        [1, 'mat-focus-indicator'], [1, 'mat-mdc-button-touch-target']
      ],
      template: function(i, r) {
        i&1 &&
            (Se(Ab), B(0, 'span', 0), Z(1), f(2, 'span', 1), Z(3, 1), g(),
             Z(4, 2), B(5, 'span', 2)(6, 'span', 3)),
            i&2 &&
            Y('mdc-button__ripple', !r._isFab)('mdc-fab__ripple', r._isFab)
      },
      styles: [
        '.mat-mdc-button-base{text-decoration:none}.mdc-button{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0);padding:0 8px}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__label{position:relative}.mat-mdc-button{padding:0 var(--mat-text-button-horizontal-padding, 12px);height:var(--mdc-text-button-container-height, 40px);font-family:var(--mdc-text-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-text-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-text-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-text-button-label-text-transform);font-weight:var(--mdc-text-button-label-text-weight, var(--mat-sys-label-large-weight))}.mat-mdc-button,.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, var(--mat-sys-primary))}.mat-mdc-button[disabled],.mat-mdc-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-text-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-button:has(.material-icons,mat-icon,[matButtonIcon]){padding:0 var(--mat-text-button-with-icon-horizontal-padding, 16px)}.mat-mdc-button>.mat-icon{margin-right:var(--mat-text-button-icon-spacing, 8px);margin-left:var(--mat-text-button-icon-offset, -4px)}[dir=rtl] .mat-mdc-button>.mat-icon{margin-right:var(--mat-text-button-icon-offset, -4px);margin-left:var(--mat-text-button-icon-spacing, 8px)}.mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-text-button-icon-offset, -4px);margin-left:var(--mat-text-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-text-button-icon-spacing, 8px);margin-left:var(--mat-text-button-icon-offset, -4px)}.mat-mdc-button .mat-ripple-element{background-color:var(--mat-text-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-text-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-text-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-text-button-touch-target-display, block)}.mat-mdc-unelevated-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mdc-filled-button-container-height, 40px);font-family:var(--mdc-filled-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-filled-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-filled-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-filled-button-label-text-transform);font-weight:var(--mdc-filled-button-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-filled-button-horizontal-padding, 24px)}.mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-filled-button-icon-spacing, 8px);margin-left:var(--mat-filled-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-filled-button-icon-offset, -8px);margin-left:var(--mat-filled-button-icon-spacing, 8px)}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-filled-button-icon-offset, -8px);margin-left:var(--mat-filled-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-filled-button-icon-spacing, 8px);margin-left:var(--mat-filled-button-icon-offset, -8px)}.mat-mdc-unelevated-button .mat-ripple-element{background-color:var(--mat-filled-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-filled-button-state-layer-color, var(--mat-sys-on-primary))}.mat-mdc-unelevated-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-filled-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-unelevated-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-unelevated-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-unelevated-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-unelevated-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-filled-button-touch-target-display, block)}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, var(--mat-sys-on-primary));background-color:var(--mdc-filled-button-container-color, var(--mat-sys-primary))}.mat-mdc-unelevated-button,.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-unelevated-button[disabled],.mat-mdc-unelevated-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-filled-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mdc-filled-button-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-raised-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);box-shadow:var(--mdc-protected-button-container-elevation-shadow, var(--mat-sys-level1));height:var(--mdc-protected-button-container-height, 40px);font-family:var(--mdc-protected-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-protected-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-protected-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-protected-button-label-text-transform);font-weight:var(--mdc-protected-button-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-protected-button-horizontal-padding, 24px)}.mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-protected-button-icon-spacing, 8px);margin-left:var(--mat-protected-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-protected-button-icon-offset, -8px);margin-left:var(--mat-protected-button-icon-spacing, 8px)}.mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-protected-button-icon-offset, -8px);margin-left:var(--mat-protected-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-protected-button-icon-spacing, 8px);margin-left:var(--mat-protected-button-icon-offset, -8px)}.mat-mdc-raised-button .mat-ripple-element{background-color:var(--mat-protected-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-protected-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-raised-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-protected-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-raised-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-raised-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-raised-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-raised-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-protected-button-touch-target-display, block)}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, var(--mat-sys-primary));background-color:var(--mdc-protected-button-container-color, var(--mat-sys-surface))}.mat-mdc-raised-button,.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation-shadow, var(--mat-sys-level2))}.mat-mdc-raised-button:focus{box-shadow:var(--mdc-protected-button-focus-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button:active,.mat-mdc-raised-button:focus:active{box-shadow:var(--mdc-protected-button-pressed-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button[disabled],.mat-mdc-raised-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-protected-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mdc-protected-button-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-raised-button[disabled].mat-mdc-button-disabled,.mat-mdc-raised-button.mat-mdc-button-disabled.mat-mdc-button-disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation-shadow, var(--mat-sys-level0))}.mat-mdc-raised-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mdc-outlined-button-container-height, 40px);font-family:var(--mdc-outlined-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-outlined-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-outlined-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-outlined-button-label-text-transform);font-weight:var(--mdc-outlined-button-label-text-weight, var(--mat-sys-label-large-weight));border-radius:var(--mdc-outlined-button-container-shape, var(--mat-sys-corner-full));border-width:var(--mdc-outlined-button-outline-width, 1px);padding:0 var(--mat-outlined-button-horizontal-padding, 24px)}.mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-outlined-button-icon-spacing, 8px);margin-left:var(--mat-outlined-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-outlined-button-icon-offset, -8px);margin-left:var(--mat-outlined-button-icon-spacing, 8px)}.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-outlined-button-icon-offset, -8px);margin-left:var(--mat-outlined-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-outlined-button-icon-spacing, 8px);margin-left:var(--mat-outlined-button-icon-offset, -8px)}.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-outlined-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-outlined-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-outlined-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-outlined-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-outlined-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-outlined-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-outlined-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-outlined-button-touch-target-display, block)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, var(--mat-sys-primary));border-color:var(--mdc-outlined-button-outline-color, var(--mat-sys-outline))}.mat-mdc-outlined-button[disabled],.mat-mdc-outlined-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-outlined-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:var(--mdc-outlined-button-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button .mdc-button__ripple{border-width:var(--mdc-outlined-button-outline-width, 1px);border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-button .mdc-button__label,.mat-mdc-button .mat-icon,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-unelevated-button .mat-icon,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-raised-button .mat-icon,.mat-mdc-outlined-button .mdc-button__label,.mat-mdc-outlined-button .mat-icon{z-index:1;position:relative}.mat-mdc-button .mat-focus-indicator,.mat-mdc-unelevated-button .mat-focus-indicator,.mat-mdc-raised-button .mat-focus-indicator,.mat-mdc-outlined-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus>.mat-focus-indicator::before,.mat-mdc-unelevated-button:focus>.mat-focus-indicator::before,.mat-mdc-raised-button:focus>.mat-focus-indicator::before,.mat-mdc-outlined-button:focus>.mat-focus-indicator::before{content:""}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px}.mat-mdc-unelevated-button .mat-focus-indicator::before,.mat-mdc-raised-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-outlined-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 3px)*-1)}',
        '@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-icon-button.mat-mdc-icon-button{outline:solid 1px}}'
      ],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})();
var Ok =
    new w('mat-mdc-fab-default-options', {providedIn: 'root', factory: Nk});
function Nk() {
  return {
    color: 'accent'
  }
}
var Ym = Nk(),
    Pk = (() => {
      class n extends Zm {
        _options = u(Ok, {optional: !0});
        _isFab = !0;
        extended;
        constructor() {
          super(), this._options = this._options || Ym,
                   this.color = this._options.color || Ym.color
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['button', 'mat-fab', '']],
          hostVars: 18,
          hostBindings: function(i, r) {
            i&2 &&
                (J('disabled', r._getDisabledAttribute())(
                     'aria-disabled', r._getAriaDisabled()),
                 kt(r.color ? 'mat-' + r.color : ''),
                 Y('mat-mdc-button-disabled', r.disabled)(
                     'mat-mdc-button-disabled-interactive',
                     r.disabledInteractive)(
                     '_mat-animation-noopable',
                     r._animationMode === 'NoopAnimations')(
                     'mat-unthemed', !r.color)('mat-mdc-button-base', !0)(
                     'mdc-fab--extended', r.extended)(
                     'mat-mdc-extended-fab', r.extended))
          },
          inputs: {extended: [2, 'extended', 'extended', q]},
          exportAs: ['matButton'],
          features: [te],
          attrs: WV,
          ngContentSelectors: Ob,
          decls: 7,
          vars: 4,
          consts: [
            [1, 'mat-mdc-button-persistent-ripple'], [1, 'mdc-button__label'],
            [1, 'mat-focus-indicator'], [1, 'mat-mdc-button-touch-target']
          ],
          template: function(i, r) {
            i&1 &&
                (Se(Ab), B(0, 'span', 0), Z(1), f(2, 'span', 1), Z(3, 1), g(),
                 Z(4, 2), B(5, 'span', 2)(6, 'span', 3)),
                i&2 &&
                Y('mdc-button__ripple', !r._isFab)('mdc-fab__ripple', r._isFab)
          },
          styles: [
            '.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mdc-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mdc-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mdc-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mdc-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mdc-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mdc-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-fab-touch-target-display, block)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mdc-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mdc-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mdc-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mdc-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mdc-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mdc-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-fab-small-touch-target-display)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;height:var(--mdc-extended-fab-container-height, 56px);border-radius:var(--mdc-extended-fab-container-shape, var(--mat-sys-corner-large));font-family:var(--mdc-extended-fab-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-extended-fab-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-extended-fab-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-extended-fab-label-text-tracking, var(--mat-sys-label-large-tracking));box-shadow:var(--mdc-extended-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:hover{box-shadow:var(--mdc-extended-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mdc-extended-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mdc-extended-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })(),
    Fk = (() => {
      class n extends Zm {
        _options = u(Ok, {optional: !0});
        _isFab = !0;
        constructor() {
          super(), this._options = this._options || Ym,
                   this.color = this._options.color || Ym.color
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['button', 'mat-mini-fab', '']],
          hostVars: 14,
          hostBindings: function(i, r) {
            i&2 &&
                (J('disabled', r._getDisabledAttribute())(
                     'aria-disabled', r._getAriaDisabled()),
                 kt(r.color ? 'mat-' + r.color : ''),
                 Y('mat-mdc-button-disabled', r.disabled)(
                     'mat-mdc-button-disabled-interactive',
                     r.disabledInteractive)(
                     '_mat-animation-noopable',
                     r._animationMode === 'NoopAnimations')(
                     'mat-unthemed', !r.color)('mat-mdc-button-base', !0))
          },
          exportAs: ['matButton'],
          features: [te],
          attrs: qV,
          ngContentSelectors: Ob,
          decls: 7,
          vars: 4,
          consts: [
            [1, 'mat-mdc-button-persistent-ripple'], [1, 'mdc-button__label'],
            [1, 'mat-focus-indicator'], [1, 'mat-mdc-button-touch-target']
          ],
          template: function(i, r) {
            i&1 &&
                (Se(Ab), B(0, 'span', 0), Z(1), f(2, 'span', 1), Z(3, 1), g(),
                 Z(4, 2), B(5, 'span', 2)(6, 'span', 3)),
                i&2 &&
                Y('mdc-button__ripple', !r._isFab)('mdc-fab__ripple', r._isFab)
          },
          styles: [GV],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var Km = (() => {
  class n extends Zm {
    constructor() {
      super(),
          this._rippleLoader.configureRipple(
              this._elementRef.nativeElement, {centered: !0})
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['button', 'mat-icon-button', '']],
      hostVars: 14,
      hostBindings: function(i, r) {
        i&2 &&
            (J('disabled', r._getDisabledAttribute())(
                 'aria-disabled', r._getAriaDisabled()),
             kt(r.color ? 'mat-' + r.color : ''),
             Y('mat-mdc-button-disabled', r.disabled)(
                 'mat-mdc-button-disabled-interactive', r.disabledInteractive)(
                 '_mat-animation-noopable',
                 r._animationMode === 'NoopAnimations')(
                 'mat-unthemed', !r.color)('mat-mdc-button-base', !0))
      },
      exportAs: ['matButton'],
      features: [te],
      attrs: QV,
      ngContentSelectors: YV,
      decls: 4,
      vars: 0,
      consts: [
        [1, 'mat-mdc-button-persistent-ripple', 'mdc-icon-button__ripple'],
        [1, 'mat-focus-indicator'], [1, 'mat-mdc-button-touch-target']
      ],
      template: function(i, r) {
        i&1 && (Se(), B(0, 'span', 0), Z(1), B(2, 'span', 1)(3, 'span', 2))
      },
      styles: [
        '.mat-mdc-icon-button{-webkit-user-select:none;user-select:none;display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;z-index:0;overflow:visible;border-radius:50%;flex-shrink:0;text-align:center;width:var(--mdc-icon-button-state-layer-size, 40px);height:var(--mdc-icon-button-state-layer-size, 40px);padding:calc(calc(var(--mdc-icon-button-state-layer-size, 40px) - var(--mdc-icon-button-icon-size, 24px)) / 2);font-size:var(--mdc-icon-button-icon-size, 24px);color:var(--mdc-icon-button-icon-color, var(--mat-sys-on-surface-variant));-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-icon-button .mdc-button__label,.mat-mdc-icon-button .mat-icon{z-index:1;position:relative}.mat-mdc-icon-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus>.mat-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-icon-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface-variant) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-icon-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-icon-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-icon-button-touch-target-display, block)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button[disabled],.mat-mdc-icon-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-icon-button-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-icon-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-icon-button img,.mat-mdc-icon-button svg{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px);vertical-align:baseline}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button[hidden]{display:none}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}', $V
      ],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})();
var Lr = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe, Zl, pe]})
  } return n
})();
var Xm = class {};
function Jm(n) {
  return n && typeof n.connect == 'function' && !(n instanceof sr)
}
var aa = function(n) {
  return n[n.REPLACED = 0] = 'REPLACED', n[n.INSERTED = 1] = 'INSERTED',
                        n[n.MOVED = 2] = 'MOVED', n[n.REMOVED = 3] = 'REMOVED',
                        n
}(aa || {}), Xl = new w('_ViewRepeater'), la = class {
  applyChanges(t, e, i, r, o) {
    t.forEachOperation((s, a, l) => {
      let c, d;
      if (s.previousIndex == null) {
        let m = i(s, a, l);
        c = e.createEmbeddedView(m.templateRef, m.context, m.index),
        d = aa.INSERTED
      } else
        l == null ? (e.remove(a), d = aa.REMOVED) :
                    (c = e.get(a), e.move(c, l), d = aa.MOVED);
      o && o({context: c?.context, operation: d, record: s})
    })
  }
  detach() {}
};
var ca = class {
  _multiple;
  _emitChanges;
  compareWith;
  _selection = new Set;
  _deselectedToEmit = [];
  _selectedToEmit = [];
  _selected;
  get selected() {
    return this._selected ||
               (this._selected = Array.from(this._selection.values())),
           this._selected
  }
  changed = new I;
  constructor(t = !1, e, i = !0, r) {
    this._multiple = t, this._emitChanges = i, this.compareWith = r,
    e && e.length &&
        (t ? e.forEach(o => this._markSelected(o)) : this._markSelected(e[0]),
         this._selectedToEmit.length = 0)
  }
  select(...t) {
    this._verifyValueAssignment(t), t.forEach(i => this._markSelected(i));
    let e = this._hasQueuedChanges();
    return this._emitChangeEvent(), e
  }
  deselect(...t) {
    this._verifyValueAssignment(t), t.forEach(i => this._unmarkSelected(i));
    let e = this._hasQueuedChanges();
    return this._emitChangeEvent(), e
  }
  setSelection(...t) {
    this._verifyValueAssignment(t);
    let e = this.selected, i = new Set(t);
    t.forEach(o => this._markSelected(o)),
        e.filter(o => !i.has(this._getConcreteValue(o, i)))
            .forEach(o => this._unmarkSelected(o));
    let r = this._hasQueuedChanges();
    return this._emitChangeEvent(), r
  }
  toggle(t) {
    return this.isSelected(t) ? this.deselect(t) : this.select(t)
  }
  clear(t = !0) {
    this._unmarkAll();
    let e = this._hasQueuedChanges();
    return t && this._emitChangeEvent(), e
  }
  isSelected(t) {
    return this._selection.has(this._getConcreteValue(t))
  }
  isEmpty() {
    return this._selection.size === 0
  }
  hasValue() {
    return !this.isEmpty()
  }
  sort(t) {
    this._multiple && this.selected && this._selected.sort(t)
  }
  isMultipleSelection() {
    return this._multiple
  }
  _emitChangeEvent() {
    this._selected = null,
    (this._selectedToEmit.length || this._deselectedToEmit.length) &&
        (this.changed.next({
          source: this,
          added: this._selectedToEmit,
          removed: this._deselectedToEmit
        }),
         this._deselectedToEmit = [], this._selectedToEmit = [])
  }
  _markSelected(t) {
    t = this._getConcreteValue(t),
    this.isSelected(t) ||
        (this._multiple || this._unmarkAll(),
         this.isSelected(t) || this._selection.add(t),
         this._emitChanges && this._selectedToEmit.push(t))
  }
  _unmarkSelected(t) {
    t = this._getConcreteValue(t),
    this.isSelected(t) &&
        (this._selection.delete(t),
         this._emitChanges && this._deselectedToEmit.push(t))
  }
  _unmarkAll() {
    this.isEmpty() || this._selection.forEach(t => this._unmarkSelected(t))
  }
  _verifyValueAssignment(t) {
    t.length > 1 && this._multiple
  }
  _hasQueuedChanges() {
    return !!(this._deselectedToEmit.length || this._selectedToEmit.length)
  }
  _getConcreteValue(t, e) {
    if (this.compareWith) {
      e = e ?? this._selection;
      for (let i of e)
        if (this.compareWith(t, i)) return i;
      return t
    } else
      return t
  }
};
var XV = 20,
    Vr = (() => {
      class n {
        _ngZone = u(U);
        _platform = u(Ie);
        _renderer = u(Ot).createRenderer(null, null);
        _cleanupGlobalListener;
        constructor() {}
        _scrolled = new I;
        _scrolledCount = 0;
        scrollContainers = new Map;
        register(e) {
          this.scrollContainers.has(e) ||
              this.scrollContainers.set(
                  e,
                  e.elementScrolled().subscribe(() => this._scrolled.next(e)))
        }
        deregister(e) {
          let i = this.scrollContainers.get(e);
          i && (i.unsubscribe(), this.scrollContainers.delete(e))
        }
        scrolled(e = XV) {
          return this._platform.isBrowser ? new ie(i => {
            this._cleanupGlobalListener ||
                (this._cleanupGlobalListener = this._ngZone.runOutsideAngular(
                     () => this._renderer.listen(
                         'document', 'scroll', () => this._scrolled.next())));
            let r = e > 0 ? this._scrolled.pipe(cd(e)).subscribe(i) :
                            this._scrolled.subscribe(i);
            return this._scrolledCount++, () => {
              r.unsubscribe(), this._scrolledCount--,
                  this._scrolledCount ||
                  (this._cleanupGlobalListener?.(),
                   this._cleanupGlobalListener = void 0)
            }
          }) :
                                            G()
        }
        ngOnDestroy() {
          this._cleanupGlobalListener?.(),
              this._cleanupGlobalListener = void 0,
              this.scrollContainers.forEach((e, i) => this.deregister(i)),
              this._scrolled.complete()
        }
        ancestorScrolled(e, i) {
          let r = this.getAncestorScrollContainers(e);
          return this.scrolled(i).pipe(me(o => !o || r.indexOf(o) > -1))
        }
        getAncestorScrollContainers(e) {
          let i = [];
          return this.scrollContainers.forEach(
                     (r, o) => {
                         this._scrollableContainsElement(o, e) && i.push(o)}),
                 i
        }
        _scrollableContainsElement(e, i) {
          let r = nn(i), o = e.getElementRef().nativeElement;
          do
            if (r == o) return !0;
          while (r = r.parentElement);
          return !1
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    Ki = (() => {
      class n {
        elementRef = u(L);
        scrollDispatcher = u(Vr);
        ngZone = u(U);
        dir = u(dt, {optional: !0});
        _scrollElement = this.elementRef.nativeElement;
        _destroyed = new I;
        _renderer = u(rt);
        _cleanupScroll;
        _elementScrolled = new I;
        constructor() {}
        ngOnInit() {
          this._cleanupScroll = this.ngZone.runOutsideAngular(
              () => this._renderer.listen(
                  this._scrollElement, 'scroll',
                  e => this._elementScrolled.next(e))),
          this.scrollDispatcher.register(this)
        }
        ngOnDestroy() {
          this._cleanupScroll?.(), this._elementScrolled.complete(),
              this.scrollDispatcher.deregister(this), this._destroyed.next(),
              this._destroyed.complete()
        }
        elementScrolled() {
          return this._elementScrolled
        }
        getElementRef() {
          return this.elementRef
        }
        scrollTo(e) {
          let i = this.elementRef.nativeElement,
              r = this.dir && this.dir.value == 'rtl';
          e.left == null && (e.left = r ? e.end : e.start),
              e.right == null && (e.right = r ? e.start : e.end),
              e.bottom != null &&
              (e.top = i.scrollHeight - i.clientHeight - e.bottom),
              r && Ks() != Un.NORMAL ?
              (e.left != null &&
                   (e.right = i.scrollWidth - i.clientWidth - e.left),
               Ks() == Un.INVERTED ? e.left = e.right :
                                     Ks() == Un.NEGATED &&
                       (e.left = e.right ? -e.right : e.right)) :
              e.right != null &&
                  (e.left = i.scrollWidth - i.clientWidth - e.right),
              this._applyScrollToOptions(e)
        }
        _applyScrollToOptions(e) {
          let i = this.elementRef.nativeElement;
          Rm() ? i.scrollTo(e) :
                 (e.top != null && (i.scrollTop = e.top),
                  e.left != null && (i.scrollLeft = e.left))
        }
        measureScrollOffset(e) {
          let i = 'left', r = 'right', o = this.elementRef.nativeElement;
          if (e == 'top') return o.scrollTop;
          if (e == 'bottom')
            return o.scrollHeight - o.clientHeight - o.scrollTop;
          let s = this.dir && this.dir.value == 'rtl';
          return e == 'start' ? e = s ? r : i : e == 'end' && (e = s ? i : r),
                                s && Ks() == Un.INVERTED ?
                     e == i ? o.scrollWidth - o.clientWidth - o.scrollLeft :
                              o.scrollLeft :
                     s && Ks() == Un.NEGATED ?
                     e == i ? o.scrollLeft + o.scrollWidth - o.clientWidth :
                              -o.scrollLeft :
                     e == i ? o.scrollLeft :
                              o.scrollWidth - o.clientWidth - o.scrollLeft
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdk-scrollable', ''], ['', 'cdkScrollable', '']]
        })
      } return n
    })(),
    JV = 20,
    Dn = (() => {
      class n {
        _platform = u(Ie);
        _listeners;
        _viewportSize;
        _change = new I;
        _document = u(ce, {optional: !0});
        constructor() {
          let e = u(U), i = u(Ot).createRenderer(null, null);
          e.runOutsideAngular(() => {
            if (this._platform.isBrowser) {
              let r = o => this._change.next(o);
              this._listeners = [
                i.listen('window', 'resize', r),
                i.listen('window', 'orientationchange', r)
              ]
            }
            this.change().subscribe(() => this._viewportSize = null)
          })
        }
        ngOnDestroy() {
          this._listeners?.forEach(e => e()), this._change.complete()
        }
        getViewportSize() {
          this._viewportSize || this._updateViewportSize();
          let e = {
            width: this._viewportSize.width,
            height: this._viewportSize.height
          };
          return this._platform.isBrowser || (this._viewportSize = null), e
        }
        getViewportRect() {
          let e = this.getViewportScrollPosition(),
              {width: i, height: r} = this.getViewportSize();
          return {
            top: e.top, left: e.left, bottom: e.top + r, right: e.left + i,
                height: r, width: i
          }
        }
        getViewportScrollPosition() {
          if (!this._platform.isBrowser) return {top: 0, left: 0};
          let e = this._document, i = this._getWindow(), r = e.documentElement,
              o = r.getBoundingClientRect(),
              s = -o.top || e.body.scrollTop || i.scrollY || r.scrollTop || 0,
              a = -o.left || e.body.scrollLeft || i.scrollX || r.scrollLeft ||
              0;
          return {
            top: s, left: a
          }
        }
        change(e = JV) {
          return e > 0 ? this._change.pipe(cd(e)) : this._change
        }
        _getWindow() {
          return this._document.defaultView || window
        }
        _updateViewportSize() {
          let e = this._getWindow();
          this._viewportSize = this._platform.isBrowser ?
              {width: e.innerWidth, height: e.innerHeight} :
              {width: 0, height: 0}
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
var Zi = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})(),
    Jl = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [Pr, Zi, Pr, Zi]})
      } return n
    })();
var ec = class {
  _attachedHost;
  attach(t) {
    return this._attachedHost = t, t.attach(this)
  }
  detach() {
    let t = this._attachedHost;
    t != null && (this._attachedHost = null, t.detach())
  }
  get isAttached() {
    return this._attachedHost != null
  }
  setAttachedHost(t) {
    this._attachedHost = t
  }
}
, jr = class extends ec {
  component;
  viewContainerRef;
  injector;
  componentFactoryResolver;
  projectableNodes;
  constructor(t, e, i, r, o) {
    super(), this.component = t, this.viewContainerRef = e, this.injector = i,
             this.projectableNodes = o
  }
}
, vi = class extends ec {
  templateRef;
  viewContainerRef;
  context;
  injector;
  constructor(t, e, i, r) {
    super(), this.templateRef = t, this.viewContainerRef = e, this.context = i,
             this.injector = r
  }
  get origin() {
    return this.templateRef.elementRef
  }
  attach(t, e = this.context) {
    return this.context = e, super.attach(t)
  }
  detach() {
    return this.context = void 0, super.detach()
  }
}
, Nb = class extends ec {
  element;
  constructor(t) {
    super(), this.element = t instanceof L ? t.nativeElement : t
  }
}
, da = class {
  _attachedPortal;
  _disposeFn;
  _isDisposed = !1;
  hasAttached() {
    return !!this._attachedPortal
  }
  attach(t) {
    if (t instanceof jr)
      return this._attachedPortal = t, this.attachComponentPortal(t);
    if (t instanceof vi)
      return this._attachedPortal = t, this.attachTemplatePortal(t);
    if (this.attachDomPortal && t instanceof Nb)
      return this._attachedPortal = t, this.attachDomPortal(t)
  }
  attachDomPortal = null;
  detach() {
    this._attachedPortal &&
        (this._attachedPortal.setAttachedHost(null),
         this._attachedPortal = null),
        this._invokeDisposeFn()
  }
  dispose() {
    this.hasAttached() && this.detach(), this._invokeDisposeFn(),
        this._isDisposed = !0
  }
  setDisposeFn(t) {
    this._disposeFn = t
  }
  _invokeDisposeFn() {
    this._disposeFn && (this._disposeFn(), this._disposeFn = null)
  }
};
var eh = class extends da {
  outletElement;
  _appRef;
  _defaultInjector;
  _document;
  constructor(t, e, i, r, o) {
    super(), this.outletElement = t, this._appRef = i,
             this._defaultInjector = r, this._document = o
  }
  attachComponentPortal(t) {
    let e;
    if (t.viewContainerRef) {
      let i = t.injector || t.viewContainerRef.injector,
          r = i.get(Vi, null, {optional: !0}) || void 0;
      e = t.viewContainerRef.createComponent(t.component, {
        index: t.viewContainerRef.length,
        injector: i,
        ngModuleRef: r,
        projectableNodes: t.projectableNodes || void 0
      }),
      this.setDisposeFn(() => e.destroy())
    } else
      e = Au(t.component, {
        elementInjector: t.injector || this._defaultInjector || he.NULL,
        environmentInjector: this._appRef.injector,
        projectableNodes: t.projectableNodes || void 0
      }),
      this._appRef.attachView(e.hostView), this.setDisposeFn(() => {
        this._appRef.viewCount > 0 && this._appRef.detachView(e.hostView),
        e.destroy()
      });
    return this.outletElement.appendChild(this._getComponentRootNode(e)),
           this._attachedPortal = t, e
  }
  attachTemplatePortal(t) {
    let e = t.viewContainerRef,
        i = e.createEmbeddedView(
            t.templateRef, t.context, {injector: t.injector});
    return i.rootNodes.forEach(r => this.outletElement.appendChild(r)),
           i.detectChanges(), this.setDisposeFn(() => {
             let r = e.indexOf(i);
             r !== -1 && e.remove(r)
           }),
           this._attachedPortal = t, i
  }
  attachDomPortal = t => {
    let e = t.element;
    e.parentNode;
    let i = this._document.createComment('dom-portal');
    e.parentNode.insertBefore(i, e), this.outletElement.appendChild(e),
        this._attachedPortal = t,
        super.setDisposeFn(
            () => {i.parentNode && i.parentNode.replaceChild(e, i)})
  };
  dispose() {
    super.dispose(), this.outletElement.remove()
  }
  _getComponentRootNode(t) {
    return t.hostView.rootNodes[0]
  }
};
var Lk = (() => {
  class n extends vi {
    constructor() {
      let e = u(qe), i = u(Ge);
      super(e, i)
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({
      type: n,
      selectors: [['', 'cdkPortal', '']],
      exportAs: ['cdkPortal'],
      features: [te]
    })
  } return n
})();
var Xi = (() => {
  class n extends da {
    _moduleRef = u(Vi, {optional: !0});
    _document = u(ce);
    _viewContainerRef = u(Ge);
    _isInitialized = !1;
    _attachedRef;
    constructor() {
      super()
    }
    get portal() {
      return this._attachedPortal
    }
    set portal(e) {
      this.hasAttached() && !e && !this._isInitialized ||
          (this.hasAttached() && super.detach(), e && super.attach(e),
           this._attachedPortal = e || null)
    }
    attached = new H;
    get attachedRef() {
      return this._attachedRef
    }
    ngOnInit() {
      this._isInitialized = !0
    }
    ngOnDestroy() {
      super.dispose(), this._attachedRef = this._attachedPortal = null
    }
    attachComponentPortal(e) {
      e.setAttachedHost(this);
      let i = e.viewContainerRef != null ? e.viewContainerRef :
                                           this._viewContainerRef,
          r = i.createComponent(e.component, {
            index: i.length,
            injector: e.injector || i.injector,
            projectableNodes: e.projectableNodes || void 0,
            ngModuleRef: this._moduleRef || void 0
          });
      return i !== this._viewContainerRef &&
                 this._getRootNode().appendChild(r.hostView.rootNodes[0]),
             super.setDisposeFn(() => r.destroy()), this._attachedPortal = e,
                                                    this._attachedRef = r,
                                                    this.attached.emit(r), r
    }
    attachTemplatePortal(e) {
      e.setAttachedHost(this);
      let i = this._viewContainerRef.createEmbeddedView(
          e.templateRef, e.context, {injector: e.injector});
      return super.setDisposeFn(() => this._viewContainerRef.clear()),
             this._attachedPortal = e, this._attachedRef = i,
             this.attached.emit(i), i
    }
    attachDomPortal = e => {
      let i = e.element;
      i.parentNode;
      let r = this._document.createComment('dom-portal');
      e.setAttachedHost(this), i.parentNode.insertBefore(r, i),
          this._getRootNode().appendChild(i),
          this._attachedPortal = e,
          super.setDisposeFn(
              () => {r.parentNode && r.parentNode.replaceChild(i, r)})
    };
    _getRootNode() {
      let e = this._viewContainerRef.element.nativeElement;
      return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({
      type: n,
      selectors: [['', 'cdkPortalOutlet', '']],
      inputs: {portal: [0, 'cdkPortalOutlet', 'portal']},
      outputs: {attached: 'attached'},
      exportAs: ['cdkPortalOutlet'],
      features: [te]
    })
  } return n
})();
var th = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})();
var Vk = Rm(), Pb = class {
  _viewportRuler;
  _previousHTMLStyles = {top: '', left: ''};
  _previousScrollPosition;
  _isEnabled = !1;
  _document;
  constructor(t, e) {
    this._viewportRuler = t, this._document = e
  }
  attach() {}
  enable() {
    if (this._canBeEnabled()) {
      let t = this._document.documentElement;
      this._previousScrollPosition =
          this._viewportRuler.getViewportScrollPosition(),
      this._previousHTMLStyles.left = t.style.left || '',
      this._previousHTMLStyles.top = t.style.top || '',
      t.style.left = ct(-this._previousScrollPosition.left),
      t.style.top = ct(-this._previousScrollPosition.top),
      t.classList.add('cdk-global-scrollblock'), this._isEnabled = !0
    }
  }
  disable() {
    if (this._isEnabled) {
      let t = this._document.documentElement, e = this._document.body,
          i = t.style, r = e.style, o = i.scrollBehavior || '',
          s = r.scrollBehavior || '';
      this._isEnabled = !1, i.left = this._previousHTMLStyles.left,
      i.top = this._previousHTMLStyles.top,
      t.classList.remove('cdk-global-scrollblock'),
      Vk && (i.scrollBehavior = r.scrollBehavior = 'auto'),
      window.scroll(
          this._previousScrollPosition.left, this._previousScrollPosition.top),
      Vk && (i.scrollBehavior = o, r.scrollBehavior = s)
    }
  }
  _canBeEnabled() {
    if (this._document.documentElement.classList.contains(
            'cdk-global-scrollblock') ||
        this._isEnabled)
      return !1;
    let e = this._document.body, i = this._viewportRuler.getViewportSize();
    return e.scrollHeight > i.height || e.scrollWidth > i.width
  }
};
var Fb = class {
  _scrollDispatcher;
  _ngZone;
  _viewportRuler;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  _initialScrollPosition;
  constructor(t, e, i, r) {
    this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i,
    this._config = r
  }
  attach(t) {
    this._overlayRef, this._overlayRef = t
  }
  enable() {
    if (this._scrollSubscription) return;
    let t = this._scrollDispatcher.scrolled(0).pipe(
        me(e => !e ||
               !this._overlayRef.overlayElement.contains(
                   e.getElementRef().nativeElement)));
    this._config && this._config.threshold && this._config.threshold > 1 ?
        (this._initialScrollPosition =
             this._viewportRuler.getViewportScrollPosition().top,
         this._scrollSubscription = t.subscribe(() => {
           let e = this._viewportRuler.getViewportScrollPosition().top;
           Math.abs(e - this._initialScrollPosition) > this._config.threshold ?
               this._detach() :
               this._overlayRef.updatePosition()
         })) :
        this._scrollSubscription = t.subscribe(this._detach)
  }
  disable() {
    this._scrollSubscription &&
        (this._scrollSubscription.unsubscribe(),
         this._scrollSubscription = null)
  }
  detach() {
    this.disable(), this._overlayRef = null
  }
  _detach = () => {
    this.disable(),
        this._overlayRef.hasAttached() &&
        this._ngZone.run(() => this._overlayRef.detach())
  }
}
, nh = class {
  enable() {}
  disable() {}
  attach() {}
};
function Lb(n, t) {
  return t.some(e => {
    let i = n.bottom<e.top, r = n.top>e.bottom,
        o = n.right<e.left, s = n.left>e.right;
    return i || r || o || s
  })
}
function jk(n, t) {
  return t.some(e => {
    let i = n.top<e.top, r = n.bottom>e.bottom,
        o = n.left<e.left, s = n.right>e.right;
    return i || r || o || s
  })
}
var Vb = class {
  _scrollDispatcher;
  _viewportRuler;
  _ngZone;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  constructor(t, e, i, r) {
    this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i,
    this._config = r
  }
  attach(t) {
    this._overlayRef, this._overlayRef = t
  }
  enable() {
    if (!this._scrollSubscription) {
      let t = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription =
          this._scrollDispatcher.scrolled(t).subscribe(() => {
            if (this._overlayRef.updatePosition(),
                this._config && this._config.autoClose) {
              let e = this._overlayRef.overlayElement.getBoundingClientRect(),
                  {width: i, height: r} = this._viewportRuler.getViewportSize();
              Lb(e,
                 [
                   {width: i, height: r, bottom: r, right: i, top: 0, left: 0}
                 ]) &&
                  (this.disable(),
                   this._ngZone.run(() => this._overlayRef.detach()))
            }
          })
    }
  }
  disable() {
    this._scrollSubscription &&
        (this._scrollSubscription.unsubscribe(),
         this._scrollSubscription = null)
  }
  detach() {
    this.disable(), this._overlayRef = null
  }
}
, tj = (() => {
    class n {
      _scrollDispatcher = u(Vr);
      _viewportRuler = u(Dn);
      _ngZone = u(U);
      _document = u(ce);
      constructor() {}
      noop = () => new nh;
      close = e =>
          new Fb(this._scrollDispatcher, this._ngZone, this._viewportRuler, e);
      block = () => new Pb(this._viewportRuler, this._document);
      reposition = e =>
          new Vb(this._scrollDispatcher, this._viewportRuler, this._ngZone, e);
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  ua = class {
  positionStrategy;
  scrollStrategy = new nh;
  panelClass = '';
  hasBackdrop = !1;
  backdropClass = 'cdk-overlay-dark-backdrop';
  width;
  height;
  minWidth;
  minHeight;
  maxWidth;
  maxHeight;
  direction;
  disposeOnNavigation = !1;
  constructor(t) {
    if (t) {
      let e = Object.keys(t);
      for (let i of e) t[i] !== void 0 && (this[i] = t[i])
    }
  }
};
var jb = class {
  connectionPair;
  scrollableViewProperties;
  constructor(t, e) {
    this.connectionPair = t, this.scrollableViewProperties = e
  }
};
var Wk = (() => {
  class n {
    _attachedOverlays = [];
    _document = u(ce);
    _isAttached;
    constructor() {}
    ngOnDestroy() {
      this.detach()
    }
    add(e) {
      this.remove(e), this._attachedOverlays.push(e)
    }
    remove(e) {
      let i = this._attachedOverlays.indexOf(e);
      i > -1 && this._attachedOverlays.splice(i, 1),
          this._attachedOverlays.length === 0 && this.detach()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})(),
    nj = (() => {
      class n extends Wk {
        _ngZone = u(U);
        _renderer = u(Ot).createRenderer(null, null);
        _cleanupKeydown;
        add(e) {
          super.add(e),
              this._isAttached ||
              (this._ngZone.runOutsideAngular(
                   () => {
                       this._cleanupKeydown = this._renderer.listen(
                           'body', 'keydown', this._keydownListener)}),
               this._isAttached = !0)
        }
        detach() {
          this._isAttached && (this._cleanupKeydown?.(), this._isAttached = !1)
        }
        _keydownListener = e => {
          let i = this._attachedOverlays;
          for (let r = i.length - 1; r > -1; r--)
            if (i[r]._keydownEvents.observers.length > 0) {
              this._ngZone.run(() => i[r]._keydownEvents.next(e));
              break
            }
        };
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    ij = (() => {
      class n extends Wk {
        _platform = u(Ie);
        _ngZone = u(U, {optional: !0});
        _cursorOriginalValue;
        _cursorStyleIsSet = !1;
        _pointerDownEventTarget;
        add(e) {
          if (super.add(e), !this._isAttached) {
            let i = this._document.body;
            this._ngZone ? this._ngZone.runOutsideAngular(
                               () => this._addEventListeners(i)) :
                           this._addEventListeners(i),
                this._platform.IOS && !this._cursorStyleIsSet &&
                (this._cursorOriginalValue = i.style.cursor,
                 i.style.cursor = 'pointer', this._cursorStyleIsSet = !0),
                this._isAttached = !0
          }
        }
        detach() {
          if (this._isAttached) {
            let e = this._document.body;
            e.removeEventListener('pointerdown', this._pointerDownListener, !0),
                e.removeEventListener('click', this._clickListener, !0),
                e.removeEventListener('auxclick', this._clickListener, !0),
                e.removeEventListener('contextmenu', this._clickListener, !0),
                this._platform.IOS && this._cursorStyleIsSet &&
                (e.style.cursor = this._cursorOriginalValue,
                 this._cursorStyleIsSet = !1),
                this._isAttached = !1
          }
        }
        _addEventListeners(e) {
          e.addEventListener('pointerdown', this._pointerDownListener, !0),
              e.addEventListener('click', this._clickListener, !0),
              e.addEventListener('auxclick', this._clickListener, !0),
              e.addEventListener('contextmenu', this._clickListener, !0)
        }
        _pointerDownListener = e => {
          this._pointerDownEventTarget = un(e)
        };
        _clickListener = e => {
          let i = un(e),
              r = e.type === 'click' && this._pointerDownEventTarget ?
              this._pointerDownEventTarget :
              i;
          this._pointerDownEventTarget = null;
          let o = this._attachedOverlays.slice();
          for (let s = o.length - 1; s > -1; s--) {
            let a = o[s];
            if (a._outsidePointerEvents.observers.length < 1 ||
                !a.hasAttached())
              continue;
            if (Bk(a.overlayElement, i) || Bk(a.overlayElement, r)) break;
            let l = a._outsidePointerEvents;
            this._ngZone ? this._ngZone.run(() => l.next(e)) : l.next(e)
          }
        };
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
function Bk(n, t) {
  let e = typeof ShadowRoot < 'u' && ShadowRoot, i = t;
  for (; i;) {
    if (i === n) return !0;
    i = e && i instanceof ShadowRoot ? i.host : i.parentNode
  }
  return !1
}
var qk = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['ng-component']],
      hostAttrs: ['cdk-overlay-style-loader', ''],
      decls: 0,
      vars: 0,
      template: function(i, r) {},
      styles: [
        '.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}'
      ],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})(),
    ih = (() => {
      class n {
        _platform = u(Ie);
        _containerElement;
        _document = u(ce);
        _styleLoader = u(lt);
        constructor() {}
        ngOnDestroy() {
          this._containerElement?.remove()
        }
        getContainerElement() {
          return this._loadStyles(),
                 this._containerElement || this._createContainer(),
                 this._containerElement
        }
        _createContainer() {
          let e = 'cdk-overlay-container';
          if (this._platform.isBrowser || sb()) {
            let r = this._document.querySelectorAll(
                `.${e}[platform="server"], .${e}[platform="test"]`);
            for (let o = 0; o < r.length; o++) r[o].remove()
          }
          let i = this._document.createElement('div');
          i.classList.add(e),
              sb() ?
              i.setAttribute('platform', 'test') :
              this._platform.isBrowser || i.setAttribute('platform', 'server'),
              this._document.body.appendChild(i), this._containerElement = i
        }
        _loadStyles() {
          this._styleLoader.load(qk)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })(),
    Bb = class {
  _renderer;
  _ngZone;
  element;
  _cleanupClick;
  _cleanupTransitionEnd;
  _fallbackTimeout;
  constructor(t, e, i, r) {
    this._renderer = e, this._ngZone = i, this.element = t.createElement('div'),
    this.element.classList.add('cdk-overlay-backdrop'),
    this._cleanupClick = e.listen(this.element, 'click', r)
  }
  detach() {
    this._ngZone.runOutsideAngular(() => {
      let t = this.element;
      clearTimeout(this._fallbackTimeout), this._cleanupTransitionEnd?.(),
          this._cleanupTransitionEnd =
              this._renderer.listen(t, 'transitionend', this.dispose),
          this._fallbackTimeout = setTimeout(this.dispose, 500),
          t.style.pointerEvents = 'none',
          t.classList.remove('cdk-overlay-backdrop-showing')
    })
  }
  dispose = () => {
    clearTimeout(this._fallbackTimeout), this._cleanupClick?.(),
        this._cleanupTransitionEnd?.(),
        this._cleanupClick = this._cleanupTransitionEnd =
            this._fallbackTimeout = void 0,
        this.element.remove()
  }
}
, ma = class {
  _portalOutlet;
  _host;
  _pane;
  _config;
  _ngZone;
  _keyboardDispatcher;
  _document;
  _location;
  _outsideClickDispatcher;
  _animationsDisabled;
  _injector;
  _renderer;
  _backdropClick = new I;
  _attachments = new I;
  _detachments = new I;
  _positionStrategy;
  _scrollStrategy;
  _locationChanges = ge.EMPTY;
  _backdropRef = null;
  _previousHostParent;
  _keydownEvents = new I;
  _outsidePointerEvents = new I;
  _renders = new I;
  _afterRenderRef;
  _afterNextRenderRef;
  constructor(t, e, i, r, o, s, a, l, c, d = !1, m, p) {
    this._portalOutlet = t, this._host = e, this._pane = i, this._config = r,
    this._ngZone = o, this._keyboardDispatcher = s, this._document = a,
    this._location = l, this._outsideClickDispatcher = c,
    this._animationsDisabled = d, this._injector = m, this._renderer = p,
    r.scrollStrategy &&
        (this._scrollStrategy = r.scrollStrategy,
         this._scrollStrategy.attach(this)),
    this._positionStrategy = r.positionStrategy,
    this._afterRenderRef =
        tn(() => rl(() => {this._renders.next()}, {injector: this._injector}))
  }
  get overlayElement() {
    return this._pane
  }
  get backdropElement() {
    return this._backdropRef?.element || null
  }
  get hostElement() {
    return this._host
  }
  attach(t) {
    !this._host.parentElement && this._previousHostParent &&
        this._previousHostParent.appendChild(this._host);
    let e = this._portalOutlet.attach(t);
    return this._positionStrategy && this._positionStrategy.attach(this),
           this._updateStackingOrder(), this._updateElementSize(),
           this._updateElementDirection(),
           this._scrollStrategy && this._scrollStrategy.enable(),
           this._afterNextRenderRef?.destroy(),
           this._afterNextRenderRef =
               ht(() => {this.hasAttached() && this.updatePosition()},
                  {injector: this._injector}),
           this._togglePointerEvents(!0),
           this._config.hasBackdrop && this._attachBackdrop(),
           this._config.panelClass &&
               this._toggleClasses(this._pane, this._config.panelClass, !0),
           this._attachments.next(), this._keyboardDispatcher.add(this),
           this._config.disposeOnNavigation &&
               (this._locationChanges =
                    this._location.subscribe(() => this.dispose())),
           this._outsideClickDispatcher.add(this),
           typeof e?.onDestroy == 'function' &&
               e.onDestroy(
                   () => {
                       this.hasAttached() &&
                       this._ngZone.runOutsideAngular(
                           () => Promise.resolve().then(() => this.detach()))}),
           e
  }
  detach() {
    if (!this.hasAttached()) return;
    this.detachBackdrop(), this._togglePointerEvents(!1),
        this._positionStrategy && this._positionStrategy.detach &&
        this._positionStrategy.detach(),
        this._scrollStrategy && this._scrollStrategy.disable();
    let t = this._portalOutlet.detach();
    return this._detachments.next(), this._keyboardDispatcher.remove(this),
           this._detachContentWhenEmpty(), this._locationChanges.unsubscribe(),
           this._outsideClickDispatcher.remove(this), t
  }
  dispose() {
    let t = this.hasAttached();
    this._positionStrategy && this._positionStrategy.dispose(),
        this._disposeScrollStrategy(), this._backdropRef?.dispose(),
        this._locationChanges.unsubscribe(),
        this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(),
        this._attachments.complete(), this._backdropClick.complete(),
        this._keydownEvents.complete(), this._outsidePointerEvents.complete(),
        this._outsideClickDispatcher.remove(this), this._host?.remove(),
        this._afterNextRenderRef?.destroy(),
        this._previousHostParent = this._pane = this._host = this._backdropRef =
            null,
        t && this._detachments.next(), this._detachments.complete(),
        this._afterRenderRef.destroy(), this._renders.complete()
  }
  hasAttached() {
    return this._portalOutlet.hasAttached()
  }
  backdropClick() {
    return this._backdropClick
  }
  attachments() {
    return this._attachments
  }
  detachments() {
    return this._detachments
  }
  keydownEvents() {
    return this._keydownEvents
  }
  outsidePointerEvents() {
    return this._outsidePointerEvents
  }
  getConfig() {
    return this._config
  }
  updatePosition() {
    this._positionStrategy && this._positionStrategy.apply()
  }
  updatePositionStrategy(t) {
    t !== this._positionStrategy &&
        (this._positionStrategy && this._positionStrategy.dispose(),
         this._positionStrategy = t,
         this.hasAttached() && (t.attach(this), this.updatePosition()))
  }
  updateSize(t) {
    this._config = y(y({}, this._config), t), this._updateElementSize()
  }
  setDirection(t) {
    this._config = ae(y({}, this._config), {direction: t}),
    this._updateElementDirection()
  }
  addPanelClass(t) {
    this._pane && this._toggleClasses(this._pane, t, !0)
  }
  removePanelClass(t) {
    this._pane && this._toggleClasses(this._pane, t, !1)
  }
  getDirection() {
    let t = this._config.direction;
    return t ? typeof t == 'string' ? t : t.value : 'ltr'
  }
  updateScrollStrategy(t) {
    t !== this._scrollStrategy &&
        (this._disposeScrollStrategy(), this._scrollStrategy = t,
         this.hasAttached() && (t.attach(this), t.enable()))
  }
  _updateElementDirection() {
    this._host.setAttribute('dir', this.getDirection())
  }
  _updateElementSize() {
    if (!this._pane) return;
    let t = this._pane.style;
    t.width = ct(this._config.width), t.height = ct(this._config.height),
    t.minWidth = ct(this._config.minWidth),
    t.minHeight = ct(this._config.minHeight),
    t.maxWidth = ct(this._config.maxWidth),
    t.maxHeight = ct(this._config.maxHeight)
  }
  _togglePointerEvents(t) {
    this._pane.style.pointerEvents = t ? '' : 'none'
  }
  _attachBackdrop() {
    let t = 'cdk-overlay-backdrop-showing';
    this._backdropRef?.dispose(),
        this._backdropRef = new Bb(
            this._document, this._renderer, this._ngZone,
            e => {this._backdropClick.next(e)}),
        this._animationsDisabled &&
        this._backdropRef.element.classList.add(
            'cdk-overlay-backdrop-noop-animation'),
        this._config.backdropClass &&
        this._toggleClasses(
            this._backdropRef.element, this._config.backdropClass, !0),
        this._host.parentElement.insertBefore(
            this._backdropRef.element, this._host),
        !this._animationsDisabled && typeof requestAnimationFrame < 'u' ?
        this._ngZone.runOutsideAngular(
            () => {requestAnimationFrame(
                () => this._backdropRef?.element.classList.add(t))}) :
        this._backdropRef.element.classList.add(t)
  }
  _updateStackingOrder() {
    this._host.nextSibling && this._host.parentNode.appendChild(this._host)
  }
  detachBackdrop() {
    this._animationsDisabled ?
        (this._backdropRef?.dispose(), this._backdropRef = null) :
        this._backdropRef?.detach()
  }
  _toggleClasses(t, e, i) {
    let r = Js(e || []).filter(o => !!o);
    r.length && (i ? t.classList.add(...r) : t.classList.remove(...r))
  }
  _detachContentWhenEmpty() {
    this._ngZone.runOutsideAngular(
        () => {
            let t =
                this._renders.pipe(re(Ke(this._attachments, this._detachments)))
                    .subscribe(
                        () => {
                            (!this._pane || !this._host ||
                             this._pane.children.length === 0) &&
                            (this._pane && this._config.panelClass &&
                                 this._toggleClasses(
                                     this._pane, this._config.panelClass, !1),
                             this._host && this._host.parentElement &&
                                 (this._previousHostParent =
                                      this._host.parentElement,
                                  this._host.remove()),
                             t.unsubscribe())})})
  }
  _disposeScrollStrategy() {
    let t = this._scrollStrategy;
    t?.disable(), t?.detach?.()
  }
}
, zk = 'cdk-overlay-connected-position-bounding-box', rj = /([A-Za-z%]+)$/,
  zb = class {
  _viewportRuler;
  _document;
  _platform;
  _overlayContainer;
  _overlayRef;
  _isInitialRender;
  _lastBoundingBoxSize = {width: 0, height: 0};
  _isPushed = !1;
  _canPush = !0;
  _growAfterOpen = !1;
  _hasFlexibleDimensions = !0;
  _positionLocked = !1;
  _originRect;
  _overlayRect;
  _viewportRect;
  _containerRect;
  _viewportMargin = 0;
  _scrollables = [];
  _preferredPositions = [];
  _origin;
  _pane;
  _isDisposed;
  _boundingBox;
  _lastPosition;
  _lastScrollVisibility;
  _positionChanges = new I;
  _resizeSubscription = ge.EMPTY;
  _offsetX = 0;
  _offsetY = 0;
  _transformOriginSelector;
  _appliedPanelClasses = [];
  _previousPushAmount;
  positionChanges = this._positionChanges;
  get positions() {
    return this._preferredPositions
  }
  constructor(t, e, i, r, o) {
    this._viewportRuler = e, this._document = i, this._platform = r,
    this._overlayContainer = o, this.setOrigin(t)
  }
  attach(t) {
    this._overlayRef && this._overlayRef, this._validatePositions(),
        t.hostElement.classList.add(zk),
        this._overlayRef = t, this._boundingBox = t.hostElement,
        this._pane = t.overlayElement, this._isDisposed = !1,
        this._isInitialRender = !0, this._lastPosition = null,
        this._resizeSubscription.unsubscribe(),
        this._resizeSubscription = this._viewportRuler.change().subscribe(
            () => {this._isInitialRender = !0, this.apply()})
  }
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) return;
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return
    }
    this._clearPanelClasses(), this._resetOverlayElementStyles(),
        this._resetBoundingBoxStyles(),
        this._viewportRect = this._getNarrowedViewportRect(),
        this._originRect = this._getOriginRect(),
        this._overlayRect = this._pane.getBoundingClientRect(),
        this._containerRect = this._overlayContainer.getContainerElement()
                                  .getBoundingClientRect();
    let t = this._originRect, e = this._overlayRect, i = this._viewportRect,
        r = this._containerRect, o = [], s;
    for (let a of this._preferredPositions) {
      let l = this._getOriginPoint(t, r, a), c = this._getOverlayPoint(l, e, a),
          d = this._getOverlayFit(c, e, i, a);
      if (d.isCompletelyWithinViewport) {
        this._isPushed = !1, this._applyPosition(a, l);
        return
      }
      if (this._canFitWithFlexibleDimensions(d, c, i)) {
        o.push({
          position: a,
          origin: l,
          overlayRect: e,
          boundingBoxRect: this._calculateBoundingBoxRect(l, a)
        });
        continue
      }
      (!s || s.overlayFit.visibleArea < d.visibleArea) && (s = {
        overlayFit: d,
        overlayPoint: c,
        originPoint: l,
        position: a,
        overlayRect: e
      })
    }
    if (o.length) {
      let a = null, l = -1;
      for (let c of o) {
        let d = c.boundingBoxRect.width * c.boundingBoxRect.height *
            (c.position.weight || 1);
        d > l && (l = d, a = c)
      }
      this._isPushed = !1, this._applyPosition(a.position, a.origin);
      return
    }
    if (this._canPush) {
      this._isPushed = !0, this._applyPosition(s.position, s.originPoint);
      return
    }
    this._applyPosition(s.position, s.originPoint)
  }
  detach() {
    this._clearPanelClasses(), this._lastPosition = null,
                               this._previousPushAmount = null,
                               this._resizeSubscription.unsubscribe()
  }
  dispose() {
    this._isDisposed ||
        (this._boundingBox && Lo(this._boundingBox.style, {
           top: '',
           left: '',
           right: '',
           bottom: '',
           height: '',
           width: '',
           alignItems: '',
           justifyContent: ''
         }),
         this._pane && this._resetOverlayElementStyles(),
         this._overlayRef && this._overlayRef.hostElement.classList.remove(zk),
         this.detach(), this._positionChanges.complete(),
         this._overlayRef = this._boundingBox = null, this._isDisposed = !0)
  }
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) return;
    let t = this._lastPosition;
    if (t) {
      this._originRect = this._getOriginRect(),
      this._overlayRect = this._pane.getBoundingClientRect(),
      this._viewportRect = this._getNarrowedViewportRect(),
      this._containerRect =
          this._overlayContainer.getContainerElement().getBoundingClientRect();
      let e = this._getOriginPoint(this._originRect, this._containerRect, t);
      this._applyPosition(t, e)
    } else
      this.apply()
  }
  withScrollableContainers(t) {
    return this._scrollables = t, this
  }
  withPositions(t) {
    return this._preferredPositions = t,
           t.indexOf(this._lastPosition) === -1 && (this._lastPosition = null),
           this._validatePositions(), this
  }
  withViewportMargin(t) {
    return this._viewportMargin = t, this
  }
  withFlexibleDimensions(t = !0) {
    return this._hasFlexibleDimensions = t, this
  }
  withGrowAfterOpen(t = !0) {
    return this._growAfterOpen = t, this
  }
  withPush(t = !0) {
    return this._canPush = t, this
  }
  withLockedPosition(t = !0) {
    return this._positionLocked = t, this
  }
  setOrigin(t) {
    return this._origin = t, this
  }
  withDefaultOffsetX(t) {
    return this._offsetX = t, this
  }
  withDefaultOffsetY(t) {
    return this._offsetY = t, this
  }
  withTransformOriginOn(t) {
    return this._transformOriginSelector = t, this
  }
  _getOriginPoint(t, e, i) {
    let r;
    if (i.originX == 'center')
      r = t.left + t.width / 2;
    else {
      let s = this._isRtl() ? t.right : t.left,
          a = this._isRtl() ? t.left : t.right;
      r = i.originX == 'start' ? s : a
    }
    e.left < 0 && (r -= e.left);
    let o;
    return i.originY == 'center' ? o = t.top + t.height / 2 :
                                   o = i.originY == 'top' ? t.top : t.bottom,
                                   e.top < 0 && (o -= e.top), {
      x: r, y: o
    }
  }
  _getOverlayPoint(t, e, i) {
    let r;
    i.overlayX == 'center'     ? r = -e.width / 2 :
        i.overlayX === 'start' ? r = this._isRtl() ? -e.width : 0 :
                                 r = this._isRtl() ? 0 : -e.width;
    let o;
    return i.overlayY == 'center' ? o = -e.height / 2 :
                                    o = i.overlayY == 'top' ? 0 : -e.height,
    {
      x: t.x + r, y: t.y + o
    }
  }
  _getOverlayFit(t, e, i, r) {
    let o = Uk(e), {x: s, y: a} = t, l = this._getOffset(r, 'x'),
        c = this._getOffset(r, 'y');
    l && (s += l), c && (a += c);
    let d = 0 - s, m = s + o.width - i.width, p = 0 - a,
        h = a + o.height - i.height, _ = this._subtractOverflows(o.width, d, m),
        v = this._subtractOverflows(o.height, p, h), k = _ * v;
    return {
      visibleArea: k, isCompletelyWithinViewport: o.width * o.height === k,
          fitsInViewportVertically: v === o.height,
          fitsInViewportHorizontally: _ == o.width
    }
  }
  _canFitWithFlexibleDimensions(t, e, i) {
    if (this._hasFlexibleDimensions) {
      let r = i.bottom - e.y, o = i.right - e.x,
          s = Hk(this._overlayRef.getConfig().minHeight),
          a = Hk(this._overlayRef.getConfig().minWidth),
          l = t.fitsInViewportVertically || s != null && s <= r,
          c = t.fitsInViewportHorizontally || a != null && a <= o;
      return l && c
    }
    return !1
  }
  _pushOverlayOnScreen(t, e, i) {
    if (this._previousPushAmount && this._positionLocked)
      return {
        x: t.x + this._previousPushAmount.x,
        y: t.y + this._previousPushAmount.y
      };
    let r = Uk(e), o = this._viewportRect,
        s = Math.max(t.x + r.width - o.width, 0),
        a = Math.max(t.y + r.height - o.height, 0),
        l = Math.max(o.top - i.top - t.y, 0),
        c = Math.max(o.left - i.left - t.x, 0), d = 0, m = 0;
    return r.width <= o.width ?
               d = c || -s :
               d = t.x < this._viewportMargin ? o.left - i.left - t.x : 0,
               r.height <= o.height ?
               m = l || -a :
               m = t.y < this._viewportMargin ? o.top - i.top - t.y : 0,
               this._previousPushAmount = {x: d, y: m}, {
      x: t.x + d, y: t.y + m
    }
  }
  _applyPosition(t, e) {
    if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t),
        this._setBoundingBoxStyles(e, t),
        t.panelClass && this._addPanelClasses(t.panelClass),
        this._positionChanges.observers.length) {
      let i = this._getScrollVisibility();
      if (t !== this._lastPosition || !this._lastScrollVisibility ||
          !oj(this._lastScrollVisibility, i)) {
        let r = new jb(t, i);
        this._positionChanges.next(r)
      }
      this._lastScrollVisibility = i
    }
    this._lastPosition = t, this._isInitialRender = !1
  }
  _setTransformOrigin(t) {
    if (!this._transformOriginSelector) return;
    let e = this._boundingBox.querySelectorAll(this._transformOriginSelector),
        i, r = t.overlayY;
    t.overlayX === 'center' ? i = 'center' :
        this._isRtl()       ? i = t.overlayX === 'start' ? 'right' : 'left' :
                              i = t.overlayX === 'start' ? 'left' : 'right';
    for (let o = 0; o < e.length; o++) e[o].style.transformOrigin = `${i} ${r}`
  }
  _calculateBoundingBoxRect(t, e) {
    let i = this._viewportRect, r = this._isRtl(), o, s, a;
    if (e.overlayY === 'top')
      s = t.y, o = i.height - s + this._viewportMargin;
    else if (e.overlayY === 'bottom')
      a = i.height - t.y + this._viewportMargin * 2,
      o = i.height - a + this._viewportMargin;
    else {
      let h = Math.min(i.bottom - t.y + i.top, t.y),
          _ = this._lastBoundingBoxSize.height;
      o = h * 2, s = t.y - h,
      o > _ && !this._isInitialRender && !this._growAfterOpen &&
          (s = t.y - _ / 2)
    }
    let l = e.overlayX === 'start' && !r || e.overlayX === 'end' && r,
        c = e.overlayX === 'end' && !r || e.overlayX === 'start' && r, d, m, p;
    if (c)
      p = i.width - t.x + this._viewportMargin * 2,
      d = t.x - this._viewportMargin;
    else if (l)
      m = t.x, d = i.right - t.x;
    else {
      let h = Math.min(i.right - t.x + i.left, t.x),
          _ = this._lastBoundingBoxSize.width;
      d = h * 2, m = t.x - h,
      d > _ && !this._isInitialRender && !this._growAfterOpen &&
          (m = t.x - _ / 2)
    }
    return {
      top: s, left: m, bottom: a, right: p, width: d, height: o
    }
  }
  _setBoundingBoxStyles(t, e) {
    let i = this._calculateBoundingBoxRect(t, e);
    !this._isInitialRender && !this._growAfterOpen &&
        (i.height = Math.min(i.height, this._lastBoundingBoxSize.height),
         i.width = Math.min(i.width, this._lastBoundingBoxSize.width));
    let r = {};
    if (this._hasExactPosition())
      r.top = r.left = '0', r.bottom = r.right = r.maxHeight = r.maxWidth = '',
      r.width = r.height = '100%';
    else {
      let o = this._overlayRef.getConfig().maxHeight,
          s = this._overlayRef.getConfig().maxWidth;
      r.height = ct(i.height), r.top = ct(i.top), r.bottom = ct(i.bottom),
      r.width = ct(i.width), r.left = ct(i.left), r.right = ct(i.right),
      e.overlayX === 'center' ?
          r.alignItems = 'center' :
          r.alignItems = e.overlayX === 'end' ? 'flex-end' : 'flex-start',
      e.overlayY === 'center' ?
          r.justifyContent = 'center' :
          r.justifyContent =
              e.overlayY === 'bottom' ? 'flex-end' : 'flex-start',
      o && (r.maxHeight = ct(o)), s && (r.maxWidth = ct(s))
    }
    this._lastBoundingBoxSize = i, Lo(this._boundingBox.style, r)
  }
  _resetBoundingBoxStyles() {
    Lo(this._boundingBox.style, {
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      height: '',
      width: '',
      alignItems: '',
      justifyContent: ''
    })
  }
  _resetOverlayElementStyles() {
    Lo(this._pane.style,
       {top: '', left: '', bottom: '', right: '', position: '', transform: ''})
  }
  _setOverlayElementStyles(t, e) {
    let i = {}, r = this._hasExactPosition(), o = this._hasFlexibleDimensions,
        s = this._overlayRef.getConfig();
    if (r) {
      let d = this._viewportRuler.getViewportScrollPosition();
      Lo(i, this._getExactOverlayY(e, t, d)),
          Lo(i, this._getExactOverlayX(e, t, d))
    } else
      i.position = 'static';
    let a = '', l = this._getOffset(e, 'x'), c = this._getOffset(e, 'y');
    l && (a += `translateX(${l}px) `), c && (a += `translateY(${c}px)`),
        i.transform = a.trim(),
        s.maxHeight &&
        (r ? i.maxHeight = ct(s.maxHeight) : o && (i.maxHeight = '')),
        s.maxWidth &&
        (r ? i.maxWidth = ct(s.maxWidth) : o && (i.maxWidth = '')),
        Lo(this._pane.style, i)
  }
  _getExactOverlayY(t, e, i) {
    let r = {top: '', bottom: ''},
        o = this._getOverlayPoint(e, this._overlayRect, t);
    if (this._isPushed &&
            (o = this._pushOverlayOnScreen(o, this._overlayRect, i)),
        t.overlayY === 'bottom') {
      let s = this._document.documentElement.clientHeight;
      r.bottom = `${s - (o.y + this._overlayRect.height)}px`
    } else
      r.top = ct(o.y);
    return r
  }
  _getExactOverlayX(t, e, i) {
    let r = {left: '', right: ''},
        o = this._getOverlayPoint(e, this._overlayRect, t);
    this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, i));
    let s;
    if (this._isRtl() ? s = t.overlayX === 'end' ? 'left' : 'right' :
                        s = t.overlayX === 'end' ? 'right' : 'left',
        s === 'right') {
      let a = this._document.documentElement.clientWidth;
      r.right = `${a - (o.x + this._overlayRect.width)}px`
    } else
      r.left = ct(o.x);
    return r
  }
  _getScrollVisibility() {
    let t = this._getOriginRect(), e = this._pane.getBoundingClientRect(),
        i = this._scrollables.map(
            r => r.getElementRef().nativeElement.getBoundingClientRect());
    return {
      isOriginClipped: jk(t, i), isOriginOutsideView: Lb(t, i),
          isOverlayClipped: jk(e, i), isOverlayOutsideView: Lb(e, i)
    }
  }
  _subtractOverflows(t, ...e) {
    return e.reduce((i, r) => i - Math.max(r, 0), t)
  }
  _getNarrowedViewportRect() {
    let t = this._document.documentElement.clientWidth,
        e = this._document.documentElement.clientHeight,
        i = this._viewportRuler.getViewportScrollPosition();
    return {
      top: i.top + this._viewportMargin, left: i.left + this._viewportMargin,
          right: i.left + t - this._viewportMargin,
          bottom: i.top + e - this._viewportMargin,
          width: t - 2 * this._viewportMargin,
          height: e - 2 * this._viewportMargin
    }
  }
  _isRtl() {
    return this._overlayRef.getDirection() === 'rtl'
  }
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed
  }
  _getOffset(t, e) {
    return e === 'x'      ? t.offsetX == null ? this._offsetX : t.offsetX :
        t.offsetY == null ? this._offsetY :
                            t.offsetY
  }
  _validatePositions() {}
  _addPanelClasses(t) {
    this._pane &&
        Js(t).forEach(
            e => {
                e !== '' && this._appliedPanelClasses.indexOf(e) === -1 &&
                (this._appliedPanelClasses.push(e),
                 this._pane.classList.add(e))})
  }
  _clearPanelClasses() {
    this._pane &&
        (this._appliedPanelClasses.forEach(
             t => {this._pane.classList.remove(t)}),
         this._appliedPanelClasses = [])
  }
  _getOriginRect() {
    let t = this._origin;
    if (t instanceof L) return t.nativeElement.getBoundingClientRect();
    if (t instanceof Element) return t.getBoundingClientRect();
    let e = t.width || 0, i = t.height || 0;
    return {
      top: t.y, bottom: t.y + i, left: t.x, right: t.x + e, height: i, width: e
    }
  }
};
function Lo(n, t) {
  for (let e in t) t.hasOwnProperty(e) && (n[e] = t[e]);
  return n
}
function Hk(n) {
  if (typeof n != 'number' && n != null) {
    let [t, e] = n.split(rj);
    return !e || e === 'px' ? parseFloat(t) : null
  }
  return n || null
}
function Uk(n) {
  return {
    top: Math.floor(n.top), right: Math.floor(n.right),
        bottom: Math.floor(n.bottom), left: Math.floor(n.left),
        width: Math.floor(n.width), height: Math.floor(n.height)
  }
}
function oj(n, t) {
  return n === t ? !0 :
                   n.isOriginClipped === t.isOriginClipped &&
          n.isOriginOutsideView === t.isOriginOutsideView &&
          n.isOverlayClipped === t.isOverlayClipped &&
          n.isOverlayOutsideView === t.isOverlayOutsideView
}
var $k = 'cdk-global-overlay-wrapper', Hb = class {
  _overlayRef;
  _cssPosition = 'static';
  _topOffset = '';
  _bottomOffset = '';
  _alignItems = '';
  _xPosition = '';
  _xOffset = '';
  _width = '';
  _height = '';
  _isDisposed = !1;
  attach(t) {
    let e = t.getConfig();
    this._overlayRef = t,
    this._width && !e.width && t.updateSize({width: this._width}),
    this._height && !e.height && t.updateSize({height: this._height}),
    t.hostElement.classList.add($k), this._isDisposed = !1
  }
  top(t = '') {
    return this._bottomOffset = '', this._topOffset = t,
           this._alignItems = 'flex-start', this
  }
  left(t = '') {
    return this._xOffset = t, this._xPosition = 'left', this
  }
  bottom(t = '') {
    return this._topOffset = '', this._bottomOffset = t,
           this._alignItems = 'flex-end', this
  }
  right(t = '') {
    return this._xOffset = t, this._xPosition = 'right', this
  }
  start(t = '') {
    return this._xOffset = t, this._xPosition = 'start', this
  }
  end(t = '') {
    return this._xOffset = t, this._xPosition = 'end', this
  }
  width(t = '') {
    return this._overlayRef ? this._overlayRef.updateSize({width: t}) :
                              this._width = t,
                              this
  }
  height(t = '') {
    return this._overlayRef ? this._overlayRef.updateSize({height: t}) :
                              this._height = t,
                              this
  }
  centerHorizontally(t = '') {
    return this.left(t), this._xPosition = 'center', this
  }
  centerVertically(t = '') {
    return this.top(t), this._alignItems = 'center', this
  }
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
    let t = this._overlayRef.overlayElement.style,
        e = this._overlayRef.hostElement.style,
        i = this._overlayRef.getConfig(),
        {width: r, height: o, maxWidth: s, maxHeight: a} = i,
        l = (r === '100%' || r === '100vw') &&
        (!s || s === '100%' || s === '100vw'),
        c = (o === '100%' || o === '100vh') &&
        (!a || a === '100%' || a === '100vh'),
        d = this._xPosition, m = this._xOffset,
        p = this._overlayRef.getConfig().direction === 'rtl', h = '', _ = '',
        v = '';
    l                  ? v = 'flex-start' :
        d === 'center' ? (v = 'center', p ? _ = m : h = m) :
        p              ? d === 'left' || d === 'end' ?
                         (v = 'flex-end', h = m) :
                         (d === 'right' || d === 'start') && (v = 'flex-start', _ = m) :
        d === 'left' || d === 'start' ?
            (v = 'flex-start', h = m) :
            (d === 'right' || d === 'end') && (v = 'flex-end', _ = m),
        t.position = this._cssPosition, t.marginLeft = l ? '0' : h,
        t.marginTop = c ? '0' : this._topOffset,
        t.marginBottom = this._bottomOffset, t.marginRight = l ? '0' : _,
        e.justifyContent = v, e.alignItems = c ? 'flex-start' : this._alignItems
  }
  dispose() {
    if (this._isDisposed || !this._overlayRef) return;
    let t = this._overlayRef.overlayElement.style,
        e = this._overlayRef.hostElement, i = e.style;
    e.classList.remove($k),
        i.justifyContent = i.alignItems = t.marginTop = t.marginBottom =
            t.marginLeft = t.marginRight = t.position = '',
        this._overlayRef = null, this._isDisposed = !0
  }
}
, sj = (() => {
    class n {
      _viewportRuler = u(Dn);
      _document = u(ce);
      _platform = u(Ie);
      _overlayContainer = u(ih);
      constructor() {}
      global() {
        return new Hb
      }
      flexibleConnectedTo(e) {
        return new zb(
            e, this._viewportRuler, this._document, this._platform,
            this._overlayContainer)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  St = (() => {
    class n {
      scrollStrategies = u(tj);
      _overlayContainer = u(ih);
      _positionBuilder = u(sj);
      _keyboardDispatcher = u(nj);
      _injector = u(he);
      _ngZone = u(U);
      _document = u(ce);
      _directionality = u(dt);
      _location = u(Dr);
      _outsideClickDispatcher = u(ij);
      _animationsModuleType = u(Ve, {optional: !0});
      _idGenerator = u(et);
      _renderer = u(Ot).createRenderer(null, null);
      _appRef;
      _styleLoader = u(lt);
      constructor() {}
      create(e) {
        this._styleLoader.load(qk);
        let i = this._createHostElement(), r = this._createPaneElement(i),
            o = this._createPortalOutlet(r), s = new ua(e);
        return s.direction = s.direction || this._directionality.value,
               new ma(
                   o, i, r, s, this._ngZone, this._keyboardDispatcher,
                   this._document, this._location, this._outsideClickDispatcher,
                   this._animationsModuleType === 'NoopAnimations',
                   this._injector.get(_t), this._renderer)
      }
      position() {
        return this._positionBuilder
      }
      _createPaneElement(e) {
        let i = this._document.createElement('div');
        return i.id = this._idGenerator.getId('cdk-overlay-'),
               i.classList.add('cdk-overlay-pane'), e.appendChild(i), i
      }
      _createHostElement() {
        let e = this._document.createElement('div');
        return this._overlayContainer.getContainerElement().appendChild(e), e
      }
      _createPortalOutlet(e) {
        return this._appRef || (this._appRef = this._injector.get(Yt)),
               new eh(e, null, this._appRef, this._injector, this._document)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })(),
  aj =
      [
        {
          originX: 'start',
          originY: 'bottom',
          overlayX: 'start',
          overlayY: 'top'
        },
        {
          originX: 'start',
          originY: 'top',
          overlayX: 'start',
          overlayY: 'bottom'
        },
        {originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom'},
        {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'}
      ],
  Gk = new w('cdk-connected-overlay-scroll-strategy', {
    providedIn: 'root',
    factory: () => {
      let n = u(St);
      return () => n.scrollStrategies.reposition()
    }
  }),
  tc = (() => {
    class n {
      elementRef = u(L);
      constructor() {}
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275dir = T({
        type: n,
        selectors: [
          ['', 'cdk-overlay-origin', ''], ['', 'overlay-origin', ''],
          ['', 'cdkOverlayOrigin', '']
        ],
        exportAs: ['cdkOverlayOrigin']
      })
    } return n
  })(),
  Ub = (() => {
    class n {
      _overlay = u(St);
      _dir = u(dt, {optional: !0});
      _overlayRef;
      _templatePortal;
      _backdropSubscription = ge.EMPTY;
      _attachSubscription = ge.EMPTY;
      _detachSubscription = ge.EMPTY;
      _positionSubscription = ge.EMPTY;
      _offsetX;
      _offsetY;
      _position;
      _scrollStrategyFactory = u(Gk);
      _disposeOnNavigation = !1;
      _ngZone = u(U);
      origin;
      positions;
      positionStrategy;
      get offsetX() {
        return this._offsetX
      }
      set offsetX(e) {
        this._offsetX = e,
        this._position && this._updatePositionStrategy(this._position)
      }
      get offsetY() {
        return this._offsetY
      }
      set offsetY(e) {
        this._offsetY = e,
        this._position && this._updatePositionStrategy(this._position)
      }
      width;
      height;
      minWidth;
      minHeight;
      backdropClass;
      panelClass;
      viewportMargin = 0;
      scrollStrategy;
      open = !1;
      disableClose = !1;
      transformOriginSelector;
      hasBackdrop = !1;
      lockPosition = !1;
      flexibleDimensions = !1;
      growAfterOpen = !1;
      push = !1;
      get disposeOnNavigation() {
        return this._disposeOnNavigation
      }
      set disposeOnNavigation(e) {
        this._disposeOnNavigation = e
      }
      backdropClick = new H;
      positionChange = new H;
      attach = new H;
      detach = new H;
      overlayKeydown = new H;
      overlayOutsideClick = new H;
      constructor() {
        let e = u(qe), i = u(Ge);
        this._templatePortal = new vi(e, i),
        this.scrollStrategy = this._scrollStrategyFactory()
      }
      get overlayRef() {
        return this._overlayRef
      }
      get dir() {
        return this._dir ? this._dir.value : 'ltr'
      }
      ngOnDestroy() {
        this._attachSubscription.unsubscribe(),
            this._detachSubscription.unsubscribe(),
            this._backdropSubscription.unsubscribe(),
            this._positionSubscription.unsubscribe(),
            this._overlayRef && this._overlayRef.dispose()
      }
      ngOnChanges(e) {
        this._position &&
            (this._updatePositionStrategy(this._position),
             this._overlayRef.updateSize({
               width: this.width,
               minWidth: this.minWidth,
               height: this.height,
               minHeight: this.minHeight
             }),
             e.origin && this.open && this._position.apply()),
            e.open &&
            (this.open ? this._attachOverlay() : this._detachOverlay())
      }
      _createOverlay() {
        (!this.positions || !this.positions.length) && (this.positions = aj);
        let e = this._overlayRef = this._overlay.create(this._buildConfig());
        this._attachSubscription =
            e.attachments().subscribe(() => this.attach.emit()),
        this._detachSubscription =
            e.detachments().subscribe(() => this.detach.emit()),
        e.keydownEvents().subscribe(i => {
          this.overlayKeydown.next(i),
          i.keyCode === 27 && !this.disableClose && !wt(i) &&
              (i.preventDefault(), this._detachOverlay())
        }),
        this._overlayRef.outsidePointerEvents().subscribe(i => {
          let r = this._getOriginElement(), o = un(i);
          (!r || r !== o && !r.contains(o)) && this.overlayOutsideClick.next(i)
        })
      }
      _buildConfig() {
        let e = this._position =
                this.positionStrategy || this._createPositionStrategy(),
            i = new ua({
              direction: this._dir || 'ltr',
              positionStrategy: e,
              scrollStrategy: this.scrollStrategy,
              hasBackdrop: this.hasBackdrop,
              disposeOnNavigation: this.disposeOnNavigation
            });
        return (this.width || this.width === 0) && (i.width = this.width),
               (this.height || this.height === 0) && (i.height = this.height),
               (this.minWidth || this.minWidth === 0) &&
                   (i.minWidth = this.minWidth),
               (this.minHeight || this.minHeight === 0) &&
                   (i.minHeight = this.minHeight),
               this.backdropClass && (i.backdropClass = this.backdropClass),
               this.panelClass && (i.panelClass = this.panelClass), i
      }
      _updatePositionStrategy(e) {
        let i = this.positions.map(r => ({
                                     originX: r.originX,
                                     originY: r.originY,
                                     overlayX: r.overlayX,
                                     overlayY: r.overlayY,
                                     offsetX: r.offsetX || this.offsetX,
                                     offsetY: r.offsetY || this.offsetY,
                                     panelClass: r.panelClass || void 0
                                   }));
        return e.setOrigin(this._getOrigin())
            .withPositions(i)
            .withFlexibleDimensions(this.flexibleDimensions)
            .withPush(this.push)
            .withGrowAfterOpen(this.growAfterOpen)
            .withViewportMargin(this.viewportMargin)
            .withLockedPosition(this.lockPosition)
            .withTransformOriginOn(this.transformOriginSelector)
      }
      _createPositionStrategy() {
        let e = this._overlay.position().flexibleConnectedTo(this._getOrigin());
        return this._updatePositionStrategy(e), e
      }
      _getOrigin() {
        return this.origin instanceof tc ? this.origin.elementRef : this.origin
      }
      _getOriginElement() {
        return this.origin instanceof tc ?
            this.origin.elementRef.nativeElement :
            this.origin instanceof L ? this.origin.nativeElement :
            typeof Element < 'u' && this.origin instanceof Element ?
                                       this.origin :
                                       null
      }
      _attachOverlay() {
        this._overlayRef ?
            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop :
            this._createOverlay(),
            this._overlayRef.hasAttached() ||
            this._overlayRef.attach(this._templatePortal),
            this.hasBackdrop ? this._backdropSubscription =
                                   this._overlayRef.backdropClick().subscribe(
                                       e => {this.backdropClick.emit(e)}) :
                               this._backdropSubscription.unsubscribe(),
            this._positionSubscription.unsubscribe(),
            this.positionChange.observers.length > 0 &&
            (this._positionSubscription =
                 this._position.positionChanges
                     .pipe(yf(() => this.positionChange.observers.length > 0))
                     .subscribe(e => {
                       this._ngZone.run(() => this.positionChange.emit(e)),
                       this.positionChange.observers.length === 0 &&
                           this._positionSubscription.unsubscribe()
                     }))
      }
      _detachOverlay() {
        this._overlayRef && this._overlayRef.detach(),
            this._backdropSubscription.unsubscribe(),
            this._positionSubscription.unsubscribe()
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275dir = T({
        type: n,
        selectors: [
          ['', 'cdk-connected-overlay', ''], ['', 'connected-overlay', ''],
          ['', 'cdkConnectedOverlay', '']
        ],
        inputs: {
          origin: [0, 'cdkConnectedOverlayOrigin', 'origin'],
          positions: [0, 'cdkConnectedOverlayPositions', 'positions'],
          positionStrategy:
              [0, 'cdkConnectedOverlayPositionStrategy', 'positionStrategy'],
          offsetX: [0, 'cdkConnectedOverlayOffsetX', 'offsetX'],
          offsetY: [0, 'cdkConnectedOverlayOffsetY', 'offsetY'],
          width: [0, 'cdkConnectedOverlayWidth', 'width'],
          height: [0, 'cdkConnectedOverlayHeight', 'height'],
          minWidth: [0, 'cdkConnectedOverlayMinWidth', 'minWidth'],
          minHeight: [0, 'cdkConnectedOverlayMinHeight', 'minHeight'],
          backdropClass:
              [0, 'cdkConnectedOverlayBackdropClass', 'backdropClass'],
          panelClass: [0, 'cdkConnectedOverlayPanelClass', 'panelClass'],
          viewportMargin:
              [0, 'cdkConnectedOverlayViewportMargin', 'viewportMargin'],
          scrollStrategy:
              [0, 'cdkConnectedOverlayScrollStrategy', 'scrollStrategy'],
          open: [0, 'cdkConnectedOverlayOpen', 'open'],
          disableClose: [0, 'cdkConnectedOverlayDisableClose', 'disableClose'],
          transformOriginSelector: [
            0, 'cdkConnectedOverlayTransformOriginOn', 'transformOriginSelector'
          ],
          hasBackdrop: [2, 'cdkConnectedOverlayHasBackdrop', 'hasBackdrop', q],
          lockPosition:
              [2, 'cdkConnectedOverlayLockPosition', 'lockPosition', q],
          flexibleDimensions: [
            2, 'cdkConnectedOverlayFlexibleDimensions', 'flexibleDimensions', q
          ],
          growAfterOpen:
              [2, 'cdkConnectedOverlayGrowAfterOpen', 'growAfterOpen', q],
          push: [2, 'cdkConnectedOverlayPush', 'push', q],
          disposeOnNavigation: [
            2, 'cdkConnectedOverlayDisposeOnNavigation', 'disposeOnNavigation',
            q
          ]
        },
        outputs: {
          backdropClick: 'backdropClick',
          positionChange: 'positionChange',
          attach: 'attach',
          detach: 'detach',
          overlayKeydown: 'overlayKeydown',
          overlayOutsideClick: 'overlayOutsideClick'
        },
        exportAs: ['cdkConnectedOverlay'],
        features: [Pe]
      })
    } return n
  })();
function lj(n) {
  return () => n.scrollStrategies.reposition()
}
var cj = {provide: Gk, deps: [St], useFactory: lj},
    ha = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({providers: [St, cj], imports: [Pr, th, Jl, Jl]})
      } return n
    })();
var $b = class {
  _box;
  _destroyed = new I;
  _resizeSubject = new I;
  _resizeObserver;
  _elementObservables = new Map;
  constructor(t) {
    this._box = t,
    typeof ResizeObserver < 'u' &&
        (this._resizeObserver =
             new ResizeObserver(e => this._resizeSubject.next(e)))
  }
  observe(t) {
    return this._elementObservables.has(t) ||
               this._elementObservables.set(
                   t,
                   new ie(e => {
                     let i = this._resizeSubject.subscribe(e);
                     return this._resizeObserver?.observe(t, {box: this._box}),
                            () => {
                              this._resizeObserver?.unobserve(t),
                                  i.unsubscribe(),
                                  this._elementObservables.delete(t)
                            }
                   })
                       .pipe(
                           me(e => e.some(i => i.target === t)),
                           Ni({bufferSize: 1, refCount: !0}),
                           re(this._destroyed))),
           this._elementObservables.get(t)
  }
  destroy() {
    this._destroyed.next(), this._destroyed.complete(),
        this._resizeSubject.complete(), this._elementObservables.clear()
  }
}
, rh = (() => {
    class n {
      _cleanupErrorListener;
      _observers = new Map;
      _ngZone = u(U);
      constructor() {
        typeof ResizeObserver < 'u'
      }
      ngOnDestroy() {
        for (let [, e] of this._observers) e.destroy();
        this._observers.clear(), this._cleanupErrorListener?.()
      }
      observe(e, i) {
        let r = i?.box || 'content-box';
        return this._observers.has(r) || this._observers.set(r, new $b(r)),
               this._observers.get(r).observe(e)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })();
var we = function(n) {
  return n[n.State = 0] = 'State', n[n.Transition = 1] = 'Transition',
                     n[n.Sequence = 2] = 'Sequence', n[n.Group = 3] = 'Group',
                     n[n.Animate = 4] = 'Animate',
                     n[n.Keyframes = 5] = 'Keyframes', n[n.Style = 6] = 'Style',
                     n[n.Trigger = 7] = 'Trigger',
                     n[n.Reference = 8] = 'Reference',
                     n[n.AnimateChild = 9] = 'AnimateChild',
                     n[n.AnimateRef = 10] = 'AnimateRef',
                     n[n.Query = 11] = 'Query', n[n.Stagger = 12] = 'Stagger', n
}(we || {}), yi = '*';
function Vo(n, t) {
  return {
    type: we.Trigger, name: n, definitions: t, options: {}
  }
}
function er(n, t = null) {
  return {
    type: we.Animate, styles: t, timings: n
  }
}
function Qk(n, t = null) {
  return {
    type: we.Sequence, steps: n, options: t
  }
}
function Ft(n) {
  return {
    type: we.Style, styles: n, offset: null
  }
}
function zr(n, t, e) {
  return {
    type: we.State, name: n, styles: t, options: e
  }
}
function wi(n, t, e = null) {
  return {
    type: we.Transition, expr: n, animation: t, options: e
  }
}
function Yk(n = null) {
  return {
    type: we.AnimateChild, options: n
  }
}
function Zk(n, t, e = null) {
  return {
    type: we.Query, selector: n, animation: t, options: e
  }
}
var Br = class {
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  _started = !1;
  _destroyed = !1;
  _finished = !1;
  _position = 0;
  parentPlayer = null;
  totalTime;
  constructor(t = 0, e = 0) {
    this.totalTime = t + e
  }
  _onFinish() {
    this._finished ||
        (this._finished = !0, this._onDoneFns.forEach(t => t()),
         this._onDoneFns = [])
  }
  onStart(t) {
    this._originalOnStartFns.push(t), this._onStartFns.push(t)
  }
  onDone(t) {
    this._originalOnDoneFns.push(t), this._onDoneFns.push(t)
  }
  onDestroy(t) {
    this._onDestroyFns.push(t)
  }
  hasStarted() {
    return this._started
  }
  init() {}
  play() {
    this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
        this._started = !0
  }
  triggerMicrotask() {
    queueMicrotask(() => this._onFinish())
  }
  _onStart() {
    this._onStartFns.forEach(t => t()), this._onStartFns = []
  }
  pause() {}
  restart() {}
  finish() {
    this._onFinish()
  }
  destroy() {
    this._destroyed ||
        (this._destroyed = !0, this.hasStarted() || this._onStart(),
         this.finish(), this._onDestroyFns.forEach(t => t()),
         this._onDestroyFns = [])
  }
  reset() {
    this._started = !1, this._finished = !1,
    this._onStartFns = this._originalOnStartFns,
    this._onDoneFns = this._originalOnDoneFns
  }
  setPosition(t) {
    this._position = this.totalTime ? t * this.totalTime : 1
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1
  }
  triggerCallback(t) {
    let e = t == 'start' ? this._onStartFns : this._onDoneFns;
    e.forEach(i => i()), e.length = 0
  }
}
, nc = class {
  _onDoneFns = [];
  _onStartFns = [];
  _finished = !1;
  _started = !1;
  _destroyed = !1;
  _onDestroyFns = [];
  parentPlayer = null;
  totalTime = 0;
  players;
  constructor(t) {
    this.players = t;
    let e = 0, i = 0, r = 0, o = this.players.length;
    o == 0 ? queueMicrotask(() => this._onFinish()) :
             this.players.forEach(s => {
               s.onDone(() => {++e == o && this._onFinish()}),
               s.onDestroy(() => {++i == o && this._onDestroy()}),
               s.onStart(() => {++r == o && this._onStart()})
             }),
        this.totalTime =
            this.players.reduce((s, a) => Math.max(s, a.totalTime), 0)
  }
  _onFinish() {
    this._finished ||
        (this._finished = !0, this._onDoneFns.forEach(t => t()),
         this._onDoneFns = [])
  }
  init() {
    this.players.forEach(t => t.init())
  }
  onStart(t) {
    this._onStartFns.push(t)
  }
  _onStart() {
    this.hasStarted() ||
        (this._started = !0, this._onStartFns.forEach(t => t()),
         this._onStartFns = [])
  }
  onDone(t) {
    this._onDoneFns.push(t)
  }
  onDestroy(t) {
    this._onDestroyFns.push(t)
  }
  hasStarted() {
    return this._started
  }
  play() {
    this.parentPlayer || this.init(), this._onStart(),
        this.players.forEach(t => t.play())
  }
  pause() {
    this.players.forEach(t => t.pause())
  }
  restart() {
    this.players.forEach(t => t.restart())
  }
  finish() {
    this._onFinish(), this.players.forEach(t => t.finish())
  }
  destroy() {
    this._onDestroy()
  }
  _onDestroy() {
    this._destroyed ||
        (this._destroyed = !0, this._onFinish(),
         this.players.forEach(t => t.destroy()),
         this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
  }
  reset() {
    this.players.forEach(t => t.reset()),
        this._destroyed = !1, this._finished = !1, this._started = !1
  }
  setPosition(t) {
    let e = t * this.totalTime;
    this.players.forEach(i => {
      let r = i.totalTime ? Math.min(1, e / i.totalTime) : 1;
      i.setPosition(r)
    })
  }
  getPosition() {
    let t = this.players.reduce(
        (e, i) => e === null || i.totalTime > e.totalTime ? i : e, null);
    return t != null ? t.getPosition() : 0
  }
  beforeDestroy() {
    this.players.forEach(t => {t.beforeDestroy && t.beforeDestroy()})
  }
  triggerCallback(t) {
    let e = t == 'start' ? this._onStartFns : this._onDoneFns;
    e.forEach(i => i()), e.length = 0
  }
}
, oh = '!';
var dj = ['notch'], uj = ['matFormFieldNotchedOutline', ''], mj = ['*'],
    hj = ['textField'], fj = ['iconPrefixContainer'],
    pj = ['textPrefixContainer'], gj = ['iconSuffixContainer'],
    _j = ['textSuffixContainer'],
    bj =
        [
          '*', [['mat-label']],
          [['', 'matPrefix', ''], ['', 'matIconPrefix', '']],
          [['', 'matTextPrefix', '']], [['', 'matTextSuffix', '']],
          [['', 'matSuffix', ''], ['', 'matIconSuffix', '']],
          [['mat-error'], ['', 'matError', '']],
          [['mat-hint', 3, 'align', 'end']], [['mat-hint', 'align', 'end']]
        ],
    vj = [
      '*', 'mat-label', '[matPrefix], [matIconPrefix]', '[matTextPrefix]',
      '[matTextSuffix]', '[matSuffix], [matIconSuffix]',
      'mat-error, [matError]', 'mat-hint:not([align=\'end\'])',
      'mat-hint[align=\'end\']'
    ];
function yj(n, t) {
  n&1 && B(0, 'span', 21)
}
function wj(n, t) {
  if (n & 1 && (f(0, 'label', 20), Z(1, 1), R(2, yj, 1, 0, 'span', 21), g()),
      n & 2) {
    let e = D(2);
    x('floating', e._shouldLabelFloat())('monitorResize', e._hasOutline())(
        'id', e._labelId),
        J('for', e._control.disableAutomaticLabeling ? null : e._control.id),
        b(2), de(!e.hideRequiredMarker && e._control.required ? 2 : -1)
  }
}
function xj(n, t) {
  if (n & 1 && R(0, wj, 3, 5, 'label', 20), n & 2) {
    let e = D();
    de(e._hasFloatingLabel() ? 0 : -1)
  }
}
function Cj(n, t) {
  n&1 && B(0, 'div', 7)
}
function Dj(n, t) {}
function Ej(n, t) {
  if (n & 1 && R(0, Dj, 0, 0, 'ng-template', 13), n & 2) {
    D(2);
    let e = yt(1);
    x('ngTemplateOutlet', e)
  }
}
function kj(n, t) {
  if (n & 1 && (f(0, 'div', 9), R(1, Ej, 1, 1, null, 13), g()), n & 2) {
    let e = D();
    x('matFormFieldNotchedOutlineOpen', e._shouldLabelFloat()), b(),
        de(e._forceDisplayInfixLabel() ? -1 : 1)
  }
}
function Sj(n, t) {
  n&1 && (f(0, 'div', 10, 2), Z(2, 2), g())
}
function Ij(n, t) {
  n&1 && (f(0, 'div', 11, 3), Z(2, 3), g())
}
function Mj(n, t) {}
function Tj(n, t) {
  if (n & 1 && R(0, Mj, 0, 0, 'ng-template', 13), n & 2) {
    D();
    let e = yt(1);
    x('ngTemplateOutlet', e)
  }
}
function Rj(n, t) {
  n&1 && (f(0, 'div', 14, 4), Z(2, 4), g())
}
function Aj(n, t) {
  n&1 && (f(0, 'div', 15, 5), Z(2, 5), g())
}
function Oj(n, t) {
  n&1 && B(0, 'div', 16)
}
function Nj(n, t) {
  if (n & 1 && (f(0, 'div', 18), Z(1, 6), g()), n & 2) {
    let e = D();
    x('@transitionMessages', e._subscriptAnimationState)
  }
}
function Pj(n, t) {
  if (n & 1 && (f(0, 'mat-hint', 22), E(1), g()), n & 2) {
    let e = D(2);
    x('id', e._hintLabelId), b(), Re(e.hintLabel)
  }
}
function Fj(n, t) {
  if (n & 1 &&
          (f(0, 'div', 19), R(1, Pj, 2, 2, 'mat-hint', 22), Z(2, 7),
           B(3, 'div', 23), Z(4, 8), g()),
      n & 2) {
    let e = D();
    x('@transitionMessages', e._subscriptAnimationState), b(),
        de(e.hintLabel ? 1 : -1)
  }
}
var ah = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({type: n, selectors: [['mat-label']]})
  } return n
})(),
    Lj = new w('MatError');
var Kk = (() => {
  class n {
    align = 'start';
    id = u(et).getId('mat-mdc-hint-');
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({
      type: n,
      selectors: [['mat-hint']],
      hostAttrs:
          [1, 'mat-mdc-form-field-hint', 'mat-mdc-form-field-bottom-align'],
      hostVars: 4,
      hostBindings: function(i, r) {
        i&2 &&
            (en('id', r.id), J('align', null),
             Y('mat-mdc-form-field-hint-end', r.align === 'end'))
      },
      inputs: {align: 'align', id: 'id'}
    })
  } return n
})(),
    Vj = new w('MatPrefix');
var rS = new w('MatSuffix'),
    oS = (() => {
      class n {
        set _isTextSelector(e) {
          this._isText = !0
        }
        _isText = !1;
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['', 'matSuffix', ''], ['', 'matIconSuffix', ''],
            ['', 'matTextSuffix', '']
          ],
          inputs: {_isTextSelector: [0, 'matTextSuffix', '_isTextSelector']},
          features: [ye([{provide: rS, useExisting: n}])]
        })
      } return n
    })(),
    sS = new w('FloatingLabelParent'),
    Xk = (() => {
      class n {
        _elementRef = u(L);
        get floating() {
          return this._floating
        }
        set floating(e) {
          this._floating = e, this.monitorResize && this._handleResize()
        }
        _floating = !1;
        get monitorResize() {
          return this._monitorResize
        }
        set monitorResize(e) {
          this._monitorResize = e,
          this._monitorResize ? this._subscribeToResize() :
                                this._resizeSubscription.unsubscribe()
        }
        _monitorResize = !1;
        _resizeObserver = u(rh);
        _ngZone = u(U);
        _parent = u(sS);
        _resizeSubscription = new ge;
        constructor() {}
        ngOnDestroy() {
          this._resizeSubscription.unsubscribe()
        }
        getWidth() {
          return jj(this._elementRef.nativeElement)
        }
        get element() {
          return this._elementRef.nativeElement
        }
        _handleResize() {
          setTimeout(() => this._parent._handleLabelResized())
        }
        _subscribeToResize() {
          this._resizeSubscription.unsubscribe(),
              this._ngZone.runOutsideAngular(
                  () => {
                      this._resizeSubscription =
                          this._resizeObserver
                              .observe(
                                  this._elementRef.nativeElement,
                                  {box: 'border-box'})
                              .subscribe(() => this._handleResize())})
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['label', 'matFormFieldFloatingLabel', '']],
          hostAttrs: [1, 'mdc-floating-label', 'mat-mdc-floating-label'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 && Y('mdc-floating-label--float-above', r.floating)
          },
          inputs: {floating: 'floating', monitorResize: 'monitorResize'}
        })
      } return n
    })();
function jj(n) {
  let t = n;
  if (t.offsetParent !== null) return t.scrollWidth;
  let e = t.cloneNode(!0);
  e.style.setProperty('position', 'absolute'),
      e.style.setProperty('transform', 'translate(-9999px, -9999px)'),
      document.documentElement.appendChild(e);
  let i = e.scrollWidth;
  return e.remove(), i
}
var Jk = 'mdc-line-ripple--active', sh = 'mdc-line-ripple--deactivating',
    eS = (() => {
      class n {
        _elementRef = u(L);
        _cleanupTransitionEnd;
        constructor() {
          let e = u(U), i = u(rt);
          e.runOutsideAngular(
              () => {
                  this._cleanupTransitionEnd = i.listen(
                      this._elementRef.nativeElement, 'transitionend',
                      this._handleTransitionEnd)})
        }
        activate() {
          let e = this._elementRef.nativeElement.classList;
          e.remove(sh), e.add(Jk)
        }
        deactivate() {
          this._elementRef.nativeElement.classList.add(sh)
        }
        _handleTransitionEnd = e => {
          let i = this._elementRef.nativeElement.classList, r = i.contains(sh);
          e.propertyName === 'opacity' && r && i.remove(Jk, sh)
        };
        ngOnDestroy() {
          this._cleanupTransitionEnd()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['div', 'matFormFieldLineRipple', '']],
          hostAttrs: [1, 'mdc-line-ripple']
        })
      } return n
    })(),
    tS = (() => {
      class n {
        _elementRef = u(L);
        _ngZone = u(U);
        open = !1;
        _notch;
        constructor() {}
        ngAfterViewInit() {
          let e = this._elementRef.nativeElement.querySelector(
              '.mdc-floating-label');
          e ? (this._elementRef.nativeElement.classList.add(
                   'mdc-notched-outline--upgraded'),
               typeof requestAnimationFrame == 'function' &&
                   (e.style.transitionDuration = '0s',
                    this._ngZone.runOutsideAngular(
                        () => {requestAnimationFrame(
                            () => e.style.transitionDuration = '')}))) :
              this._elementRef.nativeElement.classList.add(
                  'mdc-notched-outline--no-label')
        }
        _setNotchWidth(e) {
          !this.open || !e ?
              this._notch.nativeElement.style.width = '' :
              this._notch.nativeElement.style.width = `calc(${
                  e}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)`
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['div', 'matFormFieldNotchedOutline', '']],
          viewQuery: function(i, r) {
            if (i & 1 && oe(dj, 5), i & 2) {
              let o;
              $(o = W()) && (r._notch = o.first)
            }
          },
          hostAttrs: [1, 'mdc-notched-outline'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 && Y('mdc-notched-outline--notched', r.open)
          },
          inputs: {open: [0, 'matFormFieldNotchedOutlineOpen', 'open']},
          attrs: uj,
          ngContentSelectors: mj,
          decls: 5,
          vars: 0,
          consts: [
            ['notch', ''],
            [1, 'mat-mdc-notch-piece', 'mdc-notched-outline__leading'],
            [1, 'mat-mdc-notch-piece', 'mdc-notched-outline__notch'],
            [1, 'mat-mdc-notch-piece', 'mdc-notched-outline__trailing']
          ],
          template: function(i, r) {
            i&1 &&
                (Se(), B(0, 'div', 1), f(1, 'div', 2, 0), Z(3), g(),
                 B(4, 'div', 3))
          },
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })(),
    Bj = {
      transitionMessages:
          Vo('transitionMessages',
             [
               zr('enter', Ft({opacity: 1, transform: 'translateY(0%)'})),
               wi('void => enter',
                  [
                    Ft({opacity: 0, transform: 'translateY(-5px)'}),
                    er('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                  ])
             ])
    },
    ic = (() => {
      class n {
        value;
        stateChanges;
        id;
        placeholder;
        ngControl;
        focused;
        empty;
        shouldLabelFloat;
        required;
        disabled;
        errorState;
        controlType;
        autofilled;
        userAriaDescribedBy;
        disableAutomaticLabeling;
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({type: n})
      } return n
    })();
var rc = new w('MatFormField'), zj = new w('MAT_FORM_FIELD_DEFAULT_OPTIONS'),
    nS = 'fill', Hj = 'auto',
    iS = 'fixed', Uj = 'translateY(-50%)', xi = (() => {
                                             class n {
                                               _elementRef = u(L);
                                               _changeDetectorRef = u(Ae);
                                               _dir = u(dt);
                                               _platform = u(Ie);
                                               _idGenerator = u(et);
                                               _defaults =
                                                   u(zj, {optional: !0});
                                               _animationMode =
                                                   u(Ve, {optional: !0});
                                               _textField;
                                               _iconPrefixContainer;
                                               _textPrefixContainer;
                                               _iconSuffixContainer;
                                               _textSuffixContainer;
                                               _floatingLabel;
                                               _notchedOutline;
                                               _lineRipple;
                                               _formFieldControl;
                                               _prefixChildren;
                                               _suffixChildren;
                                               _errorChildren;
                                               _hintChildren;
                                               _labelChild = bC(ah);
                                               get hideRequiredMarker() {
                                                 return this._hideRequiredMarker
                                               }
                                               set hideRequiredMarker(e) {
                                                 this._hideRequiredMarker =
                                                     Je(e)
                                               }
                                               _hideRequiredMarker = !1;
                                               color = 'primary';
                                               get floatLabel() {
                                                 return this._floatLabel ||
                                                     this._defaults
                                                         ?.floatLabel ||
                                                     Hj
                                               }
                                               set floatLabel(e) {
                                                 e !== this._floatLabel &&
                                                     (this._floatLabel = e,
                                                      this._changeDetectorRef
                                                          .markForCheck())
                                               }
                                               _floatLabel;
                                               get appearance() {
                                                 return this._appearance
                                               }
                                               set appearance(e) {
                                                 let i = this._appearance,
                                                     r = e ||
                                                     this._defaults
                                                         ?.appearance ||
                                                     nS;
                                                 this._appearance = r,
                                                 this._appearance ===
                                                         'outline' &&
                                                     this._appearance !== i &&
                                                     (this._needsOutlineLabelOffsetUpdate =
                                                          !0)
                                               }
                                               _appearance = nS;
                                               get subscriptSizing() {
                                                 return this._subscriptSizing ||
                                                     this._defaults
                                                         ?.subscriptSizing ||
                                                     iS
                                               }
                                               set subscriptSizing(e) {
                                                 this._subscriptSizing = e ||
                                                     this._defaults
                                                         ?.subscriptSizing ||
                                                     iS
                                               }
                                               _subscriptSizing = null;
                                               get hintLabel() {
                                                 return this._hintLabel
                                               }
                                               set hintLabel(e) {
                                                 this._hintLabel = e,
                                                 this._processHints()
                                               }
                                               _hintLabel = '';
                                               _hasIconPrefix = !1;
                                               _hasTextPrefix = !1;
                                               _hasIconSuffix = !1;
                                               _hasTextSuffix = !1;
                                               _labelId = this._idGenerator.getId(
                                                   'mat-mdc-form-field-label-');
                                               _hintLabelId =
                                                   this._idGenerator.getId(
                                                       'mat-mdc-hint-');
                                               _subscriptAnimationState = '';
                                               get _control() {
                                                 return this._explicitFormFieldControl ||
                                                     this._formFieldControl
                                               }
                                               set _control(e) {
                                                 this._explicitFormFieldControl =
                                                     e
                                               }
                                               _destroyed = new I;
                                               _isFocused = null;
                                               _explicitFormFieldControl;
                                               _needsOutlineLabelOffsetUpdate =
                                                   !1;
                                               _previousControl = null;
                                               _stateChanges;
                                               _valueChanges;
                                               _describedByChanges;
                                               _injector = u(he);
                                               constructor() {
                                                 let e = this._defaults;
                                                 e &&
                                                     (e.appearance &&
                                                          (this.appearance =
                                                               e.appearance),
                                                      this._hideRequiredMarker =
                                                          !!e?.hideRequiredMarker,
                                                      e.color &&
                                                          (this.color =
                                                               e.color))
                                               }
                                               ngAfterViewInit() {
                                                 this._updateFocusState(),
                                                     this._subscriptAnimationState =
                                                         'enter',
                                                     this._changeDetectorRef
                                                         .detectChanges()
                                               }
                                               ngAfterContentInit() {
                                                 this._assertFormFieldControl(),
                                                     this._initializeSubscript(),
                                                     this._initializePrefixAndSuffix(),
                                                     this._initializeOutlineLabelOffsetSubscriptions()
                                               }
                                               ngAfterContentChecked() {
                                                 this._assertFormFieldControl(),
                                                     this._control !==
                                                         this._previousControl &&
                                                     (this._initializeControl(
                                                          this._previousControl),
                                                      this._previousControl =
                                                          this._control)
                                               }
                                               ngOnDestroy() {
                                                 this._stateChanges
                                                     ?.unsubscribe(),
                                                     this._valueChanges
                                                         ?.unsubscribe(),
                                                     this._describedByChanges
                                                         ?.unsubscribe(),
                                                     this._destroyed.next(),
                                                     this._destroyed.complete()
                                               }
                                               getLabelId = mi(
                                                   () =>
                                                       this._hasFloatingLabel() ?
                                                       this._labelId :
                                                       null);
                                               getConnectedOverlayOrigin() {
                                                 return this._textField ||
                                                     this._elementRef
                                               }
                                               _animateAndLockLabel() {
                                                 this._hasFloatingLabel() &&
                                                     (this.floatLabel =
                                                          'always')
                                               }
                                               _initializeControl(e) {
                                                 let i = this._control,
                                                     r = 'mat-mdc-form-field-type-';
                                                 e &&
                                                     this._elementRef
                                                         .nativeElement
                                                         .classList.remove(
                                                             r + e.controlType),
                                                     i.controlType &&
                                                     this._elementRef
                                                         .nativeElement
                                                         .classList.add(
                                                             r + i.controlType),
                                                     this._stateChanges
                                                         ?.unsubscribe(),
                                                     this._stateChanges =
                                                         i.stateChanges
                                                             .subscribe(() => {
                                                               this._updateFocusState(),
                                                               this._changeDetectorRef
                                                                   .markForCheck()
                                                             }),
                                                     this._describedByChanges
                                                         ?.unsubscribe(),
                                                     this._describedByChanges =
                                                         i.stateChanges
                                                             .pipe(
                                                                 Xe([
                                                                   void 0,
                                                                   void 0
                                                                 ]),
                                                                 Q(() =>
                                                                       [i.errorState,
                                                                        i.userAriaDescribedBy]),
                                                                 ud(),
                                                                 me(([
                                                                      [o, s],
                                                                      [a, l]
                                                                    ]) => o !==
                                                                            a ||
                                                                        s !==
                                                                            l))
                                                             .subscribe(
                                                                 () =>
                                                                     this._syncDescribedByIds()),
                                                     this._valueChanges
                                                         ?.unsubscribe(),
                                                     i.ngControl &&
                                                     i.ngControl.valueChanges &&
                                                     (this._valueChanges =
                                                          i.ngControl
                                                              .valueChanges
                                                              .pipe(re(
                                                                  this._destroyed))
                                                              .subscribe(
                                                                  () =>
                                                                      this._changeDetectorRef
                                                                          .markForCheck()))
                                               }
                                               _checkPrefixAndSuffixTypes() {
                                                 this._hasIconPrefix =
                                                     !!this._prefixChildren
                                                           .find(
                                                               e => !e._isText),
                                                 this._hasTextPrefix =
                                                     !!this._prefixChildren
                                                           .find(
                                                               e => e._isText),
                                                 this._hasIconSuffix =
                                                     !!this._suffixChildren
                                                           .find(
                                                               e => !e._isText),
                                                 this._hasTextSuffix =
                                                     !!this._suffixChildren
                                                           .find(e => e._isText)
                                               }
                                               _initializePrefixAndSuffix() {
                                                 this._checkPrefixAndSuffixTypes(),
                                                     Ke(this._prefixChildren
                                                            .changes,
                                                        this._suffixChildren
                                                            .changes)
                                                         .subscribe(() => {
                                                           this._checkPrefixAndSuffixTypes(),
                                                           this._changeDetectorRef
                                                               .markForCheck()
                                                         })
                                               }
                                               _initializeSubscript() {
                                                 this._hintChildren.changes
                                                     .subscribe(() => {
                                                       this._processHints(),
                                                       this._changeDetectorRef
                                                           .markForCheck()
                                                     }),
                                                     this._errorChildren.changes
                                                         .subscribe(() => {
                                                           this._syncDescribedByIds(),
                                                           this._changeDetectorRef
                                                               .markForCheck()
                                                         }),
                                                     this._validateHints(),
                                                     this._syncDescribedByIds()
                                               }
                                               _assertFormFieldControl() {
                                                 this._control
                                               }
                                               _updateFocusState() {
                                                 this._control.focused &&
                                                         !this._isFocused ?
                                                     (this._isFocused = !0,
                                                      this._lineRipple
                                                          ?.activate()) :
                                                     !this._control.focused &&
                                                         (this._isFocused ||
                                                          this._isFocused ===
                                                              null) &&
                                                         (this._isFocused = !1,
                                                          this._lineRipple
                                                              ?.deactivate()),
                                                     this._textField
                                                         ?.nativeElement
                                                         .classList.toggle(
                                                             'mdc-text-field--focused',
                                                             this._control
                                                                 .focused)
                                               }
                                               _initializeOutlineLabelOffsetSubscriptions() {
                                                 this._prefixChildren.changes
                                                     .subscribe(
                                                         () =>
                                                             this._needsOutlineLabelOffsetUpdate =
                                                                 !0),
                                                     rl(
                                                         () => {
                                                             this._needsOutlineLabelOffsetUpdate &&
                                                             (this._needsOutlineLabelOffsetUpdate =
                                                                  !1,
                                                              this._updateOutlineLabelOffset())},
                                                         {
                                                           injector:
                                                               this._injector
                                                         }),
                                                     this._dir.change
                                                         .pipe(re(
                                                             this._destroyed))
                                                         .subscribe(
                                                             () =>
                                                                 this._needsOutlineLabelOffsetUpdate =
                                                                     !0)
                                               }
                                               _shouldAlwaysFloat() {
                                                 return this.floatLabel ===
                                                     'always'
                                               }
                                               _hasOutline() {
                                                 return this.appearance ===
                                                     'outline'
                                               }
                                               _forceDisplayInfixLabel() {
                                                 return !this._platform
                                                             .isBrowser &&
                                                     this._prefixChildren
                                                         .length &&
                                                     !this._shouldLabelFloat()
                                               }
                                               _hasFloatingLabel = mi(
                                                   () => !!this._labelChild());
                                               _shouldLabelFloat() {
                                                 return this._hasFloatingLabel() ?
                                                     this._control
                                                             .shouldLabelFloat ||
                                                         this._shouldAlwaysFloat() :
                                                     !1
                                               }
                                               _shouldForward(e) {
                                                 let i = this._control ?
                                                     this._control.ngControl :
                                                     null;
                                                 return i && i[e]
                                               }
                                               _getDisplayedMessages() {
                                                 return this._errorChildren &&
                                                         this._errorChildren
                                                                 .length > 0 &&
                                                         this._control
                                                             .errorState ?
                                                     'error' :
                                                     'hint'
                                               }
                                               _handleLabelResized() {
                                                 this._refreshOutlineNotchWidth()
                                               }
                                               _refreshOutlineNotchWidth() {
                                                 !this._hasOutline() ||
                                                         !this._floatingLabel ||
                                                         !this._shouldLabelFloat() ?
                                                     this._notchedOutline
                                                         ?._setNotchWidth(0) :
                                                     this._notchedOutline
                                                         ?._setNotchWidth(
                                                             this._floatingLabel
                                                                 .getWidth())
                                               }
                                               _processHints() {
                                                 this._validateHints(),
                                                     this._syncDescribedByIds()
                                               }
                                               _validateHints() {
                                                 this._hintChildren
                                               }
                                               _syncDescribedByIds() {
                                                 if (this._control) {
                                                   let e = [];
                                                   if (this._control
                                                               .userAriaDescribedBy &&
                                                           typeof this._control
                                                                   .userAriaDescribedBy ==
                                                               'string' &&
                                                           e.push(
                                                               ...this._control
                                                                   .userAriaDescribedBy
                                                                   .split(' ')),
                                                       this._getDisplayedMessages() ===
                                                           'hint') {
                                                     let i = this._hintChildren ?
                                                         this._hintChildren
                                                             .find(
                                                                 o =>
                                                                     o.align ===
                                                                     'start') :
                                                         null,
                                                         r = this._hintChildren ?
                                                         this._hintChildren
                                                             .find(
                                                                 o =>
                                                                     o.align ===
                                                                     'end') :
                                                         null;
                                                     i ? e.push(i.id) :
                                                         this._hintLabel &&
                                                             e.push(
                                                                 this._hintLabelId),
                                                         r && e.push(r.id)
                                                   } else
                                                     this._errorChildren &&
                                                         e.push(
                                                             ...this
                                                                 ._errorChildren
                                                                 .map(
                                                                     i =>
                                                                         i.id));
                                                   this._control
                                                       .setDescribedByIds(e)
                                                 }
                                               }
                                               _updateOutlineLabelOffset() {
                                                 if (!this._hasOutline() ||
                                                     !this._floatingLabel)
                                                   return;
                                                 let e = this._floatingLabel
                                                             .element;
                                                 if (!(this._iconPrefixContainer ||
                                                       this._textPrefixContainer)) {
                                                   e.style.transform = '';
                                                   return
                                                 }
                                                 if (!this._isAttachedToDom()) {
                                                   this._needsOutlineLabelOffsetUpdate =
                                                       !0;
                                                   return
                                                 }
                                                 let i = this._iconPrefixContainer
                                                             ?.nativeElement,
                                                     r = this._textPrefixContainer
                                                             ?.nativeElement,
                                                     o = this._iconSuffixContainer
                                                             ?.nativeElement,
                                                     s = this._textSuffixContainer
                                                             ?.nativeElement,
                                                     a = i?.getBoundingClientRect()
                                                             .width ??
                                                     0,
                                                     l = r?.getBoundingClientRect()
                                                             .width ??
                                                     0,
                                                     c = o?.getBoundingClientRect()
                                                             .width ??
                                                     0,
                                                     d = s?.getBoundingClientRect()
                                                             .width ??
                                                     0,
                                                     m = this._dir.value ===
                                                         'rtl' ?
                                                     '-1' :
                                                     '1',
                                                     p = `${a + l}px`,
                                                     _ = `calc(${m} * (${
                                                         p} + var(--mat-mdc-form-field-label-offset-x, 0px)))`;
                                                 e.style.transform = `var(
        --mat-mdc-form-field-label-transform,
        ${Uj} translateX(${_})
    )`;
                                                 let v = a + l + c + d;
                                                 this._elementRef.nativeElement
                                                     .style.setProperty(
                                                         '--mat-form-field-notch-max-width',
                                                         `calc(100% - ${v}px)`)
                                               }
                                               _isAttachedToDom() {
                                                 let e = this._elementRef
                                                             .nativeElement;
                                                 if (e.getRootNode) {
                                                   let i = e.getRootNode();
                                                   return i && i !== e
                                                 }
                                                 return document.documentElement
                                                     .contains(e)
                                               }
                                               static \u0275fac = function(i) {
                                                 return new (i || n)
                                               };
                                               static \u0275cmp =
                                                   O({
                                                     type: n,
                                                     selectors:
                                                         [['mat-form-field']],
                                                     contentQueries: function(
                                                         i, r, o) {
                                                       if (i & 1 &&
                                                               (jC(o,
                                                                   r._labelChild,
                                                                   ah, 5),
                                                                Oe(o, ic, 5),
                                                                Oe(o, Vj, 5),
                                                                Oe(o, rS, 5),
                                                                Oe(o, Lj, 5),
                                                                Oe(o, Kk, 5)),
                                                           i & 2) {
                                                         BC();
                                                         let s;
                                                         $(s = W()) &&
                                                             (r._formFieldControl =
                                                                  s.first),
                                                             $(s = W()) &&
                                                             (r._prefixChildren =
                                                                  s),
                                                             $(s = W()) &&
                                                             (r._suffixChildren =
                                                                  s),
                                                             $(s = W()) &&
                                                             (r._errorChildren =
                                                                  s),
                                                             $(s = W()) &&
                                                             (r._hintChildren =
                                                                  s)
                                                       }
                                                     },
                                                     viewQuery: function(i, r) {
                                                       if (i & 1 &&
                                                               (oe(hj, 5),
                                                                oe(fj, 5),
                                                                oe(pj, 5),
                                                                oe(gj, 5),
                                                                oe(_j, 5),
                                                                oe(Xk, 5),
                                                                oe(tS, 5),
                                                                oe(eS, 5)),
                                                           i & 2) {
                                                         let o;
                                                         $(o = W()) &&
                                                             (r._textField =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._iconPrefixContainer =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._textPrefixContainer =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._iconSuffixContainer =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._textSuffixContainer =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._floatingLabel =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._notchedOutline =
                                                                  o.first),
                                                             $(o = W()) &&
                                                             (r._lineRipple =
                                                                  o.first)
                                                       }
                                                     },
                                                     hostAttrs: [
                                                       1, 'mat-mdc-form-field'
                                                     ],
                                                     hostVars: 42,
                                                     hostBindings: function(
                                                         i, r) {
                                                       i&2 &&
                                                           Y('mat-mdc-form-field-label-always-float',
                                                             r._shouldAlwaysFloat())(
                                                               'mat-mdc-form-field-has-icon-prefix',
                                                               r._hasIconPrefix)(
                                                               'mat-mdc-form-field-has-icon-suffix',
                                                               r._hasIconSuffix)(
                                                               'mat-form-field-invalid',
                                                               r._control
                                                                   .errorState)(
                                                               'mat-form-field-disabled',
                                                               r._control
                                                                   .disabled)(
                                                               'mat-form-field-autofilled',
                                                               r._control
                                                                   .autofilled)(
                                                               'mat-form-field-no-animations',
                                                               r._animationMode ===
                                                                   'NoopAnimations')(
                                                               'mat-form-field-appearance-fill',
                                                               r.appearance ==
                                                                   'fill')(
                                                               'mat-form-field-appearance-outline',
                                                               r.appearance ==
                                                                   'outline')(
                                                               'mat-form-field-hide-placeholder',
                                                               r._hasFloatingLabel() &&
                                                                   !r._shouldLabelFloat())(
                                                               'mat-focused',
                                                               r._control
                                                                   .focused)(
                                                               'mat-primary',
                                                               r.color !==
                                                                       'accent' &&
                                                                   r.color !==
                                                                       'warn')(
                                                               'mat-accent',
                                                               r.color ===
                                                                   'accent')(
                                                               'mat-warn',
                                                               r.color ===
                                                                   'warn')(
                                                               'ng-untouched',
                                                               r._shouldForward(
                                                                   'untouched'))(
                                                               'ng-touched',
                                                               r._shouldForward(
                                                                   'touched'))(
                                                               'ng-pristine',
                                                               r._shouldForward(
                                                                   'pristine'))(
                                                               'ng-dirty',
                                                               r._shouldForward(
                                                                   'dirty'))(
                                                               'ng-valid',
                                                               r._shouldForward(
                                                                   'valid'))(
                                                               'ng-invalid',
                                                               r._shouldForward(
                                                                   'invalid'))(
                                                               'ng-pending',
                                                               r._shouldForward(
                                                                   'pending'))
                                                     },
                                                     inputs: {
                                                       hideRequiredMarker:
                                                           'hideRequiredMarker',
                                                       color: 'color',
                                                       floatLabel: 'floatLabel',
                                                       appearance: 'appearance',
                                                       subscriptSizing:
                                                           'subscriptSizing',
                                                       hintLabel: 'hintLabel'
                                                     },
                                                     exportAs: ['matFormField'],
                                                     features: [ye([
                                                       {
                                                         provide: rc,
                                                         useExisting: n
                                                       },
                                                       {
                                                         provide: sS,
                                                         useExisting: n
                                                       }
                                                     ])],
                                                     ngContentSelectors: vj,
                                                     decls: 18,
                                                     vars: 21,
                                                     consts: [
                                                       ['labelTemplate', ''],
                                                       ['textField', ''],
                                                       [
                                                         'iconPrefixContainer',
                                                         ''
                                                       ],
                                                       [
                                                         'textPrefixContainer',
                                                         ''
                                                       ],
                                                       [
                                                         'textSuffixContainer',
                                                         ''
                                                       ],
                                                       [
                                                         'iconSuffixContainer',
                                                         ''
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-text-field-wrapper',
                                                         'mdc-text-field', 3,
                                                         'click'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-focus-overlay'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-flex'
                                                       ],
                                                       [
                                                         'matFormFieldNotchedOutline',
                                                         '', 3,
                                                         'matFormFieldNotchedOutlineOpen'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-icon-prefix'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-text-prefix'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-infix'
                                                       ],
                                                       [3, 'ngTemplateOutlet'],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-text-suffix'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-icon-suffix'
                                                       ],
                                                       [
                                                         'matFormFieldLineRipple',
                                                         ''
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-subscript-wrapper',
                                                         'mat-mdc-form-field-bottom-align'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-error-wrapper'
                                                       ],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-hint-wrapper'
                                                       ],
                                                       [
                                                         'matFormFieldFloatingLabel',
                                                         '', 3, 'floating',
                                                         'monitorResize', 'id'
                                                       ],
                                                       [
                                                         'aria-hidden', 'true',
                                                         1,
                                                         'mat-mdc-form-field-required-marker',
                                                         'mdc-floating-label--required'
                                                       ],
                                                       [3, 'id'],
                                                       [
                                                         1,
                                                         'mat-mdc-form-field-hint-spacer'
                                                       ]
                                                     ],
                                                     template: function(i, r) {
                                                       if (i & 1) {
                                                         let o = ee();
                                                         Se(bj),
                                                             R(0, xj, 1, 1,
                                                               'ng-template',
                                                               null, 0, dl),
                                                             f(2, 'div', 6, 1),
                                                             M('click',
                                                               function(a) {
                                                                 return N(o),
                                                                        P(r._control
                                                                              .onContainerClick(
                                                                                  a))
                                                               }),
                                                             R(4, Cj, 1, 0,
                                                               'div', 7),
                                                             f(5, 'div', 8),
                                                             R(6, kj, 2, 2,
                                                               'div', 9)(
                                                                 7, Sj, 3, 0,
                                                                 'div', 10)(
                                                                 8, Ij, 3, 0,
                                                                 'div', 11),
                                                             f(9, 'div', 12),
                                                             R(10, Tj, 1, 1,
                                                               null, 13),
                                                             Z(11), g(),
                                                             R(12, Rj, 3, 0,
                                                               'div', 14)(
                                                                 13, Aj, 3, 0,
                                                                 'div', 15),
                                                             g(),
                                                             R(14, Oj, 1, 0,
                                                               'div', 16),
                                                             g(),
                                                             f(15, 'div', 17),
                                                             R(16, Nj, 2, 1,
                                                               'div', 18)(
                                                                 17, Fj, 5, 2,
                                                                 'div', 19),
                                                             g()
                                                       }
                                                       if (i & 2) {
                                                         let o;
                                                         b(2),
                                                             Y('mdc-text-field--filled',
                                                               !r._hasOutline())(
                                                                 'mdc-text-field--outlined',
                                                                 r._hasOutline())(
                                                                 'mdc-text-field--no-label',
                                                                 !r._hasFloatingLabel())(
                                                                 'mdc-text-field--disabled',
                                                                 r._control
                                                                     .disabled)(
                                                                 'mdc-text-field--invalid',
                                                                 r._control
                                                                     .errorState),
                                                             b(2),
                                                             de(!r._hasOutline() &&
                                                                        !r._control
                                                                             .disabled ?
                                                                    4 :
                                                                    -1),
                                                             b(2),
                                                             de(r._hasOutline() ?
                                                                    6 :
                                                                    -1),
                                                             b(),
                                                             de(r._hasIconPrefix ?
                                                                    7 :
                                                                    -1),
                                                             b(),
                                                             de(r._hasTextPrefix ?
                                                                    8 :
                                                                    -1),
                                                             b(2),
                                                             de(!r._hasOutline() ||
                                                                        r._forceDisplayInfixLabel() ?
                                                                    10 :
                                                                    -1),
                                                             b(2),
                                                             de(r._hasTextSuffix ?
                                                                    12 :
                                                                    -1),
                                                             b(),
                                                             de(r._hasIconSuffix ?
                                                                    13 :
                                                                    -1),
                                                             b(),
                                                             de(r._hasOutline() ?
                                                                    -1 :
                                                                    14),
                                                             b(),
                                                             Y('mat-mdc-form-field-subscript-dynamic-size',
                                                               r.subscriptSizing ===
                                                                   'dynamic'),
                                                             b(),
                                                             de((o = r._getDisplayedMessages()) ===
                                                                        'error' ?
                                                                    16 :
                                                                    o ===
                                                                        'hint' ?
                                                                    17 :
                                                                    -1)
                                                       }
                                                     },
                                                     dependencies:
                                                         [Xk, tS, Pu, eS, Kk],
                                                     styles: [
                                                       '.mdc-text-field{display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-text-field__input{width:100%;min-width:0;border:none;border-radius:0;background:none;padding:0;-moz-appearance:none;-webkit-appearance:none;height:28px}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}.mdc-text-field__input::placeholder{opacity:0}.mdc-text-field__input::-moz-placeholder{opacity:0}.mdc-text-field__input::-webkit-input-placeholder{opacity:0}.mdc-text-field__input:-ms-input-placeholder{opacity:0}.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input::-moz-placeholder,.mdc-text-field--focused .mdc-text-field__input::-moz-placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input::-webkit-input-placeholder,.mdc-text-field--focused .mdc-text-field__input::-webkit-input-placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::-moz-placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::-webkit-input-placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive:-ms-input-placeholder{opacity:0}.mdc-text-field--outlined .mdc-text-field__input,.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-filled-text-field-input-text-color, var(--mat-sys-on-surface));caret-color:var(--mdc-filled-text-field-caret-color, var(--mat-sys-primary))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::-moz-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::-webkit-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-error-caret-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-filled-text-field-disabled-input-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-outlined-text-field-input-text-color, var(--mat-sys-on-surface));caret-color:var(--mdc-outlined-text-field-caret-color, var(--mat-sys-primary))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::-moz-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::-webkit-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-error-caret-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-outlined-text-field-disabled-input-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}@media(forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}}.mdc-text-field--filled{height:56px;border-bottom-right-radius:0;border-bottom-left-radius:0;border-top-left-radius:var(--mdc-filled-text-field-container-shape, var(--mat-sys-corner-extra-small));border-top-right-radius:var(--mdc-filled-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:var(--mdc-filled-text-field-container-color, var(--mat-sys-surface-variant))}.mdc-text-field--filled.mdc-text-field--disabled{background-color:var(--mdc-filled-text-field-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 4%, transparent))}.mdc-text-field--outlined{height:56px;overflow:visible;padding-right:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)));padding-left:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)) + 4px)}[dir=rtl] .mdc-text-field--outlined{padding-right:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)) + 4px);padding-left:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))}.mdc-floating-label{position:absolute;left:0;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label{right:0;left:auto;transform-origin:right top;text-align:right}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:auto}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label{left:auto;right:4px}.mdc-text-field--filled .mdc-floating-label{left:16px;right:auto}[dir=rtl] .mdc-text-field--filled .mdc-floating-label{left:auto;right:16px}.mdc-text-field--disabled .mdc-floating-label{cursor:default}@media(forced-colors: active){.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label{color:var(--mdc-filled-text-field-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label{color:var(--mdc-filled-text-field-focus-label-text-color, var(--mat-sys-primary))}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-floating-label{color:var(--mdc-filled-text-field-hover-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label{color:var(--mdc-filled-text-field-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-floating-label{color:var(--mdc-filled-text-field-error-label-text-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mdc-floating-label{color:var(--mdc-filled-text-field-error-focus-label-text-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-floating-label{color:var(--mdc-filled-text-field-error-hover-label-text-color, var(--mat-sys-on-error-container))}.mdc-text-field--filled .mdc-floating-label{font-family:var(--mdc-filled-text-field-label-text-font, var(--mat-sys-body-large-font));font-size:var(--mdc-filled-text-field-label-text-size, var(--mat-sys-body-large-size));font-weight:var(--mdc-filled-text-field-label-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mdc-filled-text-field-label-text-tracking, var(--mat-sys-body-large-tracking))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label{color:var(--mdc-outlined-text-field-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label{color:var(--mdc-outlined-text-field-focus-label-text-color, var(--mat-sys-primary))}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-floating-label{color:var(--mdc-outlined-text-field-hover-label-text-color, var(--mat-sys-on-surface))}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label{color:var(--mdc-outlined-text-field-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-floating-label{color:var(--mdc-outlined-text-field-error-label-text-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mdc-floating-label{color:var(--mdc-outlined-text-field-error-focus-label-text-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-floating-label{color:var(--mdc-outlined-text-field-error-hover-label-text-color, var(--mat-sys-on-error-container))}.mdc-text-field--outlined .mdc-floating-label{font-family:var(--mdc-outlined-text-field-label-text-font, var(--mat-sys-body-large-font));font-size:var(--mdc-outlined-text-field-label-text-size, var(--mat-sys-body-large-size));font-weight:var(--mdc-outlined-text-field-label-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mdc-outlined-text-field-label-text-tracking, var(--mat-sys-body-large-tracking))}.mdc-floating-label--float-above{cursor:auto;transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1);font-size:.75rem}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:0;margin-right:1px}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline{text-align:right}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mat-mdc-notch-piece{box-sizing:border-box;height:100%;pointer-events:none;border-top:1px solid;border-bottom:1px solid}.mdc-text-field--focused .mat-mdc-notch-piece{border-width:2px}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-outline-color, var(--mat-sys-outline));border-width:var(--mdc-outlined-text-field-outline-width, 1px)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-hover-outline-color, var(--mat-sys-on-surface))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-focus-outline-color, var(--mat-sys-primary))}.mdc-text-field--outlined.mdc-text-field--disabled .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-outline-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--focused):hover .mdc-notched-outline .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-hover-outline-color, var(--mat-sys-on-error-container))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-focus-outline-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mat-mdc-notch-piece{border-width:var(--mdc-outlined-text-field-focus-outline-width, 2px)}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;border-top-right-radius:0;border-bottom-right-radius:0;border-top-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))}[dir=rtl] .mdc-notched-outline__leading{border-left:none;border-right:1px solid;border-bottom-left-radius:0;border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-notched-outline__trailing{flex-grow:1;border-left:none;border-right:1px solid;border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}[dir=rtl] .mdc-notched-outline__trailing{border-left:1px solid;border-right:none;border-top-right-radius:0;border-bottom-right-radius:0;border-top-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:min(var(--mat-form-field-notch-max-width, 100%),100% - max(12px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))*2)}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none;--mat-form-field-notch-max-width: 100%}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1;border-bottom-width:var(--mdc-filled-text-field-active-indicator-height, 1px)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-active-indicator-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-hover-active-indicator-color, var(--mat-sys-on-surface))}.mdc-text-field--filled.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-disabled-active-indicator-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-active-indicator-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-hover-active-indicator-color, var(--mat-sys-on-error-container))}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-width:var(--mdc-filled-text-field-focus-active-indicator-height, 2px)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-focus-active-indicator-color, var(--mat-sys-primary))}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-error-focus-active-indicator-color, var(--mat-sys-error))}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-text-field--disabled{pointer-events:none}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;line-height:normal;pointer-events:all;will-change:auto}.mat-mdc-form-field:not(.mat-form-field-disabled) .mat-mdc-floating-label.mdc-floating-label{cursor:inherit}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto;will-change:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-form-field-disabled .mdc-text-field__input::placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input::-moz-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input::-webkit-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input:-ms-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field .mdc-notched-outline__notch{border-left:1px solid rgba(0,0,0,0)}[dir=rtl] .mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field .mdc-notched-outline__notch{border-left:none;border-right:1px solid rgba(0,0,0,0)}.mat-mdc-form-field-infix{min-height:var(--mat-form-field-container-height, 56px);padding-top:var(--mat-form-field-filled-with-label-container-padding-top, 24px);padding-bottom:var(--mat-form-field-filled-with-label-container-padding-bottom, 8px)}.mdc-text-field--outlined .mat-mdc-form-field-infix,.mdc-text-field--no-label .mat-mdc-form-field-infix{padding-top:var(--mat-form-field-container-vertical-padding, 16px);padding-bottom:var(--mat-form-field-container-vertical-padding, 16px)}.mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-floating-label{top:calc(var(--mat-form-field-container-height, 56px)/2)}.mdc-text-field--filled .mat-mdc-floating-label{display:var(--mat-form-field-filled-label-display, block)}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{--mat-mdc-form-field-label-transform: translateY(calc(calc(6.75px + var(--mat-form-field-container-height, 56px) / 2) * -1)) scale(var(--mat-mdc-form-field-floating-label-scale, 0.75));transform:var(--mat-mdc-form-field-label-transform)}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block;color:var(--mat-form-field-error-text-color, var(--mat-sys-error))}.mat-mdc-form-field-subscript-wrapper,.mat-mdc-form-field-bottom-align::before{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-subscript-text-font, var(--mat-sys-body-small-font));line-height:var(--mat-form-field-subscript-text-line-height, var(--mat-sys-body-small-line-height));font-size:var(--mat-form-field-subscript-text-size, var(--mat-sys-body-small-size));letter-spacing:var(--mat-form-field-subscript-text-tracking, var(--mat-sys-body-small-tracking));font-weight:var(--mat-form-field-subscript-text-weight, var(--mat-sys-body-small-weight))}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none;background-color:var(--mat-form-field-state-layer-color, var(--mat-sys-on-surface))}.mat-mdc-text-field-wrapper:hover .mat-mdc-form-field-focus-overlay{opacity:var(--mat-form-field-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-form-field.mat-focused .mat-mdc-form-field-focus-overlay{opacity:var(--mat-form-field-focus-state-layer-opacity, 0)}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}select.mat-mdc-form-field-input-control:not(.mat-mdc-native-select-inline) option{color:var(--mat-form-field-select-option-text-color, var(--mat-sys-neutral10))}select.mat-mdc-form-field-input-control:not(.mat-mdc-native-select-inline) option:disabled{color:var(--mat-form-field-select-disabled-option-text-color, color-mix(in srgb, var(--mat-sys-neutral10) 38%, transparent))}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none;color:var(--mat-form-field-enabled-select-arrow-color, var(--mat-sys-on-surface-variant))}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select.mat-focused .mat-mdc-form-field-infix::after{color:var(--mat-form-field-focus-select-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field-type-mat-native-select.mat-form-field-disabled .mat-mdc-form-field-infix::after{color:var(--mat-form-field-disabled-select-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}@media(forced-colors: active){.mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}}@media(forced-colors: active){.mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}}@media(forced-colors: active){.mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}}@media(forced-colors: active){.mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-container-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-form-field-container-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-form-field-container-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-form-field-container-text-tracking, var(--mat-sys-body-large-tracking));font-weight:var(--mat-form-field-container-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-floating-label--float-above{font-size:calc(var(--mat-form-field-outlined-label-text-populated-size)*var(--mat-mdc-form-field-floating-label-scale))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:var(--mat-form-field-outlined-label-text-populated-size)}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%;z-index:0}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:0 12px;box-sizing:content-box}.mat-mdc-form-field-icon-prefix{color:var(--mat-form-field-leading-icon-color, var(--mat-sys-on-surface-variant))}.mat-form-field-disabled .mat-mdc-form-field-icon-prefix{color:var(--mat-form-field-disabled-leading-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-form-field-disabled .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-disabled-trailing-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-invalid .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-trailing-icon-color, var(--mat-sys-error))}.mat-form-field-invalid:not(.mat-focused):not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper:hover .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-hover-trailing-icon-color, var(--mat-sys-on-error-container))}.mat-form-field-invalid.mat-focused .mat-mdc-text-field-wrapper .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-focus-trailing-icon-color, var(--mat-sys-error))}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field-infix:has(textarea[cols]){width:auto}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::-moz-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::-webkit-input-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::-moz-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::-moz-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::-webkit-input-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::-webkit-input-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'
                                                     ],
                                                     encapsulation: 2,
                                                     data: {
                                                       animation: [
                                                         Bj.transitionMessages
                                                       ]
                                                     },
                                                     changeDetection: 0
                                                   })
                                             } return n
                                           })(),
    tr = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe, ea, pe]})
      } return n
    })();
var $j = ['trigger'], Wj = ['panel'], qj = [[['mat-select-trigger']], '*'],
    Gj = ['mat-select-trigger', '*'];
function Qj(n, t) {
  if (n & 1 && (f(0, 'span', 4), E(1), g()), n & 2) {
    let e = D();
    b(), Re(e.placeholder)
  }
}
function Yj(n, t) {
  n&1 && Z(0)
}
function Zj(n, t) {
  if (n & 1 && (f(0, 'span', 11), E(1), g()), n & 2) {
    let e = D(2);
    b(), Re(e.triggerValue)
  }
}
function Kj(n, t) {
  if (n & 1 && (f(0, 'span', 5), R(1, Yj, 1, 0)(2, Zj, 2, 1, 'span', 11), g()),
      n & 2) {
    let e = D();
    b(), de(e.customTrigger ? 1 : 2)
  }
}
function Xj(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 12, 1), M('@transformPanel.done', function(r) {
      N(e);
      let o = D();
      return P(o._panelDoneAnimatingStream.next(r.toState))
    })('keydown', function(r) {
      N(e);
      let o = D();
      return P(o._handleKeydown(r))
    }), Z(2, 1), g()
  }
  if (n & 2) {
    let e = D();
    LC('mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ',
       e._getPanelTheme(), ''),
        x('ngClass', e.panelClass)('@transformPanel', 'showing'),
        J('id', e.id + '-panel')('aria-multiselectable', e.multiple)(
            'aria-label', e.ariaLabel || null)(
            'aria-labelledby', e._getPanelAriaLabelledby())
  }
}
var Jj = {
  transformPanelWrap:
      Vo('transformPanelWrap',
         [wi('* => void', Zk('@transformPanel', [Yk()], {optional: !0}))]),
  transformPanel:
      Vo('transformPanel',
         [
           zr('void', Ft({opacity: 0, transform: 'scale(1, 0.8)'})),
           wi('void => showing',
              er('120ms cubic-bezier(0, 0, 0.2, 1)',
                 Ft({opacity: 1, transform: 'scale(1, 1)'}))),
           wi('* => void', er('100ms linear', Ft({opacity: 0})))
         ])
};
var aS = new w('mat-select-scroll-strategy', {
  providedIn: 'root',
  factory: () => {
    let n = u(St);
    return () => n.scrollStrategies.reposition()
  }
});
function eB(n) {
  return () => n.scrollStrategies.reposition()
}
var tB = new w('MAT_SELECT_CONFIG'),
    nB = {provide: aS, deps: [St], useFactory: eB},
    iB = new w('MatSelectTrigger'), Wb = class {
  source;
  value;
  constructor(t, e) {
    this.source = t, this.value = e
  }
}
, ch = (() => {
    class n {
      _viewportRuler = u(Dn);
      _changeDetectorRef = u(Ae);
      _elementRef = u(L);
      _dir = u(dt, {optional: !0});
      _idGenerator = u(et);
      _parentFormField = u(rc, {optional: !0});
      ngControl = u(Bn, {self: !0, optional: !0});
      _liveAnnouncer = u(wk);
      _defaultOptions = u(tB, {optional: !0});
      _initialized = new I;
      options;
      optionGroups;
      customTrigger;
      _positions = [
        {
          originX: 'start',
          originY: 'bottom',
          overlayX: 'start',
          overlayY: 'top'
        },
        {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'}, {
          originX: 'start',
          originY: 'top',
          overlayX: 'start',
          overlayY: 'bottom',
          panelClass: 'mat-mdc-select-panel-above'
        },
        {
          originX: 'end',
          originY: 'top',
          overlayX: 'end',
          overlayY: 'bottom',
          panelClass: 'mat-mdc-select-panel-above'
        }
      ];
      _scrollOptionIntoView(e) {
        let i = this.options.toArray()[e];
        if (i) {
          let r = this.panel.nativeElement,
              o = Tk(e, this.options, this.optionGroups),
              s = i._getHostElement();
          e === 0 && o === 1 ?
              r.scrollTop = 0 :
              r.scrollTop =
                  Rk(s.offsetTop, s.offsetHeight, r.scrollTop, r.offsetHeight)
        }
      }
      _positioningSettled() {
        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0)
      }
      _getChangeEvent(e) {
        return new Wb(this, e)
      }
      _scrollStrategyFactory = u(aS);
      _panelOpen = !1;
      _compareWith = (e, i) => e === i;
      _uid = this._idGenerator.getId('mat-select-');
      _triggerAriaLabelledBy = null;
      _previousControl;
      _destroy = new I;
      _errorStateTracker;
      stateChanges = new I;
      disableAutomaticLabeling = !0;
      userAriaDescribedBy;
      _selectionModel;
      _keyManager;
      _preferredOverlayOrigin;
      _overlayWidth;
      _onChange = () => {};
      _onTouched = () => {};
      _valueId = this._idGenerator.getId('mat-select-value-');
      _panelDoneAnimatingStream = new I;
      _scrollStrategy;
      _overlayPanelClass = this._defaultOptions?.overlayPanelClass || '';
      get focused() {
        return this._focused || this._panelOpen
      }
      _focused = !1;
      controlType = 'mat-select';
      trigger;
      panel;
      _overlayDir;
      panelClass;
      disabled = !1;
      disableRipple = !1;
      tabIndex = 0;
      get hideSingleSelectionIndicator() {
        return this._hideSingleSelectionIndicator
      }
      set hideSingleSelectionIndicator(e) {
        this._hideSingleSelectionIndicator = e, this._syncParentProperties()
      }
      _hideSingleSelectionIndicator =
          this._defaultOptions?.hideSingleSelectionIndicator ?? !1;
      get placeholder() {
        return this._placeholder
      }
      set placeholder(e) {
        this._placeholder = e, this.stateChanges.next()
      }
      _placeholder;
      get required() {
        return this._required ??
            this.ngControl?.control?.hasValidator(Ls.required) ?? !1
      }
      set required(e) {
        this._required = e, this.stateChanges.next()
      }
      _required;
      get multiple() {
        return this._multiple
      }
      set multiple(e) {
        this._selectionModel, this._multiple = e
      }
      _multiple = !1;
      disableOptionCentering =
          this._defaultOptions?.disableOptionCentering ?? !1;
      get compareWith() {
        return this._compareWith
      }
      set compareWith(e) {
        this._compareWith = e,
        this._selectionModel && this._initializeSelection()
      }
      get value() {
        return this._value
      }
      set value(e) {
        this._assignValue(e) && this._onChange(e)
      }
      _value;
      ariaLabel = '';
      ariaLabelledby;
      get errorStateMatcher() {
        return this._errorStateTracker.matcher
      }
      set errorStateMatcher(e) {
        this._errorStateTracker.matcher = e
      }
      typeaheadDebounceInterval;
      sortComparator;
      get id() {
        return this._id
      }
      set id(e) {
        this._id = e || this._uid, this.stateChanges.next()
      }
      _id;
      get errorState() {
        return this._errorStateTracker.errorState
      }
      set errorState(e) {
        this._errorStateTracker.errorState = e
      }
      panelWidth =
          this._defaultOptions && typeof this._defaultOptions.panelWidth < 'u' ?
          this._defaultOptions.panelWidth :
          'auto';
      canSelectNullableOptions =
          this._defaultOptions?.canSelectNullableOptions ?? !1;
      optionSelectionChanges = Xn(() => {
        let e = this.options;
        return e ?
            e.changes.pipe(
                Xe(e), $e(() => Ke(...e.map(i => i.onSelectionChange)))) :
            this._initialized.pipe($e(() => this.optionSelectionChanges))
      });
      openedChange = new H;
      _openedStream = this.openedChange.pipe(me(e => e), Q(() => {}));
      _closedStream = this.openedChange.pipe(me(e => !e), Q(() => {}));
      selectionChange = new H;
      valueChange = new H;
      constructor() {
        let e = u(Gm), i = u(El, {optional: !0}), r = u(kl, {optional: !0}),
            o = u(new Qt('tabindex'), {optional: !0});
        this.ngControl && (this.ngControl.valueAccessor = this),
            this._defaultOptions?.typeaheadDebounceInterval != null &&
            (this.typeaheadDebounceInterval =
                 this._defaultOptions.typeaheadDebounceInterval),
            this._errorStateTracker =
                new na(e, this.ngControl, r, i, this.stateChanges),
            this._scrollStrategy = this._scrollStrategyFactory(),
            this.tabIndex = o == null ? 0 : parseInt(o) || 0, this.id = this.id
      }
      ngOnInit() {
        this._selectionModel = new ca(this.multiple), this.stateChanges.next(),
        this._panelDoneAnimatingStream.pipe(Rn(), re(this._destroy))
            .subscribe(() => this._panelDoneAnimating(this.panelOpen)),
        this._viewportRuler.change()
            .pipe(re(this._destroy))
            .subscribe(
                () => {
                    this.panelOpen &&
                    (this._overlayWidth =
                         this._getOverlayWidth(this._preferredOverlayOrigin),
                     this._changeDetectorRef.detectChanges())})
      }
      ngAfterContentInit() {
        this._initialized.next(), this._initialized.complete(),
            this._initKeyManager(),
            this._selectionModel.changed.pipe(re(this._destroy))
                .subscribe(e => {
                  e.added.forEach(i => i.select()),
                  e.removed.forEach(i => i.deselect())
                }),
            this.options.changes.pipe(Xe(null), re(this._destroy))
                .subscribe(
                    () => {this._resetOptions(), this._initializeSelection()})
      }
      ngDoCheck() {
        let e = this._getTriggerAriaLabelledby(), i = this.ngControl;
        if (e !== this._triggerAriaLabelledBy) {
          let r = this._elementRef.nativeElement;
          this._triggerAriaLabelledBy = e,
          e ? r.setAttribute('aria-labelledby', e) :
              r.removeAttribute('aria-labelledby')
        }
        i &&
            (this._previousControl !== i.control &&
                 (this._previousControl !== void 0 && i.disabled !== null &&
                      i.disabled !== this.disabled &&
                      (this.disabled = i.disabled),
                  this._previousControl = i.control),
             this.updateErrorState())
      }
      ngOnChanges(e) {
        (e.disabled || e.userAriaDescribedBy) && this.stateChanges.next(),
            e.typeaheadDebounceInterval && this._keyManager &&
            this._keyManager.withTypeAhead(this.typeaheadDebounceInterval)
      }
      ngOnDestroy() {
        this._keyManager?.destroy(), this._destroy.next(),
            this._destroy.complete(), this.stateChanges.complete(),
            this._clearFromModal()
      }
      toggle() {
        this.panelOpen ? this.close() : this.open()
      }
      open() {
        this._canOpen() &&
            (this._parentFormField &&
                 (this._preferredOverlayOrigin =
                      this._parentFormField.getConnectedOverlayOrigin()),
             this._overlayWidth =
                 this._getOverlayWidth(this._preferredOverlayOrigin),
             this._applyModalPanelOwnership(), this._panelOpen = !0,
             this._keyManager.withHorizontalOrientation(null),
             this._highlightCorrectOption(),
             this._changeDetectorRef.markForCheck(), this.stateChanges.next())
      }
      _trackedModal = null;
      _applyModalPanelOwnership() {
        let e = this._elementRef.nativeElement.closest(
            'body > .cdk-overlay-container [aria-modal="true"]');
        if (!e) return;
        let i = `${this.id}-panel`;
        this._trackedModal && Um(this._trackedModal, 'aria-owns', i),
            bb(e, 'aria-owns', i), this._trackedModal = e
      }
      _clearFromModal() {
        if (!this._trackedModal) return;
        let e = `${this.id}-panel`;
        Um(this._trackedModal, 'aria-owns', e), this._trackedModal = null
      }
      close() {
        this._panelOpen &&
            (this._panelOpen = !1,
             this._keyManager.withHorizontalOrientation(
                 this._isRtl() ? 'rtl' : 'ltr'),
             this._changeDetectorRef.markForCheck(), this._onTouched(),
             this.stateChanges.next())
      }
      writeValue(e) {
        this._assignValue(e)
      }
      registerOnChange(e) {
        this._onChange = e
      }
      registerOnTouched(e) {
        this._onTouched = e
      }
      setDisabledState(e) {
        this.disabled = e, this._changeDetectorRef.markForCheck(),
        this.stateChanges.next()
      }
      get panelOpen() {
        return this._panelOpen
      }
      get selected() {
        return this.multiple ? this._selectionModel?.selected || [] :
                               this._selectionModel?.selected[0]
      }
      get triggerValue() {
        if (this.empty) return '';
        if (this._multiple) {
          let e = this._selectionModel.selected.map(i => i.viewValue);
          return this._isRtl() && e.reverse(), e.join(', ')
        }
        return this._selectionModel.selected[0].viewValue
      }
      updateErrorState() {
        this._errorStateTracker.updateErrorState()
      }
      _isRtl() {
        return this._dir ? this._dir.value === 'rtl' : !1
      }
      _handleKeydown(e) {
        this.disabled ||
            (this.panelOpen ? this._handleOpenKeydown(e) :
                              this._handleClosedKeydown(e))
      }
      _handleClosedKeydown(e) {
        let i = e.keyCode, r = i === 40 || i === 38 || i === 37 || i === 39,
            o = i === 13 || i === 32, s = this._keyManager;
        if (!s.isTyping() && o && !wt(e) || (this.multiple || e.altKey) && r)
          e.preventDefault(), this.open();
        else if (!this.multiple) {
          let a = this.selected;
          s.onKeydown(e);
          let l = this.selected;
          l && a !== l && this._liveAnnouncer.announce(l.viewValue, 1e4)
        }
      }
      _handleOpenKeydown(e) {
        let i = this._keyManager, r = e.keyCode, o = r === 40 || r === 38,
            s = i.isTyping();
        if (o && e.altKey)
          e.preventDefault(), this.close();
        else if (!s && (r === 13 || r === 32) && i.activeItem && !wt(e))
          e.preventDefault(), i.activeItem._selectViaInteraction();
        else if (!s && this._multiple && r === 65 && e.ctrlKey) {
          e.preventDefault();
          let a = this.options.some(l => !l.disabled && !l.selected);
          this.options.forEach(
              l => {l.disabled || (a ? l.select() : l.deselect())})
        } else {
          let a = i.activeItemIndex;
          i.onKeydown(e),
              this._multiple && o && e.shiftKey && i.activeItem &&
              i.activeItemIndex !== a && i.activeItem._selectViaInteraction()
        }
      }
      _onFocus() {
        this.disabled || (this._focused = !0, this.stateChanges.next())
      }
      _onBlur() {
        this._focused = !1, this._keyManager?.cancelTypeahead(),
        !this.disabled && !this.panelOpen &&
            (this._onTouched(), this._changeDetectorRef.markForCheck(),
             this.stateChanges.next())
      }
      _onAttached() {
        this._overlayDir.positionChange.pipe(Ye(1)).subscribe(() => {
          this._changeDetectorRef.detectChanges(),
          this._positioningSettled()
        })
      }
      _getPanelTheme() {
        return this._parentFormField ? `mat-${this._parentFormField.color}` : ''
      }
      get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty()
      }
      _initializeSelection() {
        Promise.resolve().then(() => {
          this.ngControl && (this._value = this.ngControl.value),
          this._setSelectionByValue(this._value),
          this.stateChanges.next()
        })
      }
      _setSelectionByValue(e) {
        if (this.options.forEach(i => i.setInactiveStyles()),
            this._selectionModel.clear(), this.multiple && e)
          Array.isArray(e), e.forEach(i => this._selectOptionByValue(i)),
              this._sortValues();
        else {
          let i = this._selectOptionByValue(e);
          i ? this._keyManager.updateActiveItem(i) :
              this.panelOpen || this._keyManager.updateActiveItem(-1)
        }
        this._changeDetectorRef.markForCheck()
      }
      _selectOptionByValue(e) {
        let i = this.options.find(r => {
          if (this._selectionModel.isSelected(r)) return !1;
          try {
            return (r.value != null || this.canSelectNullableOptions) &&
                this._compareWith(r.value, e)
          } catch {
            return !1
          }
        });
        return i && this._selectionModel.select(i), i
      }
      _assignValue(e) {
        return e !== this._value || this._multiple && Array.isArray(e) ?
            (this.options && this._setSelectionByValue(e), this._value = e,
             !0) :
            !1
      }
      _skipPredicate = e => this.panelOpen ? !1 : e.disabled;
      _getOverlayWidth(e) {
        return this.panelWidth === 'auto' ?
            (e instanceof tc ? e.elementRef : e || this._elementRef)
                .nativeElement.getBoundingClientRect()
                .width :
            this.panelWidth === null ? '' :
                                       this.panelWidth
      }
      _syncParentProperties() {
        if (this.options)
          for (let e of this.options) e._changeDetectorRef.markForCheck()
      }
      _initKeyManager() {
        this._keyManager =
            new jm(this.options)
                .withTypeAhead(this.typeaheadDebounceInterval)
                .withVerticalOrientation()
                .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')
                .withHomeAndEnd()
                .withPageUpDown()
                .withAllowedModifierKeys(['shiftKey'])
                .skipPredicate(this._skipPredicate),
        this._keyManager.tabOut.subscribe(
            () => {
                this.panelOpen &&
                (!this.multiple && this._keyManager.activeItem &&
                     this._keyManager.activeItem._selectViaInteraction(),
                 this.focus(), this.close())}),
        this._keyManager.change.subscribe(
            () => {
                this._panelOpen && this.panel ?
                    this._scrollOptionIntoView(
                        this._keyManager.activeItemIndex || 0) :
                    !this._panelOpen && !this.multiple &&
                        this._keyManager.activeItem &&
                        this._keyManager.activeItem._selectViaInteraction()})
      }
      _resetOptions() {
        let e = Ke(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(re(e)).subscribe(i => {
          this._onSelect(i.source, i.isUserInput),
          i.isUserInput && !this.multiple && this._panelOpen &&
              (this.close(), this.focus())
        }),
            Ke(...this.options.map(i => i._stateChanges))
                .pipe(re(e))
                .subscribe(() => {
                  this._changeDetectorRef.detectChanges(),
                  this.stateChanges.next()
                })
      }
      _onSelect(e, i) {
        let r = this._selectionModel.isSelected(e);
        !this.canSelectNullableOptions && e.value == null && !this._multiple ?
            (e.deselect(), this._selectionModel.clear(),
             this.value != null && this._propagateChanges(e.value)) :
            (r !== e.selected &&
                 (e.selected ? this._selectionModel.select(e) :
                               this._selectionModel.deselect(e)),
             i && this._keyManager.setActiveItem(e),
             this.multiple && (this._sortValues(), i && this.focus())),
            r !== this._selectionModel.isSelected(e) &&
            this._propagateChanges(),
            this.stateChanges.next()
      }
      _sortValues() {
        if (this.multiple) {
          let e = this.options.toArray();
          this._selectionModel.sort(
              (i, r) => this.sortComparator ? this.sortComparator(i, r, e) :
                                              e.indexOf(i) - e.indexOf(r)),
              this.stateChanges.next()
        }
      }
      _propagateChanges(e) {
        let i;
        this.multiple ? i = this.selected.map(r => r.value) :
                        i = this.selected ? this.selected.value : e,
                        this._value = i, this.valueChange.emit(i),
                        this._onChange(i),
                        this.selectionChange.emit(this._getChangeEvent(i)),
                        this._changeDetectorRef.markForCheck()
      }
      _highlightCorrectOption() {
        if (this._keyManager)
          if (this.empty) {
            let e = -1;
            for (let i = 0; i < this.options.length; i++)
              if (!this.options.get(i).disabled) {
                e = i;
                break
              }
            this._keyManager.setActiveItem(e)
          } else
            this._keyManager.setActiveItem(this._selectionModel.selected[0])
      }
      _canOpen() {
        return !this._panelOpen && !this.disabled && this.options?.length > 0
      }
      focus(e) {
        this._elementRef.nativeElement.focus(e)
      }
      _getPanelAriaLabelledby() {
        if (this.ariaLabel) return null;
        let e = this._parentFormField?.getLabelId() || null,
            i = e ? e + ' ' : '';
        return this.ariaLabelledby ? i + this.ariaLabelledby : e
      }
      _getAriaActiveDescendant() {
        return this.panelOpen && this._keyManager &&
                this._keyManager.activeItem ?
            this._keyManager.activeItem.id :
            null
      }
      _getTriggerAriaLabelledby() {
        if (this.ariaLabel) return null;
        let e = this._parentFormField?.getLabelId(),
            i = (e ? e + ' ' : '') + this._valueId;
        return this.ariaLabelledby && (i += ' ' + this.ariaLabelledby), i
      }
      _panelDoneAnimating(e) {
        this.openedChange.emit(e)
      }
      setDescribedByIds(e) {
        e.length ?
            this._elementRef.nativeElement.setAttribute(
                'aria-describedby', e.join(' ')) :
            this._elementRef.nativeElement.removeAttribute('aria-describedby')
      }
      onContainerClick() {
        this.focus(), this.open()
      }
      get shouldLabelFloat() {
        return this.panelOpen || !this.empty ||
            this.focused && !!this.placeholder
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275cmp = O({
        type: n,
        selectors: [['mat-select']],
        contentQueries: function(i, r, o) {
          if (i & 1 && (Oe(o, iB, 5), Oe(o, sa, 5), Oe(o, Tb, 5)), i & 2) {
            let s;
            $(s = W()) && (r.customTrigger = s.first),
                $(s = W()) && (r.options = s),
                $(s = W()) && (r.optionGroups = s)
          }
        },
        viewQuery: function(i, r) {
          if (i & 1 && (oe($j, 5), oe(Wj, 5), oe(Ub, 5)), i & 2) {
            let o;
            $(o = W()) && (r.trigger = o.first),
                $(o = W()) && (r.panel = o.first),
                $(o = W()) && (r._overlayDir = o.first)
          }
        },
        hostAttrs: [
          'role', 'combobox', 'aria-haspopup', 'listbox', 1, 'mat-mdc-select'
        ],
        hostVars: 19,
        hostBindings: function(i, r) {
          i&1 &&
              M('keydown',
                function(s) {
                  return r._handleKeydown(s)
                })(
                  'focus',
                  function() {
                    return r._onFocus()
                  })(
                  'blur',
                  function() {
                    return r._onBlur()
                  }),
              i&2 &&
              (J('id', r.id)('tabindex', r.disabled ? -1 : r.tabIndex)(
                   'aria-controls', r.panelOpen ? r.id + '-panel' : null)(
                   'aria-expanded', r.panelOpen)(
                   'aria-label', r.ariaLabel || null)(
                   'aria-required', r.required.toString())(
                   'aria-disabled', r.disabled.toString())(
                   'aria-invalid', r.errorState)(
                   'aria-activedescendant', r._getAriaActiveDescendant()),
               Y('mat-mdc-select-disabled', r.disabled)(
                   'mat-mdc-select-invalid', r.errorState)(
                   'mat-mdc-select-required', r.required)(
                   'mat-mdc-select-empty', r.empty)(
                   'mat-mdc-select-multiple', r.multiple))
        },
        inputs: {
          userAriaDescribedBy: [0, 'aria-describedby', 'userAriaDescribedBy'],
          panelClass: 'panelClass',
          disabled: [2, 'disabled', 'disabled', q],
          disableRipple: [2, 'disableRipple', 'disableRipple', q],
          tabIndex: [2, 'tabIndex', 'tabIndex', e => e == null ? 0 : st(e)],
          hideSingleSelectionIndicator: [
            2, 'hideSingleSelectionIndicator', 'hideSingleSelectionIndicator', q
          ],
          placeholder: 'placeholder',
          required: [2, 'required', 'required', q],
          multiple: [2, 'multiple', 'multiple', q],
          disableOptionCentering:
              [2, 'disableOptionCentering', 'disableOptionCentering', q],
          compareWith: 'compareWith',
          value: 'value',
          ariaLabel: [0, 'aria-label', 'ariaLabel'],
          ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby'],
          errorStateMatcher: 'errorStateMatcher',
          typeaheadDebounceInterval:
              [2, 'typeaheadDebounceInterval', 'typeaheadDebounceInterval', st],
          sortComparator: 'sortComparator',
          id: 'id',
          panelWidth: 'panelWidth',
          canSelectNullableOptions:
              [2, 'canSelectNullableOptions', 'canSelectNullableOptions', q]
        },
        outputs: {
          openedChange: 'openedChange',
          _openedStream: 'opened',
          _closedStream: 'closed',
          selectionChange: 'selectionChange',
          valueChange: 'valueChange'
        },
        exportAs: ['matSelect'],
        features: [
          ye([{provide: ic, useExisting: n}, {provide: Mb, useExisting: n}]), Pe
        ],
        ngContentSelectors: Gj,
        decls: 11,
        vars: 8,
        consts: [
          ['fallbackOverlayOrigin', 'cdkOverlayOrigin', 'trigger', ''],
          ['panel', ''],
          ['cdk-overlay-origin', '', 1, 'mat-mdc-select-trigger', 3, 'click'],
          [1, 'mat-mdc-select-value'],
          [1, 'mat-mdc-select-placeholder', 'mat-mdc-select-min-line'],
          [1, 'mat-mdc-select-value-text'], [1, 'mat-mdc-select-arrow-wrapper'],
          [1, 'mat-mdc-select-arrow'],
          [
            'viewBox', '0 0 24 24', 'width', '24px', 'height', '24px',
            'focusable', 'false', 'aria-hidden', 'true'
          ],
          ['d', 'M7 10l5 5 5-5z'],
          [
            'cdk-connected-overlay', '', 'cdkConnectedOverlayLockPosition', '',
            'cdkConnectedOverlayHasBackdrop', '',
            'cdkConnectedOverlayBackdropClass',
            'cdk-overlay-transparent-backdrop', 3, 'backdropClick', 'attach',
            'detach', 'cdkConnectedOverlayPanelClass',
            'cdkConnectedOverlayScrollStrategy', 'cdkConnectedOverlayOrigin',
            'cdkConnectedOverlayOpen', 'cdkConnectedOverlayPositions',
            'cdkConnectedOverlayWidth'
          ],
          [1, 'mat-mdc-select-min-line'],
          ['role', 'listbox', 'tabindex', '-1', 3, 'keydown', 'ngClass']
        ],
        template: function(i, r) {
          if (i & 1) {
            let o = ee();
            Se(qj), f(0, 'div', 2, 0),
                M('click',
                  function() {
                    return N(o), P(r.open())
                  }),
                f(3, 'div', 3),
                R(4, Qj, 2, 1, 'span', 4)(5, Kj, 3, 1, 'span', 5), g(),
                f(6, 'div', 6)(7, 'div', 7), Bt(), f(8, 'svg', 8),
                B(9, 'path', 9), g()()()(), R(10, Xj, 3, 9, 'ng-template', 10),
                M('backdropClick', function() {
                  return N(o), P(r.close())
                })('attach', function() {
                  return N(o), P(r._onAttached())
                })('detach', function() {
                  return N(o), P(r.close())
                })
          }
          if (i & 2) {
            let o = yt(1);
            b(3), J('id', r._valueId), b(), de(r.empty ? 4 : 5), b(6),
                x('cdkConnectedOverlayPanelClass', r._overlayPanelClass)(
                    'cdkConnectedOverlayScrollStrategy', r._scrollStrategy)(
                    'cdkConnectedOverlayOrigin',
                    r._preferredOverlayOrigin || o)(
                    'cdkConnectedOverlayOpen', r.panelOpen)(
                    'cdkConnectedOverlayPositions', r._positions)(
                    'cdkConnectedOverlayWidth', r._overlayWidth)
          }
        },
        dependencies: [tc, Ub, vn],
        styles: [
          '.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color, var(--mat-sys-on-surface));font-family:var(--mat-select-trigger-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-select-trigger-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-select-trigger-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-select-trigger-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mat-select-trigger-text-tracking, var(--mat-sys-body-large-tracking))}div.mat-mdc-select-panel{box-shadow:var(--mat-select-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-disabled .mat-mdc-select-placeholder{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow,.mat-form-field-invalid:not(.mat-form-field-disabled) .mat-mdc-form-field-infix::after{color:var(--mat-select-invalid-arrow-color, var(--mat-sys-error))}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}@media(forced-colors: active){.mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .mat-mdc-select-arrow svg{fill:GrayText}}div.mat-mdc-select-panel{width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color, var(--mat-sys-surface-container))}@media(forced-colors: active){div.mat-mdc-select-panel{outline:solid 1px}}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}div.mat-mdc-select-panel .mat-mdc-option{--mdc-list-list-item-container-color: var(--mat-select-panel-background-color)}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color, var(--mat-sys-on-surface-variant))}.mat-form-field-no-animations .mat-mdc-select-placeholder,._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100%/0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:var(--mat-select-arrow-transform, translateY(-8px))}'
        ],
        encapsulation: 2,
        data: {animation: [Jj.transformPanel]},
        changeDetection: 0
      })
    } return n
  })();
var dh = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj =
        V({providers: [nB], imports: [ha, Rb, pe, Zi, tr, Rb, pe]})
  } return n
})();
var oB = ['tooltip'], dS = 20;
var uS = new w('mat-tooltip-scroll-strategy', {
  providedIn: 'root',
  factory: () => {
    let n = u(St);
    return () => n.scrollStrategies.reposition({scrollThrottle: dS})
  }
});
function sB(n) {
  return () => n.scrollStrategies.reposition({scrollThrottle: dS})
}
var aB = {provide: uS, deps: [St], useFactory: sB};
function lB() {
  return {
    showDelay: 0, hideDelay: 0, touchendHideDelay: 1500
  }
}
var cB =
    new w('mat-tooltip-default-options', {providedIn: 'root', factory: lB});
var lS = 'tooltip-panel', cS = _i({passive: !0}), dB = 8, uB = 8, mB = 24,
    hB = 200,
    mS = (() => {
      class n {
        _elementRef = u(L);
        _ngZone = u(U);
        _platform = u(Ie);
        _ariaDescriber = u(bk);
        _focusMonitor = u(xn);
        _dir = u(dt);
        _injector = u(he);
        _defaultOptions = u(cB, {optional: !0});
        _overlayRef;
        _tooltipInstance;
        _portal;
        _position = 'below';
        _positionAtOrigin = !1;
        _disabled = !1;
        _tooltipClass;
        _viewInitialized = !1;
        _pointerExitEventsInitialized = !1;
        _tooltipComponent = fB;
        _viewportMargin = 8;
        _currentPosition;
        _cssClassPrefix = 'mat-mdc';
        _ariaDescriptionPending;
        _dirSubscribed = !1;
        get position() {
          return this._position
        }
        set position(e) {
          e !== this._position &&
              (this._position = e,
               this._overlayRef &&
                   (this._updatePosition(this._overlayRef),
                    this._tooltipInstance?.show(0),
                    this._overlayRef.updatePosition()))
        }
        get positionAtOrigin() {
          return this._positionAtOrigin
        }
        set positionAtOrigin(e) {
          this._positionAtOrigin = Je(e), this._detach(),
          this._overlayRef = null
        }
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          let i = Je(e);
          this._disabled !== i &&
              (this._disabled = i,
               i ? this.hide(0) : this._setupPointerEnterEventsIfNeeded(),
               this._syncAriaDescription(this.message))
        }
        get showDelay() {
          return this._showDelay
        }
        set showDelay(e) {
          this._showDelay = mn(e)
        }
        _showDelay;
        get hideDelay() {
          return this._hideDelay
        }
        set hideDelay(e) {
          this._hideDelay = mn(e),
          this._tooltipInstance &&
              (this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay)
        }
        _hideDelay;
        touchGestures = 'auto';
        get message() {
          return this._message
        }
        set message(e) {
          let i = this._message;
          this._message = e != null ? String(e).trim() : '',
          !this._message && this._isTooltipVisible() ?
              this.hide(0) :
              (this._setupPointerEnterEventsIfNeeded(),
               this._updateTooltipMessage()),
          this._syncAriaDescription(i)
        }
        _message = '';
        get tooltipClass() {
          return this._tooltipClass
        }
        set tooltipClass(e) {
          this._tooltipClass = e,
          this._tooltipInstance && this._setTooltipClass(this._tooltipClass)
        }
        _passiveListeners = [];
        _touchstartTimeout = null;
        _destroyed = new I;
        _isDestroyed = !1;
        constructor() {
          let e = this._defaultOptions;
          e &&
              (this._showDelay = e.showDelay, this._hideDelay = e.hideDelay,
               e.position && (this.position = e.position),
               e.positionAtOrigin &&
                   (this.positionAtOrigin = e.positionAtOrigin),
               e.touchGestures && (this.touchGestures = e.touchGestures),
               e.tooltipClass && (this.tooltipClass = e.tooltipClass)),
              this._viewportMargin = dB
        }
        ngAfterViewInit() {
          this._viewInitialized = !0, this._setupPointerEnterEventsIfNeeded(),
          this._focusMonitor.monitor(this._elementRef)
              .pipe(re(this._destroyed))
              .subscribe(
                  e => {
                      e ? e === 'keyboard' &&
                              this._ngZone.run(() => this.show()) :
                          this._ngZone.run(() => this.hide(0))})
        }
        ngOnDestroy() {
          let e = this._elementRef.nativeElement;
          this._touchstartTimeout && clearTimeout(this._touchstartTimeout),
              this._overlayRef &&
              (this._overlayRef.dispose(), this._tooltipInstance = null),
              this._passiveListeners.forEach(
                  ([i, r]) => {e.removeEventListener(i, r, cS)}),
              this._passiveListeners.length = 0, this._destroyed.next(),
              this._destroyed.complete(), this._isDestroyed = !0,
              this._ariaDescriber.removeDescription(e, this.message, 'tooltip'),
              this._focusMonitor.stopMonitoring(e)
        }
        show(e = this.showDelay, i) {
          if (this.disabled || !this.message || this._isTooltipVisible()) {
            this._tooltipInstance?._cancelPendingAnimations();
            return
          }
          let r = this._createOverlay(i);
          this._detach(),
              this._portal = this._portal ||
              new jr(this._tooltipComponent, this._injector.get(Ge));
          let o = this._tooltipInstance = r.attach(this._portal).instance;
          o._triggerElement = this._elementRef.nativeElement,
          o._mouseLeaveHideDelay = this._hideDelay,
          o.afterHidden()
              .pipe(re(this._destroyed))
              .subscribe(() => this._detach()),
          this._setTooltipClass(this._tooltipClass),
          this._updateTooltipMessage(), o.show(e)
        }
        hide(e = this.hideDelay) {
          let i = this._tooltipInstance;
          i &&
              (i.isVisible() ? i.hide(e) :
                               (i._cancelPendingAnimations(), this._detach()))
        }
        toggle(e) {
          this._isTooltipVisible() ? this.hide() : this.show(void 0, e)
        }
        _isTooltipVisible() {
          return !!this._tooltipInstance && this._tooltipInstance.isVisible()
        }
        _createOverlay(e) {
          if (this._overlayRef) {
            let s = this._overlayRef.getConfig().positionStrategy;
            if ((!this.positionAtOrigin || !e) && s._origin instanceof L)
              return this._overlayRef;
            this._detach()
          }
          let i = this._injector.get(Vr).getAncestorScrollContainers(
                  this._elementRef),
              r = this._injector.get(St),
              o = r.position()
                      .flexibleConnectedTo(
                          this.positionAtOrigin ? e || this._elementRef :
                                                  this._elementRef)
                      .withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)
                      .withFlexibleDimensions(!1)
                      .withViewportMargin(this._viewportMargin)
                      .withScrollableContainers(i);
          return o.positionChanges.pipe(re(this._destroyed)).subscribe(s => {
            this._updateCurrentPositionClass(s.connectionPair),
            this._tooltipInstance &&
                s.scrollableViewProperties.isOverlayClipped &&
                this._tooltipInstance.isVisible() &&
                this._ngZone.run(() => this.hide(0))
          }),
                 this._overlayRef = r.create({
                   direction: this._dir,
                   positionStrategy: o,
                   panelClass: `${this._cssClassPrefix}-${lS}`,
                   scrollStrategy: this._injector.get(uS)()
                 }),
                 this._updatePosition(this._overlayRef),
                 this._overlayRef.detachments()
                     .pipe(re(this._destroyed))
                     .subscribe(() => this._detach()),
                 this._overlayRef.outsidePointerEvents()
                     .pipe(re(this._destroyed))
                     .subscribe(
                         () => this._tooltipInstance?._handleBodyInteraction()),
                 this._overlayRef.keydownEvents()
                     .pipe(re(this._destroyed))
                     .subscribe(
                         s => {
                             this._isTooltipVisible() && s.keyCode === 27 &&
                             !wt(s) &&
                             (s.preventDefault(), s.stopPropagation(),
                              this._ngZone.run(() => this.hide(0)))}),
                 this._defaultOptions?.disableTooltipInteractivity &&
                     this._overlayRef.addPanelClass(`${
                         this._cssClassPrefix}-tooltip-panel-non-interactive`),
                 this._dirSubscribed ||
                     (this._dirSubscribed = !0,
                      this._dir.change.pipe(re(this._destroyed))
                          .subscribe(
                              () => {
                                  this._overlayRef &&
                                  this._updatePosition(this._overlayRef)})),
                 this._overlayRef
        }
        _detach() {
          this._overlayRef && this._overlayRef.hasAttached() &&
              this._overlayRef.detach(),
              this._tooltipInstance = null
        }
        _updatePosition(e) {
          let i = e.getConfig().positionStrategy, r = this._getOrigin(),
              o = this._getOverlayPosition();
          i.withPositions([
            this._addOffset(y(y({}, r.main), o.main)),
            this._addOffset(y(y({}, r.fallback), o.fallback))
          ])
        }
        _addOffset(e) {
          let i = uB, r = !this._dir || this._dir.value == 'ltr';
          return e.originY === 'top'        ? e.offsetY = -i :
                     e.originY === 'bottom' ? e.offsetY = i :
                     e.originX === 'start'  ? e.offsetX = r ? -i : i :
                                              e.originX === 'end' &&
                         (e.offsetX = r ? i : -i),
                                       e
        }
        _getOrigin() {
          let e = !this._dir || this._dir.value == 'ltr', i = this.position, r;
          i == 'above' || i == 'below' ?
              r = {
                originX: 'center',
                originY: i == 'above' ? 'top' : 'bottom'
              } :
              i == 'before' || i == 'left' && e || i == 'right' && !e ?
              r = {originX: 'start', originY: 'center'} :
              (i == 'after' || i == 'right' && e || i == 'left' && !e) &&
                  (r = {originX: 'end', originY: 'center'});
          let {x: o, y: s} = this._invertPosition(r.originX, r.originY);
          return {
            main: r, fallback: {originX: o, originY: s}
          }
        }
        _getOverlayPosition() {
          let e = !this._dir || this._dir.value == 'ltr', i = this.position, r;
          i == 'above' ?
              r = {overlayX: 'center', overlayY: 'bottom'} :
              i == 'below' ?
              r = {overlayX: 'center', overlayY: 'top'} :
              i == 'before' || i == 'left' && e || i == 'right' && !e ?
              r = {overlayX: 'end', overlayY: 'center'} :
              (i == 'after' || i == 'right' && e || i == 'left' && !e) &&
                  (r = {overlayX: 'start', overlayY: 'center'});
          let {x: o, y: s} = this._invertPosition(r.overlayX, r.overlayY);
          return {
            main: r, fallback: {overlayX: o, overlayY: s}
          }
        }
        _updateTooltipMessage() {
          this._tooltipInstance &&
              (this._tooltipInstance.message = this.message,
               this._tooltipInstance._markForCheck(),
               ht(
                   () => {
                       this._tooltipInstance &&
                       this._overlayRef.updatePosition()},
                   {injector: this._injector}))
        }
        _setTooltipClass(e) {
          this._tooltipInstance &&
              (this._tooltipInstance.tooltipClass = e,
               this._tooltipInstance._markForCheck())
        }
        _invertPosition(e, i) {
          return this.position === 'above' || this.position === 'below' ?
                     i === 'top' ? i = 'bottom' :
                                   i === 'bottom' && (i = 'top') :
                     e === 'end' ? e = 'start' :
                                   e === 'start' && (e = 'end'),
          {
            x: e, y: i
          }
        }
        _updateCurrentPositionClass(e) {
          let {overlayY: i, originX: r, originY: o} = e, s;
          if (i === 'center' ?
                  this._dir&& this._dir.value === 'rtl' ?
                  s = r === 'end' ? 'left' : 'right' :
                  s = r === 'start' ? 'left' : 'right' :
                  s = i === 'bottom' && o === 'top' ? 'above' : 'below',
              s !== this._currentPosition) {
            let a = this._overlayRef;
            if (a) {
              let l = `${this._cssClassPrefix}-${lS}-`;
              a.removePanelClass(l + this._currentPosition),
                  a.addPanelClass(l + s)
            }
            this._currentPosition = s
          }
        }
        _setupPointerEnterEventsIfNeeded() {
          this._disabled || !this.message || !this._viewInitialized ||
              this._passiveListeners.length ||
              (this._platformSupportsMouseEvents() ?
                   this._passiveListeners.push([
                     'mouseenter',
                     e => {
                       this._setupPointerExitEventsIfNeeded();
                       let i;
                       e.x !== void 0 && e.y !== void 0 && (i = e),
                           this.show(void 0, i)
                     }
                   ]) :
                   this.touchGestures !== 'off' &&
                       (this._disableNativeGesturesIfNecessary(),
                        this._passiveListeners.push([
                          'touchstart',
                          e => {
                            let i = e.targetTouches?.[0],
                                r = i ? {x: i.clientX, y: i.clientY} : void 0;
                            this._setupPointerExitEventsIfNeeded(),
                                this._touchstartTimeout &&
                                clearTimeout(this._touchstartTimeout);
                            let o = 500;
                            this._touchstartTimeout = setTimeout(
                                () => {
                                  this._touchstartTimeout = null,
                                  this.show(void 0, r)
                                },
                                this._defaultOptions?.touchLongPressShowDelay ??
                                    o)
                          }
                        ])),
               this._addListeners(this._passiveListeners))
        }
        _setupPointerExitEventsIfNeeded() {
          if (this._pointerExitEventsInitialized) return;
          this._pointerExitEventsInitialized = !0;
          let e = [];
          if (this._platformSupportsMouseEvents())
            e.push(
                [
                  'mouseleave',
                  i => {
                    let r = i.relatedTarget;
                    (!r || !this._overlayRef?.overlayElement.contains(r)) &&
                        this.hide()
                  }
                ],
                ['wheel', i => this._wheelListener(i)]);
          else if (this.touchGestures !== 'off') {
            this._disableNativeGesturesIfNecessary();
            let i = () => {
              this._touchstartTimeout && clearTimeout(this._touchstartTimeout),
                  this.hide(this._defaultOptions?.touchendHideDelay)
            };
            e.push(['touchend', i], ['touchcancel', i])
          }
          this._addListeners(e), this._passiveListeners.push(...e)
        }
        _addListeners(e) {
          e.forEach(
              ([i, r]) => {
                  this._elementRef.nativeElement.addEventListener(i, r, cS)})
        }
        _platformSupportsMouseEvents() {
          return !this._platform.IOS && !this._platform.ANDROID
        }
        _wheelListener(e) {
          if (this._isTooltipVisible()) {
            let i = this._injector.get(ce).elementFromPoint(
                    e.clientX, e.clientY),
                r = this._elementRef.nativeElement;
            i !== r && !r.contains(i) && this.hide()
          }
        }
        _disableNativeGesturesIfNecessary() {
          let e = this.touchGestures;
          if (e !== 'off') {
            let i = this._elementRef.nativeElement, r = i.style;
            (e === 'on' ||
             i.nodeName !== 'INPUT' && i.nodeName !== 'TEXTAREA') &&
                (r.userSelect = r.msUserSelect = r.webkitUserSelect =
                     r.MozUserSelect = 'none'),
                (e === 'on' || !i.draggable) && (r.webkitUserDrag = 'none'),
                r.touchAction = 'none',
                r.webkitTapHighlightColor = 'transparent'
          }
        }
        _syncAriaDescription(e) {
          this._ariaDescriptionPending ||
              (this._ariaDescriptionPending = !0,
               this._ariaDescriber.removeDescription(
                   this._elementRef.nativeElement, e, 'tooltip'),
               this._isDestroyed ||
                   ht({
                     write: () => {
                       this._ariaDescriptionPending = !1,
                       this.message && !this.disabled &&
                           this._ariaDescriber.describe(
                               this._elementRef.nativeElement, this.message,
                               'tooltip')
                     }
                   },
                      {injector: this._injector}))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matTooltip', '']],
          hostAttrs: [1, 'mat-mdc-tooltip-trigger'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 && Y('mat-mdc-tooltip-disabled', r.disabled)
          },
          inputs: {
            position: [0, 'matTooltipPosition', 'position'],
            positionAtOrigin:
                [0, 'matTooltipPositionAtOrigin', 'positionAtOrigin'],
            disabled: [0, 'matTooltipDisabled', 'disabled'],
            showDelay: [0, 'matTooltipShowDelay', 'showDelay'],
            hideDelay: [0, 'matTooltipHideDelay', 'hideDelay'],
            touchGestures: [0, 'matTooltipTouchGestures', 'touchGestures'],
            message: [0, 'matTooltip', 'message'],
            tooltipClass: [0, 'matTooltipClass', 'tooltipClass']
          },
          exportAs: ['matTooltip']
        })
      } return n
    })(),
    fB = (() => {
      class n {
        _changeDetectorRef = u(Ae);
        _elementRef = u(L);
        _isMultiline = !1;
        message;
        tooltipClass;
        _showTimeoutId;
        _hideTimeoutId;
        _triggerElement;
        _mouseLeaveHideDelay;
        _animationsDisabled;
        _tooltip;
        _closeOnInteraction = !1;
        _isVisible = !1;
        _onHide = new I;
        _showAnimation = 'mat-mdc-tooltip-show';
        _hideAnimation = 'mat-mdc-tooltip-hide';
        constructor() {
          let e = u(Ve, {optional: !0});
          this._animationsDisabled = e === 'NoopAnimations'
        }
        show(e) {
          this._hideTimeoutId != null && clearTimeout(this._hideTimeoutId),
              this._showTimeoutId = setTimeout(
                  () => {
                    this._toggleVisibility(!0),
                    this._showTimeoutId = void 0
                  },
                  e)
        }
        hide(e) {
          this._showTimeoutId != null && clearTimeout(this._showTimeoutId),
              this._hideTimeoutId = setTimeout(
                  () => {
                    this._toggleVisibility(!1),
                    this._hideTimeoutId = void 0
                  },
                  e)
        }
        afterHidden() {
          return this._onHide
        }
        isVisible() {
          return this._isVisible
        }
        ngOnDestroy() {
          this._cancelPendingAnimations(), this._onHide.complete(),
              this._triggerElement = null
        }
        _handleBodyInteraction() {
          this._closeOnInteraction && this.hide(0)
        }
        _markForCheck() {
          this._changeDetectorRef.markForCheck()
        }
        _handleMouseLeave({relatedTarget: e}) {
          (!e || !this._triggerElement.contains(e)) &&
              (this.isVisible() ? this.hide(this._mouseLeaveHideDelay) :
                                  this._finalizeAnimation(!1))
        }
        _onShow() {
          this._isMultiline = this._isTooltipMultiline(), this._markForCheck()
        }
        _isTooltipMultiline() {
          let e = this._elementRef.nativeElement.getBoundingClientRect();
          return e.height > mB && e.width >= hB
        }
        _handleAnimationEnd({animationName: e}) {
          (e === this._showAnimation || e === this._hideAnimation) &&
              this._finalizeAnimation(e === this._showAnimation)
        }
        _cancelPendingAnimations() {
          this._showTimeoutId != null && clearTimeout(this._showTimeoutId),
              this._hideTimeoutId != null && clearTimeout(this._hideTimeoutId),
              this._showTimeoutId = this._hideTimeoutId = void 0
        }
        _finalizeAnimation(e) {
          e ? this._closeOnInteraction = !0 :
              this.isVisible() || this._onHide.next()
        }
        _toggleVisibility(e) {
          let i = this._tooltip.nativeElement, r = this._showAnimation,
              o = this._hideAnimation;
          if (i.classList.remove(e ? o : r), i.classList.add(e ? r : o),
              this._isVisible !== e &&
                  (this._isVisible = e, this._changeDetectorRef.markForCheck()),
              e && !this._animationsDisabled &&
                  typeof getComputedStyle == 'function') {
            let s = getComputedStyle(i);
            (s.getPropertyValue('animation-duration') === '0s' ||
             s.getPropertyValue('animation-name') === 'none') &&
                (this._animationsDisabled = !0)
          }
          e && this._onShow(),
              this._animationsDisabled &&
              (i.classList.add('_mat-animation-noopable'),
               this._finalizeAnimation(e))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-tooltip-component']],
          viewQuery: function(i, r) {
            if (i & 1 && oe(oB, 7), i & 2) {
              let o;
              $(o = W()) && (r._tooltip = o.first)
            }
          },
          hostAttrs: ['aria-hidden', 'true'],
          hostBindings: function(i, r) {
            i&1 && M('mouseleave', function(s) {
              return r._handleMouseLeave(s)
            })
          },
          decls: 4,
          vars: 4,
          consts: [
            ['tooltip', ''],
            [1, 'mdc-tooltip', 'mat-mdc-tooltip', 3, 'animationend', 'ngClass'],
            [1, 'mat-mdc-tooltip-surface', 'mdc-tooltip__surface']
          ],
          template: function(i, r) {
            if (i & 1) {
              let o = ee();
              f(0, 'div', 1, 0), M('animationend', function(a) {
                return N(o), P(r._handleAnimationEnd(a))
              }), f(2, 'div', 2), E(3), g()()
            }
            i&2 &&
                (Y('mdc-tooltip--multiline', r._isMultiline),
                 x('ngClass', r.tooltipClass), b(3), Re(r.message))
          },
          dependencies: [vn],
          styles: [
            '.mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color, var(--mat-sys-inverse-surface));color:var(--mdc-plain-tooltip-supporting-text-color, var(--mat-sys-inverse-on-surface));border-radius:var(--mdc-plain-tooltip-container-shape, var(--mat-sys-corner-extra-small));font-family:var(--mdc-plain-tooltip-supporting-text-font, var(--mat-sys-body-small-font));font-size:var(--mdc-plain-tooltip-supporting-text-size, var(--mat-sys-body-small-size));font-weight:var(--mdc-plain-tooltip-supporting-text-weight, var(--mat-sys-body-small-weight));line-height:var(--mdc-plain-tooltip-supporting-text-line-height, var(--mat-sys-body-small-line-height));letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, var(--mat-sys-body-small-tracking))}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel{line-height:normal}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var hS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({providers: [aB], imports: [xb, ha, pe, pe, Zi]})
  } return n
})();
function pB(n, t) {
  if (n & 1 && (f(0, 'mat-option', 17), E(1), g()), n & 2) {
    let e = t.$implicit;
    x('value', e), b(), at(' ', e, ' ')
  }
}
function gB(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'mat-form-field', 14)(1, 'mat-select', 16, 0),
        M('selectionChange',
          function(r) {
            N(e);
            let o = D(2);
            return P(o._changePageSize(r.value))
          }),
        Do(3, pB, 2, 2, 'mat-option', 17, Co), g(), f(5, 'div', 18),
        M('click', function() {
          N(e);
          let r = yt(2);
          return P(r.open())
        }), g()()
  }
  if (n & 2) {
    let e = D(2);
    x('appearance', e._formFieldAppearance)('color', e.color), b(),
        x('value', e.pageSize)('disabled', e.disabled)(
            'aria-labelledby', e._pageSizeLabelId)(
            'panelClass', e.selectConfig.panelClass || '')(
            'disableOptionCentering', e.selectConfig.disableOptionCentering),
        b(2), Eo(e._displayedPageSizeOptions)
  }
}
function _B(n, t) {
  if (n & 1 && (f(0, 'div', 15), E(1), g()), n & 2) {
    let e = D(2);
    b(), Re(e.pageSize)
  }
}
function bB(n, t) {
  if (n & 1 &&
          (f(0, 'div', 3)(1, 'div', 13), E(2), g(),
           R(3, gB, 6, 7, 'mat-form-field', 14)(4, _B, 2, 1, 'div', 15), g()),
      n & 2) {
    let e = D();
    b(), J('id', e._pageSizeLabelId), b(),
        at(' ', e._intl.itemsPerPageLabel, ' '), b(),
        de(e._displayedPageSizeOptions.length > 1 ? 3 : -1), b(),
        de(e._displayedPageSizeOptions.length <= 1 ? 4 : -1)
  }
}
function vB(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 19), M('click', function() {
      N(e);
      let r = D();
      return P(r._buttonClicked(0, r._previousButtonsDisabled()))
    }), Bt(), f(1, 'svg', 8), B(2, 'path', 20), g()()
  }
  if (n & 2) {
    let e = D();
    x('matTooltip', e._intl.firstPageLabel)(
        'matTooltipDisabled', e._previousButtonsDisabled())(
        'disabled', e._previousButtonsDisabled()),
        J('aria-label', e._intl.firstPageLabel)
  }
}
function yB(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 21), M('click', function() {
      N(e);
      let r = D();
      return P(
          r._buttonClicked(r.getNumberOfPages() - 1, r._nextButtonsDisabled()))
    }), Bt(), f(1, 'svg', 8), B(2, 'path', 22), g()()
  }
  if (n & 2) {
    let e = D();
    x('matTooltip', e._intl.lastPageLabel)(
        'matTooltipDisabled', e._nextButtonsDisabled())(
        'disabled', e._nextButtonsDisabled()),
        J('aria-label', e._intl.lastPageLabel)
  }
}
var jo = (() => {
  class n {
    changes = new I;
    itemsPerPageLabel = 'Items per page:';
    nextPageLabel = 'Next page';
    previousPageLabel = 'Previous page';
    firstPageLabel = 'First page';
    lastPageLabel = 'Last page';
    getRangeLabel = (e, i, r) => {
      if (r == 0 || i == 0) return `0 of ${r}`;
      r = Math.max(r, 0);
      let o = e * i, s = o < r ? Math.min(o + i, r) : o + i;
      return `${o + 1} \u2013 ${s} of ${r}`
    };
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function wB(n) {
  return n || new jo
}
var xB = {provide: jo, deps: [[new bo, new Ja, jo]], useFactory: wB}, CB = 50;
var DB = new w('MAT_PAGINATOR_DEFAULT_OPTIONS'), qb = (() => {
                                                   class n {
                                                     _intl = u(jo);
                                                     _changeDetectorRef = u(Ae);
                                                     _formFieldAppearance;
                                                     _pageSizeLabelId = u(et).getId(
                                                         'mat-paginator-page-size-label-');
                                                     _intlChanges;
                                                     _isInitialized = !1;
                                                     _initializedStream =
                                                         new In(1);
                                                     color;
                                                     get pageIndex() {
                                                       return this._pageIndex
                                                     }
                                                     set pageIndex(e) {
                                                       this._pageIndex =
                                                           Math.max(e || 0, 0),
                                                       this._changeDetectorRef
                                                           .markForCheck()
                                                     }
                                                     _pageIndex = 0;
                                                     get length() {
                                                       return this._length
                                                     }
                                                     set length(e) {
                                                       this._length = e || 0,
                                                       this._changeDetectorRef
                                                           .markForCheck()
                                                     }
                                                     _length = 0;
                                                     get pageSize() {
                                                       return this._pageSize
                                                     }
                                                     set pageSize(e) {
                                                       this._pageSize =
                                                           Math.max(e || 0, 0),
                                                       this._updateDisplayedPageSizeOptions()
                                                     }
                                                     _pageSize;
                                                     get pageSizeOptions() {
                                                       return this
                                                           ._pageSizeOptions
                                                     }
                                                     set pageSizeOptions(e) {
                                                       this._pageSizeOptions =
                                                           (e || []).map(
                                                               i => st(i, 0)),
                                                       this._updateDisplayedPageSizeOptions()
                                                     }
                                                     _pageSizeOptions = [];
                                                     hidePageSize = !1;
                                                     showFirstLastButtons = !1;
                                                     selectConfig = {};
                                                     disabled = !1;
                                                     page = new H;
                                                     _displayedPageSizeOptions;
                                                     initialized =
                                                         this._initializedStream;
                                                     constructor() {
                                                       let e = this._intl,
                                                           i = u(
                                                               DB,
                                                               {optional: !0});
                                                       if (this._intlChanges =
                                                               e.changes.subscribe(
                                                                   () =>
                                                                       this._changeDetectorRef
                                                                           .markForCheck()),
                                                           i) {
                                                         let {
                                                           pageSize: r,
                                                           pageSizeOptions: o,
                                                           hidePageSize: s,
                                                           showFirstLastButtons:
                                                               a
                                                         } = i;
                                                         r != null &&
                                                             (this._pageSize =
                                                                  r),
                                                             o != null &&
                                                             (this._pageSizeOptions =
                                                                  o),
                                                             s != null &&
                                                             (this.hidePageSize =
                                                                  s),
                                                             a != null &&
                                                             (this.showFirstLastButtons =
                                                                  a)
                                                       }
                                                       this._formFieldAppearance =
                                                           i?.formFieldAppearance ||
                                                           'outline'
                                                     }
                                                     ngOnInit() {
                                                       this._isInitialized = !0,
                                                       this._updateDisplayedPageSizeOptions(),
                                                       this._initializedStream
                                                           .next()
                                                     }
                                                     ngOnDestroy() {
                                                       this._initializedStream
                                                           .complete(),
                                                           this._intlChanges
                                                               .unsubscribe()
                                                     }
                                                     nextPage() {
                                                       this.hasNextPage() &&
                                                           this._navigate(
                                                               this.pageIndex +
                                                               1)
                                                     }
                                                     previousPage() {
                                                       this.hasPreviousPage() &&
                                                           this._navigate(
                                                               this.pageIndex -
                                                               1)
                                                     }
                                                     firstPage() {
                                                       this.hasPreviousPage() &&
                                                           this._navigate(0)
                                                     }
                                                     lastPage() {
                                                       this.hasNextPage() &&
                                                           this._navigate(
                                                               this.getNumberOfPages() -
                                                               1)
                                                     }
                                                     hasPreviousPage() {
                                                       return this.pageIndex >=
                                                           1 &&
                                                           this.pageSize != 0
                                                     }
                                                     hasNextPage() {
                                                       let e =
                                                           this.getNumberOfPages() -
                                                           1;
                                                       return this.pageIndex <
                                                           e &&
                                                           this.pageSize != 0
                                                     }
                                                     getNumberOfPages() {
                                                       return this.pageSize ?
                                                           Math.ceil(
                                                               this.length /
                                                               this.pageSize) :
                                                           0
                                                     }
                                                     _changePageSize(e) {
                                                       let i = this.pageIndex *
                                                           this.pageSize,
                                                           r = this.pageIndex;
                                                       this.pageIndex =
                                                           Math.floor(i / e) ||
                                                           0,
                                                       this.pageSize = e,
                                                       this._emitPageEvent(r)
                                                     }
                                                     _nextButtonsDisabled() {
                                                       return this.disabled ||
                                                           !this.hasNextPage()
                                                     }
                                                     _previousButtonsDisabled() {
                                                       return this.disabled ||
                                                           !this.hasPreviousPage()
                                                     }
                                                     _updateDisplayedPageSizeOptions() {
                                                       this._isInitialized &&
                                                           (this.pageSize ||
                                                                (this._pageSize =
                                                                     this.pageSizeOptions
                                                                             .length !=
                                                                         0 ?
                                                                     this.pageSizeOptions
                                                                         [0] :
                                                                     CB),
                                                            this._displayedPageSizeOptions =
                                                                this.pageSizeOptions
                                                                    .slice(),
                                                            this._displayedPageSizeOptions
                                                                        .indexOf(
                                                                            this.pageSize) ===
                                                                    -1 &&
                                                                this._displayedPageSizeOptions
                                                                    .push(
                                                                        this.pageSize),
                                                            this._displayedPageSizeOptions
                                                                .sort(
                                                                    (e, i) =>
                                                                        e - i),
                                                            this._changeDetectorRef
                                                                .markForCheck())
                                                     }
                                                     _emitPageEvent(e) {
                                                       this.page.emit({
                                                         previousPageIndex: e,
                                                         pageIndex:
                                                             this.pageIndex,
                                                         pageSize:
                                                             this.pageSize,
                                                         length: this.length
                                                       })
                                                     }
                                                     _navigate(e) {
                                                       let i = this.pageIndex;
                                                       e !== i &&
                                                           (this.pageIndex = e,
                                                            this._emitPageEvent(
                                                                i))
                                                     }
                                                     _buttonClicked(e, i) {
                                                       i || this._navigate(e)
                                                     }
                                                     static \u0275fac =
                                                         function(i) {
                                                       return new (i || n)
                                                     };
                                                     static \u0275cmp =
                                                         O(
                                                             {
                                                               type: n,
                                                               selectors: [[
                                                                 'mat-paginator'
                                                               ]],
                                                               hostAttrs: [
                                                                 'role',
                                                                 'group', 1,
                                                                 'mat-mdc-paginator'
                                                               ],
                                                               inputs: {
                                                                 color: 'color',
                                                                 pageIndex: [
                                                                   2,
                                                                   'pageIndex',
                                                                   'pageIndex',
                                                                   st
                                                                 ],
                                                                 length: [
                                                                   2, 'length',
                                                                   'length', st
                                                                 ],
                                                                 pageSize: [
                                                                   2,
                                                                   'pageSize',
                                                                   'pageSize',
                                                                   st
                                                                 ],
                                                                 pageSizeOptions:
                                                                     'pageSizeOptions',
                                                                 hidePageSize: [
                                                                   2,
                                                                   'hidePageSize',
                                                                   'hidePageSize',
                                                                   q
                                                                 ],
                                                                 showFirstLastButtons: [
                                                                   2,
                                                                   'showFirstLastButtons',
                                                                   'showFirstLastButtons',
                                                                   q
                                                                 ],
                                                                 selectConfig:
                                                                     'selectConfig',
                                                                 disabled: [
                                                                   2,
                                                                   'disabled',
                                                                   'disabled', q
                                                                 ]
                                                               },
                                                               outputs: {
                                                                 page: 'page'
                                                               },
                                                               exportAs: [
                                                                 'matPaginator'
                                                               ],
                                                               decls: 14,
                                                               vars: 12,
                                                               consts: [
                                                                 [
                                                                   'selectRef',
                                                                   ''
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-outer-container'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-container'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-page-size'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-range-actions'
                                                                 ],
                                                                 [
                                                                   'aria-live',
                                                                   'polite', 1,
                                                                   'mat-mdc-paginator-range-label'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-first',
                                                                   3,
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-previous',
                                                                   3, 'click',
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   'viewBox',
                                                                   '0 0 24 24',
                                                                   'focusable',
                                                                   'false',
                                                                   'aria-hidden',
                                                                   'true', 1,
                                                                   'mat-mdc-paginator-icon'
                                                                 ],
                                                                 [
                                                                   'd',
                                                                   'M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-next',
                                                                   3, 'click',
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   'd',
                                                                   'M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-last',
                                                                   3,
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-page-size-label'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-page-size-select',
                                                                   3,
                                                                   'appearance',
                                                                   'color'
                                                                 ],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-page-size-value'
                                                                 ],
                                                                 [
                                                                   'hideSingleSelectionIndicator',
                                                                   '', 3,
                                                                   'selectionChange',
                                                                   'value',
                                                                   'disabled',
                                                                   'aria-labelledby',
                                                                   'panelClass',
                                                                   'disableOptionCentering'
                                                                 ],
                                                                 [3, 'value'],
                                                                 [
                                                                   1,
                                                                   'mat-mdc-paginator-touch-target',
                                                                   3, 'click'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-first',
                                                                   3, 'click',
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   'd',
                                                                   'M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z'
                                                                 ],
                                                                 [
                                                                   'mat-icon-button',
                                                                   '', 'type',
                                                                   'button',
                                                                   'matTooltipPosition',
                                                                   'above',
                                                                   'disabledInteractive',
                                                                   '', 1,
                                                                   'mat-mdc-paginator-navigation-last',
                                                                   3, 'click',
                                                                   'matTooltip',
                                                                   'matTooltipDisabled',
                                                                   'disabled'
                                                                 ],
                                                                 [
                                                                   'd',
                                                                   'M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z'
                                                                 ]
                                                               ],
                                                               template: function(
                                                                   i, r) {
                                                                 i&1 &&
                                                                     (f(0,
                                                                        'div',
                                                                        1)(
                                                                          1,
                                                                          'div',
                                                                          2),
                                                                      R(2, bB,
                                                                        5, 4,
                                                                        'div',
                                                                        3),
                                                                      f(3,
                                                                        'div',
                                                                        4)(
                                                                          4,
                                                                          'div',
                                                                          5),
                                                                      E(5), g(),
                                                                      R(6, vB,
                                                                        3, 4,
                                                                        'button',
                                                                        6),
                                                                      f(7,
                                                                        'button',
                                                                        7),
                                                                      M('click',
                                                                        function() {
                                                                          return r
                                                                              ._buttonClicked(
                                                                                  r.pageIndex -
                                                                                      1,
                                                                                  r._previousButtonsDisabled())
                                                                        }),
                                                                      Bt(),
                                                                      f(8,
                                                                        'svg',
                                                                        8),
                                                                      B(9,
                                                                        'path',
                                                                        9),
                                                                      g()(),
                                                                      wo(),
                                                                      f(10,
                                                                        'button',
                                                                        10),
                                                                      M('click',
                                                                        function() {
                                                                          return r
                                                                              ._buttonClicked(
                                                                                  r.pageIndex +
                                                                                      1,
                                                                                  r._nextButtonsDisabled())
                                                                        }),
                                                                      Bt(),
                                                                      f(11,
                                                                        'svg',
                                                                        8),
                                                                      B(12,
                                                                        'path',
                                                                        11),
                                                                      g()(),
                                                                      R(13, yB,
                                                                        3, 4,
                                                                        'button',
                                                                        12),
                                                                      g()()()),
                                                                     i&2 &&
                                                                     (b(2),
                                                                      de(r.hidePageSize ?
                                                                             -1 :
                                                                             2),
                                                                      b(3),
                                                                      at(' ',
                                                                         r._intl.getRangeLabel(
                                                                             r.pageIndex,
                                                                             r.pageSize,
                                                                             r.length),
                                                                         ' '),
                                                                      b(),
                                                                      de(r.showFirstLastButtons ?
                                                                             6 :
                                                                             -1),
                                                                      b(),
                                                                      x('matTooltip',
                                                                        r._intl
                                                                            .previousPageLabel)(
                                                                          'matTooltipDisabled',
                                                                          r._previousButtonsDisabled())(
                                                                          'disabled',
                                                                          r._previousButtonsDisabled()),
                                                                      J('aria-label',
                                                                        r._intl
                                                                            .previousPageLabel),
                                                                      b(3),
                                                                      x('matTooltip',
                                                                        r._intl
                                                                            .nextPageLabel)(
                                                                          'matTooltipDisabled',
                                                                          r._nextButtonsDisabled())(
                                                                          'disabled',
                                                                          r._nextButtonsDisabled()),
                                                                      J('aria-label',
                                                                        r._intl
                                                                            .nextPageLabel),
                                                                      b(3),
                                                                      de(r.showFirstLastButtons ?
                                                                             13 :
                                                                             -1))
                                                               },
                                                               dependencies: [
                                                                 xi, ch, sa, Km,
                                                                 mS
                                                               ],
                                                               styles: [
                                                                 '.mat-mdc-paginator{display:block;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-paginator-container-text-color, var(--mat-sys-on-surface));background-color:var(--mat-paginator-container-background-color, var(--mat-sys-surface));font-family:var(--mat-paginator-container-text-font, var(--mat-sys-body-small-font));line-height:var(--mat-paginator-container-text-line-height, var(--mat-sys-body-small-line-height));font-size:var(--mat-paginator-container-text-size, var(--mat-sys-body-small-size));font-weight:var(--mat-paginator-container-text-weight, var(--mat-sys-body-small-weight));letter-spacing:var(--mat-paginator-container-text-tracking, var(--mat-sys-body-small-tracking));--mat-form-field-container-height:var(--mat-paginator-form-field-container-height, 40px);--mat-form-field-container-vertical-padding:var(--mat-paginator-form-field-container-vertical-padding, 8px)}.mat-mdc-paginator .mat-mdc-select-value{font-size:var(--mat-paginator-select-trigger-text-size, var(--mat-sys-body-small-size))}.mat-mdc-paginator .mat-mdc-form-field-subscript-wrapper{display:none}.mat-mdc-paginator .mat-mdc-select{line-height:1.5}.mat-mdc-paginator-outer-container{display:flex}.mat-mdc-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap;width:100%;min-height:var(--mat-paginator-container-size, 56px)}.mat-mdc-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-mdc-paginator-page-size{margin-right:0;margin-left:8px}.mat-mdc-paginator-page-size-label{margin:0 4px}.mat-mdc-paginator-page-size-select{margin:0 4px;width:84px}.mat-mdc-paginator-range-label{margin:0 32px 0 24px}.mat-mdc-paginator-range-actions{display:flex;align-items:center}.mat-mdc-paginator-icon{display:inline-block;width:28px;fill:var(--mat-paginator-enabled-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button[aria-disabled] .mat-mdc-paginator-icon{fill:var(--mat-paginator-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}[dir=rtl] .mat-mdc-paginator-icon{transform:rotate(180deg)}@media(forced-colors: active){.mat-mdc-icon-button[disabled] .mat-mdc-paginator-icon,.mat-mdc-paginator-icon{fill:currentColor;fill:CanvasText}.mat-mdc-paginator-range-actions .mat-mdc-icon-button{outline:solid 1px}}.mat-mdc-paginator-touch-target{display:var(--mat-paginator-touch-target-display, block);position:absolute;top:50%;left:50%;width:84px;height:48px;background-color:rgba(0,0,0,0);transform:translate(-50%, -50%);cursor:pointer}'
                                                               ],
                                                               encapsulation: 2,
                                                               changeDetection:
                                                                   0
                                                             })
                                                   } return n
                                                 })(),
    fS = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({providers: [xB], imports: [Lr, dh, hS, qb]})
      } return n
    })();
var rn = class {
  static getBaseUrlWithoutPath() {
    let t = window.location.href;
    return new URL(t).origin + '/dev-ui'
  }
  static getApiServerBaseUrl() {
    return window.runtimeConfig?.backendUrl
  }
};
var Hr = class n {
  constructor(t, e) {
    this.http = t;
    this.zone = e
  }
  apiServerDomain = rn.getApiServerBaseUrl();
  _currentApp = new Le('');
  currentApp = this._currentApp.asObservable();
  getApp() {
    return this.currentApp
  }
  setApp(t) {
    this._currentApp.next(t)
  }
  run(t) {
    let i = {headers: {'Content-type': 'application/json'}},
        r = this.apiServerDomain + '/run';
    return this.http.post(r, t, i)
  }
  run_sse(t) {
    let e = this.apiServerDomain + '/run_sse';
    return new ie(
        i => {fetch(e, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Accept: 'text/event-stream'
                },
                body: JSON.stringify(t)
              })
                  .then(r => {
                    let o = r.body?.getReader(), s = new TextDecoder('utf-8'),
                        a = null, l = () => {
                          o?.read()
                              .then(({done: c, value: d}) => {
                                if (c) return i.complete();
                                s.decode(d, {stream: !0})
                                    .split(/\r?\n/)
                                    .filter(h => h.startsWith('data: '))
                                    .forEach(h => {
                                      let _ = h.replace(/^data:\s*/, '');
                                      this.zone.run(() => i.next(_))
                                    }),
                                    l()
                              })
                              .catch(c => {this.zone.run(() => i.error(c))})
                        };
                    l()
                  })
                  .catch(r => {this.zone.run(() => i.error(r))})})
  }
  listApps() {
    if (this.apiServerDomain != null) {
      let t = this.apiServerDomain + '/list-apps?relative_path=./';
      return this.http.get(t)
    }
    return new ie
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(zt), A(U))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var Ur = class n {
  constructor(t) {
    this.http = t
  }
  apiServerDomain = rn.getApiServerBaseUrl();
  getEventTrace(t) {
    let e = this.apiServerDomain + `/debug/trace/${t}`;
    return this.http.get(e)
  }
  getEvent(t, e, i, r) {
    let o = this.apiServerDomain +
        `/apps/${e}/users/${t}/sessions/${i}/events/${r}/graph`;
    return this.http.get(o, {responseType: 'blob'})
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(zt))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var gS = (() => {
  class n {
    get vertical() {
      return this._vertical
    }
    set vertical(e) {
      this._vertical = Je(e)
    }
    _vertical = !1;
    get inset() {
      return this._inset
    }
    set inset(e) {
      this._inset = Je(e)
    }
    _inset = !1;
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['mat-divider']],
      hostAttrs: ['role', 'separator', 1, 'mat-divider'],
      hostVars: 7,
      hostBindings: function(i, r) {
        i&2 &&
            (J('aria-orientation', r.vertical ? 'vertical' : 'horizontal'),
             Y('mat-divider-vertical', r.vertical)(
                 'mat-divider-horizontal', !r.vertical)(
                 'mat-divider-inset', r.inset))
      },
      inputs: {vertical: 'vertical', inset: 'inset'},
      decls: 0,
      vars: 0,
      template: function(i, r) {},
      styles: [
        '.mat-divider{display:block;margin:0;border-top-style:solid;border-top-color:var(--mat-divider-color, var(--mat-sys-outline));border-top-width:var(--mat-divider-width, 1px)}.mat-divider.mat-divider-vertical{border-top:0;border-right-style:solid;border-right-color:var(--mat-divider-color, var(--mat-sys-outline));border-right-width:var(--mat-divider-width, 1px)}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}'
      ],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})(),
    _S = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe, pe]})
      } return n
    })();
var IB = ['*'],
    MB =
        '.mdc-list{margin:0;padding:8px 0;list-style-type:none}.mdc-list:focus{outline:none}.mdc-list-item{display:flex;position:relative;justify-content:flex-start;overflow:hidden;padding:0;align-items:stretch;cursor:pointer;padding-left:16px;padding-right:16px;background-color:var(--mdc-list-list-item-container-color, transparent);border-radius:var(--mdc-list-list-item-container-shape, var(--mat-sys-corner-none))}.mdc-list-item.mdc-list-item--selected{background-color:var(--mdc-list-list-item-selected-container-color)}.mdc-list-item:focus{outline:0}.mdc-list-item.mdc-list-item--disabled{cursor:auto}.mdc-list-item.mdc-list-item--with-one-line{height:var(--mdc-list-list-item-one-line-container-height, 48px)}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__start{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-two-lines{height:var(--mdc-list-list-item-two-line-container-height, 64px)}.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines{height:var(--mdc-list-list-item-three-line-container-height, 88px)}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--selected::before,.mdc-list-item.mdc-list-item--selected:focus::before,.mdc-list-item:not(.mdc-list-item--selected):focus::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;content:"";pointer-events:none}a.mdc-list-item{color:inherit;text-decoration:none}.mdc-list-item__start{fill:currentColor;flex-shrink:0;pointer-events:none}.mdc-list-item--with-leading-icon .mdc-list-item__start{color:var(--mdc-list-list-item-leading-icon-color, var(--mat-sys-on-surface-variant));width:var(--mdc-list-list-item-leading-icon-size, 24px);height:var(--mdc-list-list-item-leading-icon-size, 24px);margin-left:16px;margin-right:32px}[dir=rtl] .mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:32px;margin-right:16px}.mdc-list-item--with-leading-icon:hover .mdc-list-item__start{color:var(--mdc-list-list-item-hover-leading-icon-color)}.mdc-list-item--with-leading-avatar .mdc-list-item__start{width:var(--mdc-list-list-item-leading-avatar-size, 40px);height:var(--mdc-list-list-item-leading-avatar-size, 40px);margin-left:16px;margin-right:16px;border-radius:50%}.mdc-list-item--with-leading-avatar .mdc-list-item__start,[dir=rtl] .mdc-list-item--with-leading-avatar .mdc-list-item__start{margin-left:16px;margin-right:16px;border-radius:50%}.mdc-list-item__end{flex-shrink:0;pointer-events:none}.mdc-list-item--with-trailing-meta .mdc-list-item__end{font-family:var(--mdc-list-list-item-trailing-supporting-text-font, var(--mat-sys-label-small-font));line-height:var(--mdc-list-list-item-trailing-supporting-text-line-height, var(--mat-sys-label-small-line-height));font-size:var(--mdc-list-list-item-trailing-supporting-text-size, var(--mat-sys-label-small-size));font-weight:var(--mdc-list-list-item-trailing-supporting-text-weight, var(--mat-sys-label-small-weight));letter-spacing:var(--mdc-list-list-item-trailing-supporting-text-tracking, var(--mat-sys-label-small-tracking))}.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-trailing-icon-color, var(--mat-sys-on-surface-variant));width:var(--mdc-list-list-item-trailing-icon-size, 24px);height:var(--mdc-list-list-item-trailing-icon-size, 24px)}.mdc-list-item--with-trailing-icon:hover .mdc-list-item__end{color:var(--mdc-list-list-item-hover-trailing-icon-color)}.mdc-list-item.mdc-list-item--with-trailing-meta .mdc-list-item__end{color:var(--mdc-list-list-item-trailing-supporting-text-color, var(--mat-sys-on-surface-variant))}.mdc-list-item--selected.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-selected-trailing-icon-color, var(--mat-sys-primary))}.mdc-list-item__content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;align-self:center;flex:1;pointer-events:none}.mdc-list-item--with-two-lines .mdc-list-item__content,.mdc-list-item--with-three-lines .mdc-list-item__content{align-self:stretch}.mdc-list-item__primary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;color:var(--mdc-list-list-item-label-text-color, var(--mat-sys-on-surface));font-family:var(--mdc-list-list-item-label-text-font, var(--mat-sys-body-large-font));line-height:var(--mdc-list-list-item-label-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mdc-list-list-item-label-text-size, var(--mat-sys-body-large-size));font-weight:var(--mdc-list-list-item-label-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mdc-list-list-item-label-text-tracking, var(--mat-sys-body-large-tracking))}.mdc-list-item:hover .mdc-list-item__primary-text{color:var(--mdc-list-list-item-hover-label-text-color, var(--mat-sys-on-surface))}.mdc-list-item:focus .mdc-list-item__primary-text{color:var(--mdc-list-list-item-focus-label-text-color, var(--mat-sys-on-surface))}.mdc-list-item--with-two-lines .mdc-list-item__primary-text,.mdc-list-item--with-three-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before,.mdc-list-item--with-three-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after,.mdc-list-item--with-three-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item__secondary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;color:var(--mdc-list-list-item-supporting-text-color, var(--mat-sys-on-surface-variant));font-family:var(--mdc-list-list-item-supporting-text-font, var(--mat-sys-body-medium-font));line-height:var(--mdc-list-list-item-supporting-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mdc-list-list-item-supporting-text-size, var(--mat-sys-body-medium-size));font-weight:var(--mdc-list-list-item-supporting-text-weight, var(--mat-sys-body-medium-weight));letter-spacing:var(--mdc-list-list-item-supporting-text-tracking, var(--mat-sys-body-medium-tracking))}.mdc-list-item__secondary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}.mdc-list-item--with-three-lines .mdc-list-item__secondary-text{white-space:normal;line-height:20px}.mdc-list-item--with-overline .mdc-list-item__secondary-text{white-space:nowrap;line-height:auto}.mdc-list-item--with-leading-radio.mdc-list-item,.mdc-list-item--with-leading-checkbox.mdc-list-item,.mdc-list-item--with-leading-icon.mdc-list-item,.mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:0;padding-right:16px}[dir=rtl] .mdc-list-item--with-leading-radio.mdc-list-item,[dir=rtl] .mdc-list-item--with-leading-checkbox.mdc-list-item,[dir=rtl] .mdc-list-item--with-leading-icon.mdc-list-item,[dir=rtl] .mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:16px;padding-right:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text,.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text,.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before,.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before,.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after,.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after,.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end,.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end,.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before,.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before,.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item--with-trailing-icon.mdc-list-item,[dir=rtl] .mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:0;padding-right:0}.mdc-list-item--with-trailing-icon .mdc-list-item__end{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:16px;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:0;padding-right:16px}.mdc-list-item--with-trailing-meta .mdc-list-item__end{-webkit-user-select:none;user-select:none;margin-left:28px;margin-right:16px}[dir=rtl] .mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:16px;margin-right:28px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end,.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{display:block;line-height:normal;align-self:flex-start;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end::before,.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-list-item--with-leading-radio .mdc-list-item__start,.mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:8px;margin-right:24px}[dir=rtl] .mdc-list-item--with-leading-radio .mdc-list-item__start,[dir=rtl] .mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__start,.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-radio.mdc-list-item,.mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:16px;padding-right:0}[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item,[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:0;padding-right:16px}.mdc-list-item--with-trailing-radio.mdc-list-item--with-leading-icon,.mdc-list-item--with-trailing-radio.mdc-list-item--with-leading-avatar,.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-leading-icon,.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-leading-avatar{padding-left:0}[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item--with-leading-icon,[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item--with-leading-avatar,[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item--with-leading-icon,[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item--with-leading-avatar{padding-right:0}.mdc-list-item--with-trailing-radio .mdc-list-item__end,.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:24px;margin-right:8px}[dir=rtl] .mdc-list-item--with-trailing-radio .mdc-list-item__end,[dir=rtl] .mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-radio.mdc-list-item--with-three-lines .mdc-list-item__end,.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-group__subheader{margin:.75rem 16px}.mdc-list-item--disabled .mdc-list-item__start,.mdc-list-item--disabled .mdc-list-item__content,.mdc-list-item--disabled .mdc-list-item__end{opacity:1}.mdc-list-item--disabled .mdc-list-item__primary-text,.mdc-list-item--disabled .mdc-list-item__secondary-text{opacity:var(--mdc-list-list-item-disabled-label-text-opacity, 0.3)}.mdc-list-item--disabled.mdc-list-item--with-leading-icon .mdc-list-item__start{color:var(--mdc-list-list-item-disabled-leading-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-list-list-item-disabled-leading-icon-opacity, 0.38)}.mdc-list-item--disabled.mdc-list-item--with-trailing-icon .mdc-list-item__end{color:var(--mdc-list-list-item-disabled-trailing-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-list-list-item-disabled-trailing-icon-opacity, 0.38)}.mat-mdc-list-item.mat-mdc-list-item-both-leading-and-trailing,[dir=rtl] .mat-mdc-list-item.mat-mdc-list-item-both-leading-and-trailing{padding-left:0;padding-right:0}.mdc-list-item.mdc-list-item--disabled .mdc-list-item__primary-text{color:var(--mdc-list-list-item-disabled-label-text-color, var(--mat-sys-on-surface))}.mdc-list-item:hover::before{background-color:var(--mdc-list-list-item-hover-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mdc-list-list-item-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mdc-list-item.mdc-list-item--disabled::before{background-color:var(--mdc-list-list-item-disabled-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mdc-list-list-item-disabled-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-list-item:focus::before{background-color:var(--mdc-list-list-item-focus-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mdc-list-list-item-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-list-item--disabled .mdc-radio,.mdc-list-item--disabled .mdc-checkbox{opacity:var(--mdc-list-list-item-disabled-label-text-opacity, 0.3)}.mdc-list-item--with-leading-avatar .mat-mdc-list-item-avatar{border-radius:var(--mdc-list-list-item-leading-avatar-shape, var(--mat-sys-corner-full));background-color:var(--mdc-list-list-item-leading-avatar-color, var(--mat-sys-primary-container))}.mat-mdc-list-item-icon{font-size:var(--mdc-list-list-item-leading-icon-size, 24px)}@media(forced-colors: active){a.mdc-list-item--activated::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}a.mdc-list-item--activated [dir=rtl]::after{right:auto;left:16px}}.mat-mdc-list-base{display:block}.mat-mdc-list-base .mdc-list-item__start,.mat-mdc-list-base .mdc-list-item__end,.mat-mdc-list-base .mdc-list-item__content{pointer-events:auto}.mat-mdc-list-item,.mat-mdc-list-option{width:100%;box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-list-item:not(.mat-mdc-list-item-interactive),.mat-mdc-list-option:not(.mat-mdc-list-item-interactive){cursor:default}.mat-mdc-list-item .mat-divider-inset,.mat-mdc-list-option .mat-divider-inset{position:absolute;left:0;right:0;bottom:0}.mat-mdc-list-item .mat-mdc-list-item-avatar~.mat-divider-inset,.mat-mdc-list-option .mat-mdc-list-item-avatar~.mat-divider-inset{margin-left:72px}[dir=rtl] .mat-mdc-list-item .mat-mdc-list-item-avatar~.mat-divider-inset,[dir=rtl] .mat-mdc-list-option .mat-mdc-list-item-avatar~.mat-divider-inset{margin-right:72px}.mat-mdc-list-item-interactive::before{top:0;left:0;right:0;bottom:0;position:absolute;content:"";opacity:0;pointer-events:none;border-radius:inherit}.mat-mdc-list-item>.mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-list-item:focus>.mat-focus-indicator::before{content:""}.mat-mdc-list-item.mdc-list-item--with-three-lines .mat-mdc-list-item-line.mdc-list-item__secondary-text{white-space:nowrap;line-height:normal}.mat-mdc-list-item.mdc-list-item--with-three-lines .mat-mdc-list-item-unscoped-content.mdc-list-item__secondary-text{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:rgba(0,0,0,0);text-align:start}mat-action-list button::-moz-focus-inner{border:0}.mdc-list-item--with-leading-icon .mdc-list-item__start{margin-inline-start:var(--mat-list-list-item-leading-icon-start-space, 16px);margin-inline-end:var(--mat-list-list-item-leading-icon-end-space, 16px)}.mat-mdc-nav-list .mat-mdc-list-item{border-radius:var(--mat-list-active-indicator-shape, var(--mat-sys-corner-full));--mat-focus-indicator-border-radius:var(--mat-list-active-indicator-shape, var(--mat-sys-corner-full))}.mat-mdc-nav-list .mat-mdc-list-item.mdc-list-item--activated{background-color:var(--mat-list-active-indicator-color, var(--mat-sys-secondary-container))}',
    TB = ['unscopedContent'], RB = ['text'],
    AB =
        [
          [['', 'matListItemAvatar', ''], ['', 'matListItemIcon', '']],
          [['', 'matListItemTitle', '']], [['', 'matListItemLine', '']], '*',
          [['', 'matListItemMeta', '']], [['mat-divider']]
        ],
    OB = [
      '[matListItemAvatar],[matListItemIcon]', '[matListItemTitle]',
      '[matListItemLine]', '*', '[matListItemMeta]', 'mat-divider'
    ];
var NB = new w('ListOption'),
    PB = (() => {
      class n {
        _elementRef = u(L);
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matListItemTitle', '']],
          hostAttrs:
              [1, 'mat-mdc-list-item-title', 'mdc-list-item__primary-text']
        })
      } return n
    })(),
    FB = (() => {
      class n {
        _elementRef = u(L);
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matListItemLine', '']],
          hostAttrs:
              [1, 'mat-mdc-list-item-line', 'mdc-list-item__secondary-text']
        })
      } return n
    })(),
    LB = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matListItemMeta', '']],
          hostAttrs: [1, 'mat-mdc-list-item-meta', 'mdc-list-item__end']
        })
      } return n
    })(),
    bS = (() => {
      class n {
        _listOption = u(NB, {optional: !0});
        constructor() {}
        _isAlignedAtStart() {
          return !this._listOption ||
              this._listOption?._getTogglePosition() === 'after'
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          hostVars: 4,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mdc-list-item__start', r._isAlignedAtStart())(
                    'mdc-list-item__end', !r._isAlignedAtStart())
          }
        })
      } return n
    })(),
    VB = (() => {
      class n extends bS {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matListItemAvatar', '']],
          hostAttrs: [1, 'mat-mdc-list-item-avatar'],
          features: [te]
        })
      } return n
    })(),
    jB = (() => {
      class n extends bS {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matListItemIcon', '']],
          hostAttrs: [1, 'mat-mdc-list-item-icon'],
          features: [te]
        })
      } return n
    })(),
    BB = new w('MAT_LIST_CONFIG'),
    Gb = (() => {
      class n {
        _isNonInteractive = !0;
        get disableRipple() {
          return this._disableRipple
        }
        set disableRipple(e) {
          this._disableRipple = Je(e)
        }
        _disableRipple = !1;
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          this._disabled = Je(e)
        }
        _disabled = !1;
        _defaultOptions = u(BB, {optional: !0});
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          hostVars: 1,
          hostBindings: function(i, r) {
            i&2 && J('aria-disabled', r.disabled)
          },
          inputs: {disableRipple: 'disableRipple', disabled: 'disabled'}
        })
      } return n
    })(),
    zB = (() => {
      class n {
        _elementRef = u(L);
        _ngZone = u(U);
        _listBase = u(Gb, {optional: !0});
        _platform = u(Ie);
        _hostElement;
        _isButtonElement;
        _noopAnimations;
        _avatars;
        _icons;
        set lines(e) {
          this._explicitLines = mn(e, null), this._updateItemLines(!1)
        }
        _explicitLines = null;
        get disableRipple() {
          return this.disabled || this._disableRipple || this._noopAnimations ||
              !!this._listBase?.disableRipple
        }
        set disableRipple(e) {
          this._disableRipple = Je(e)
        }
        _disableRipple = !1;
        get disabled() {
          return this._disabled || !!this._listBase?.disabled
        }
        set disabled(e) {
          this._disabled = Je(e)
        }
        _disabled = !1;
        _subscriptions = new ge;
        _rippleRenderer = null;
        _hasUnscopedTextContent = !1;
        rippleConfig;
        get rippleDisabled() {
          return this.disableRipple || !!this.rippleConfig.disabled
        }
        constructor() {
          u(lt).load($n);
          let e = u(Yl, {optional: !0}), i = u(Ve, {optional: !0});
          this.rippleConfig = e || {},
          this._hostElement = this._elementRef.nativeElement,
          this._isButtonElement =
              this._hostElement.nodeName.toLowerCase() === 'button',
          this._noopAnimations = i === 'NoopAnimations',
          this._listBase && !this._listBase._isNonInteractive &&
              this._initInteractiveListItem(),
          this._isButtonElement && !this._hostElement.hasAttribute('type') &&
              this._hostElement.setAttribute('type', 'button')
        }
        ngAfterViewInit() {
          this._monitorProjectedLinesAndTitle(), this._updateItemLines(!0)
        }
        ngOnDestroy() {
          this._subscriptions.unsubscribe(),
              this._rippleRenderer !== null &&
              this._rippleRenderer._removeTriggerEvents()
        }
        _hasIconOrAvatar() {
          return !!(this._avatars.length || this._icons.length)
        }
        _initInteractiveListItem() {
          this._hostElement.classList.add('mat-mdc-list-item-interactive'),
              this._rippleRenderer = new ia(
                  this, this._ngZone, this._hostElement, this._platform, u(he)),
              this._rippleRenderer.setupTriggerEvents(this._hostElement)
        }
        _monitorProjectedLinesAndTitle() {
          this._ngZone.runOutsideAngular(
              () => {this._subscriptions.add(
                  Ke(this._lines.changes, this._titles.changes)
                      .subscribe(() => this._updateItemLines(!1)))})
        }
        _updateItemLines(e) {
          if (!this._lines || !this._titles || !this._unscopedContent) return;
          e && this._checkDomForUnscopedTextContent();
          let i = this._explicitLines ?? this._inferLinesFromContent(),
              r = this._unscopedContent.nativeElement;
          if (this._hostElement.classList.toggle(
                  'mat-mdc-list-item-single-line', i <= 1),
              this._hostElement.classList.toggle(
                  'mdc-list-item--with-one-line', i <= 1),
              this._hostElement.classList.toggle(
                  'mdc-list-item--with-two-lines', i === 2),
              this._hostElement.classList.toggle(
                  'mdc-list-item--with-three-lines', i === 3),
              this._hasUnscopedTextContent) {
            let o = this._titles.length === 0 && i === 1;
            r.classList.toggle('mdc-list-item__primary-text', o),
                r.classList.toggle('mdc-list-item__secondary-text', !o)
          } else
            r.classList.remove('mdc-list-item__primary-text'),
                r.classList.remove('mdc-list-item__secondary-text')
        }
        _inferLinesFromContent() {
          let e = this._titles.length + this._lines.length;
          return this._hasUnscopedTextContent && (e += 1), e
        }
        _checkDomForUnscopedTextContent() {
          this._hasUnscopedTextContent =
              Array.from(this._unscopedContent.nativeElement.childNodes)
                  .filter(e => e.nodeType !== e.COMMENT_NODE)
                  .some(e => !!(e.textContent && e.textContent.trim()))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          contentQueries: function(i, r, o) {
            if (i & 1 && (Oe(o, VB, 4), Oe(o, jB, 4)), i & 2) {
              let s;
              $(s = W()) && (r._avatars = s), $(s = W()) && (r._icons = s)
            }
          },
          hostVars: 4,
          hostBindings: function(i, r) {
            i&2 &&
                (J('aria-disabled', r.disabled)(
                     'disabled', r._isButtonElement && r.disabled || null),
                 Y('mdc-list-item--disabled', r.disabled))
          },
          inputs: {
            lines: 'lines',
            disableRipple: 'disableRipple',
            disabled: 'disabled'
          }
        })
      } return n
    })();
var vS = (() => {
  class n extends Gb {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275cmp = O({
      type: n,
      selectors: [['mat-list']],
      hostAttrs: [1, 'mat-mdc-list', 'mat-mdc-list-base', 'mdc-list'],
      exportAs: ['matList'],
      features: [ye([{provide: Gb, useExisting: n}]), te],
      ngContentSelectors: IB,
      decls: 1,
      vars: 0,
      template: function(i, r) {
        i&1 && (Se(), Z(0))
      },
      styles: [MB],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})(),
    yS = (() => {
      class n extends zB {
        _lines;
        _titles;
        _meta;
        _unscopedContent;
        _itemText;
        get activated() {
          return this._activated
        }
        set activated(e) {
          this._activated = Je(e)
        }
        _activated = !1;
        _getAriaCurrent() {
          return this._hostElement.nodeName === 'A' && this._activated ?
              'page' :
              null
        }
        _hasBothLeadingAndTrailing() {
          return this._meta.length !== 0 &&
              (this._avatars.length !== 0 || this._icons.length !== 0)
        }
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275cmp = O({
          type: n,
          selectors: [
            ['mat-list-item'], ['a', 'mat-list-item', ''],
            ['button', 'mat-list-item', '']
          ],
          contentQueries: function(i, r, o) {
            if (i & 1 && (Oe(o, FB, 5), Oe(o, PB, 5), Oe(o, LB, 5)), i & 2) {
              let s;
              $(s = W()) && (r._lines = s), $(s = W()) && (r._titles = s),
                  $(s = W()) && (r._meta = s)
            }
          },
          viewQuery: function(i, r) {
            if (i & 1 && (oe(TB, 5), oe(RB, 5)), i & 2) {
              let o;
              $(o = W()) && (r._unscopedContent = o.first),
                  $(o = W()) && (r._itemText = o.first)
            }
          },
          hostAttrs: [1, 'mat-mdc-list-item', 'mdc-list-item'],
          hostVars: 13,
          hostBindings: function(i, r) {
            i&2 &&
                (J('aria-current', r._getAriaCurrent()),
                 Y('mdc-list-item--activated', r.activated)(
                     'mdc-list-item--with-leading-avatar',
                     r._avatars.length !== 0)(
                     'mdc-list-item--with-leading-icon', r._icons.length !== 0)(
                     'mdc-list-item--with-trailing-meta', r._meta.length !== 0)(
                     'mat-mdc-list-item-both-leading-and-trailing',
                     r._hasBothLeadingAndTrailing())(
                     '_mat-animation-noopable', r._noopAnimations))
          },
          inputs: {activated: 'activated'},
          exportAs: ['matListItem'],
          features: [te],
          ngContentSelectors: OB,
          decls: 10,
          vars: 0,
          consts: [
            ['unscopedContent', ''], [1, 'mdc-list-item__content'],
            [1, 'mat-mdc-list-item-unscoped-content', 3, 'cdkObserveContent'],
            [1, 'mat-focus-indicator']
          ],
          template: function(i, r) {
            if (i & 1) {
              let o = ee();
              Se(AB), Z(0), f(1, 'span', 1), Z(2, 1), Z(3, 2),
                  f(4, 'span', 2, 0), M('cdkObserveContent', function() {
                    return N(o), P(r._updateItemLines(!0))
                  }), Z(6, 3), g()(), Z(7, 4), Z(8, 5), B(9, 'div', 3)
            }
          },
          dependencies: [Om],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var wS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [ea, pe, Zl, Ib, _S]})
  } return n
})();
function UB(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'mat-list-item', 6), M('click', function() {
      let r = N(e).$implicit, o = D(2);
      return P(o.selectEvent(r.key))
    }), f(1, 'span', 7), E(2), g(), f(3, 'span'), E(4), g()()
  }
  if (n & 2) {
    let e = t.$implicit, i = t.index;
    b(2), Re(i), b(2), Re(e.key)
  }
}
function $B(n, t) {
  if (n & 1 &&
          (f(0, 'div', 3)(1, 'p'), E(2, 'Conversations with agent'), g(),
           f(3, 'mat-list', 4), R(4, UB, 5, 2, 'mat-list-item', 5),
           Cr(5, 'keyvalue'), g()()),
      n & 2) {
    let e = D();
    b(4), x('ngForOf', qC(5, 1, e.eventsMap, e.mapOrderPreservingSort))
  }
}
function WB(n, t) {
  n&1 && (f(0, 'div')(1, 'p'), E(2, 'No conversations'), g()())
}
var Bo = class n {
  constructor(t) {
    this.eventService = t
  }
  eventsMap = new Map;
  selectedEvent = new H;
  llmRequest = void 0;
  llmResponse = void 0;
  llmRequestKey = 'gcp.vertex.agent.llm_request';
  llmResponseKey = 'gcp.vertex.agent.llm_response';
  isDetailsPanelOpen = !1;
  showJson = Array(this.eventsMap.size).fill(!1);
  toggleJson(t) {
    this.showJson[t] = !this.showJson[t]
  }
  selectEvent(t) {
    this.selectedEvent.emit(t)
  }
  mapOrderPreservingSort = (t, e) => 0;
  static \u0275fac = function(e) {
    return new (e || n)(z(Ur))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-event-tab']],
    inputs: {eventsMap: 'eventsMap'},
    outputs: {selectedEvent: 'selectedEvent'},
    standalone: !1,
    decls: 3,
    vars: 2,
    consts:
        [
          [1, 'events-wrapper'], ['class', 'events-container', 4, 'ngIf'],
          [4, 'ngIf'], [1, 'events-container'], [1, 'event-list'],
          [3, 'click', 4, 'ngFor', 'ngForOf'], [3, 'click'], [1, 'event-index']
        ],
    template:
        function(e, i) {
          e&1 &&
              (f(0, 'div', 0), R(1, $B, 6, 4, 'div', 1)(2, WB, 3, 0, 'div', 2),
               g()),
              e&2 &&
              (b(), x('ngIf', i.eventsMap.size > 0), b(),
               x('ngIf', i.eventsMap.size == 0))
        },
    dependencies: [yn, fi, vS, yS, fD],
    styles:
        [
          '.events-wrapper[_ngcontent-%COMP%]{padding-left:25px;padding-right:25px;color:#9aa0a6;font-size:14px;font-weight:700}.event-index[_ngcontent-%COMP%]{color:#80868b;font-family:Roboto;font-size:14px;font-style:normal;font-weight:400;margin-right:10px}.spacer[_ngcontent-%COMP%]{flex:1 1 auto}.events-container[_ngcontent-%COMP%]{margin-top:20px}.event-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;margin-top:20px}.function-event-button[_ngcontent-%COMP%]{margin-top:11px}.event-list[_ngcontent-%COMP%]{--mat-list-active-indicator-color: orange}.event-list[_ngcontent-%COMP%]{--mdc-list-list-item-container-color: #2b2b2f}.event-list[_ngcontent-%COMP%]{--mdc-list-list-item-label-text-size: 14px}.event-list[_ngcontent-%COMP%]{--mdc-list-list-item-label-text-weight: 400}.event-list[_ngcontent-%COMP%]{--mdc-list-list-item-one-line-container-height: 52px}[_nghost-%COMP%]     .mdc-list-item{border:1px solid #5f6368;cursor:pointer}[_nghost-%COMP%]     .mdc-list-item:hover{background-color:#1c1b1c}'
        ]
  })
};
function GB(n, t) {}
var $r = class {
  viewContainerRef;
  injector;
  id;
  role = 'dialog';
  panelClass = '';
  hasBackdrop = !0;
  backdropClass = '';
  disableClose = !1;
  width = '';
  height = '';
  minWidth;
  minHeight;
  maxWidth;
  maxHeight;
  positionStrategy;
  data = null;
  direction;
  ariaDescribedBy = null;
  ariaLabelledBy = null;
  ariaLabel = null;
  ariaModal = !1;
  autoFocus = 'first-tabbable';
  restoreFocus = !0;
  scrollStrategy;
  closeOnNavigation = !0;
  closeOnDestroy = !0;
  closeOnOverlayDetachments = !0;
  componentFactoryResolver;
  providers;
  container;
  templateContext
};
var Yb = (() => {
  class n extends da {
    _elementRef = u(L);
    _focusTrapFactory = u($m);
    _config;
    _interactivityChecker = u(Ql);
    _ngZone = u(U);
    _overlayRef = u(ma);
    _focusMonitor = u(xn);
    _renderer = u(rt);
    _platform = u(Ie);
    _document = u(ce, {optional: !0});
    _portalOutlet;
    _focusTrap = null;
    _elementFocusedBeforeDialogWasOpened = null;
    _closeInteractionType = null;
    _ariaLabelledByQueue = [];
    _changeDetectorRef = u(Ae);
    _injector = u(he);
    _isDestroyed = !1;
    constructor() {
      super(), this._config = u($r, {optional: !0}) || new $r,
               this._config.ariaLabelledBy &&
          this._ariaLabelledByQueue.push(this._config.ariaLabelledBy)
    }
    _addAriaLabelledBy(e) {
      this._ariaLabelledByQueue.push(e), this._changeDetectorRef.markForCheck()
    }
    _removeAriaLabelledBy(e) {
      let i = this._ariaLabelledByQueue.indexOf(e);
      i > -1 &&
          (this._ariaLabelledByQueue.splice(i, 1),
           this._changeDetectorRef.markForCheck())
    }
    _contentAttached() {
      this._initializeFocusTrap(), this._handleBackdropClicks(),
          this._captureInitialFocus()
    }
    _captureInitialFocus() {
      this._trapFocus()
    }
    ngOnDestroy() {
      this._isDestroyed = !0, this._restoreFocus()
    }
    attachComponentPortal(e) {
      this._portalOutlet.hasAttached();
      let i = this._portalOutlet.attachComponentPortal(e);
      return this._contentAttached(), i
    }
    attachTemplatePortal(e) {
      this._portalOutlet.hasAttached();
      let i = this._portalOutlet.attachTemplatePortal(e);
      return this._contentAttached(), i
    }
    attachDomPortal = e => {
      this._portalOutlet.hasAttached();
      let i = this._portalOutlet.attachDomPortal(e);
      return this._contentAttached(), i
    };
    _recaptureFocus() {
      this._containsFocus() || this._trapFocus()
    }
    _forceFocus(e, i) {
      this._interactivityChecker.isFocusable(e) ||
          (e.tabIndex = -1, this._ngZone.runOutsideAngular(() => {
            let r = () => {o(), s(), e.removeAttribute('tabindex')},
            o = this._renderer.listen(e, 'blur', r),
            s = this._renderer.listen(e, 'mousedown', r)
          })),
          e.focus(i)
    }
    _focusByCssSelector(e, i) {
      let r = this._elementRef.nativeElement.querySelector(e);
      r && this._forceFocus(r, i)
    }
    _trapFocus() {
      this._isDestroyed || ht(() => {
        let e = this._elementRef.nativeElement;
        switch (this._config.autoFocus) {
          case !1:
          case 'dialog':
            this._containsFocus() || e.focus();
            break;
          case !0:
          case 'first-tabbable':
            this._focusTrap?.focusInitialElement() ||
                this._focusDialogContainer();
            break;
          case 'first-heading':
            this._focusByCssSelector(
                'h1, h2, h3, h4, h5, h6, [role="heading"]');
            break;
          default:
            this._focusByCssSelector(this._config.autoFocus);
            break
        }
      }, {injector: this._injector})
    }
    _restoreFocus() {
      let e = this._config.restoreFocus, i = null;
      if (typeof e == 'string' ?
              i = this._document.querySelector(e) :
              typeof e == 'boolean' ?
              i = e ? this._elementFocusedBeforeDialogWasOpened : null :
              e && (i = e),
          this._config.restoreFocus && i && typeof i.focus == 'function') {
        let r = Xs(), o = this._elementRef.nativeElement;
        (!r || r === this._document.body || r === o || o.contains(r)) &&
            (this._focusMonitor ?
                 (this._focusMonitor.focusVia(i, this._closeInteractionType),
                  this._closeInteractionType = null) :
                 i.focus())
      }
      this._focusTrap && this._focusTrap.destroy()
    }
    _focusDialogContainer() {
      this._elementRef.nativeElement.focus &&
          this._elementRef.nativeElement.focus()
    }
    _containsFocus() {
      let e = this._elementRef.nativeElement, i = Xs();
      return e === i || e.contains(i)
    }
    _initializeFocusTrap() {
      this._platform.isBrowser &&
          (this._focusTrap =
               this._focusTrapFactory.create(this._elementRef.nativeElement),
           this._document && (this._elementFocusedBeforeDialogWasOpened = Xs()))
    }
    _handleBackdropClicks() {
      this._overlayRef.backdropClick().subscribe(
          () => {this._config.disableClose && this._recaptureFocus()})
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['cdk-dialog-container']],
      viewQuery: function(i, r) {
        if (i & 1 && oe(Xi, 7), i & 2) {
          let o;
          $(o = W()) && (r._portalOutlet = o.first)
        }
      },
      hostAttrs: ['tabindex', '-1', 1, 'cdk-dialog-container'],
      hostVars: 6,
      hostBindings: function(i, r) {
        i&2 &&
            J('id', r._config.id || null)('role', r._config.role)(
                'aria-modal', r._config.ariaModal)(
                'aria-labelledby',
                r._config.ariaLabel ? null : r._ariaLabelledByQueue[0])(
                'aria-label', r._config.ariaLabel)(
                'aria-describedby', r._config.ariaDescribedBy || null)
      },
      features: [te],
      decls: 1,
      vars: 0,
      consts: [['cdkPortalOutlet', '']],
      template: function(i, r) {
        i&1 && R(0, GB, 0, 0, 'ng-template', 0)
      },
      dependencies: [Xi],
      styles: [
        '.cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}'
      ],
      encapsulation: 2
    })
  } return n
})(),
    oc = class {
  overlayRef;
  config;
  componentInstance;
  componentRef;
  containerInstance;
  disableClose;
  closed = new I;
  backdropClick;
  keydownEvents;
  outsidePointerEvents;
  id;
  _detachSubscription;
  constructor(t, e) {
    this.overlayRef = t, this.config = e, this.disableClose = e.disableClose,
    this.backdropClick = t.backdropClick(),
    this.keydownEvents = t.keydownEvents(),
    this.outsidePointerEvents = t.outsidePointerEvents(), this.id = e.id,
    this.keydownEvents.subscribe(
        i => {
            i.keyCode === 27 && !this.disableClose && !wt(i) &&
            (i.preventDefault(),
             this.close(void 0, {focusOrigin: 'keyboard'}))}),
    this.backdropClick.subscribe(
        () => {
            this.disableClose || this.close(void 0, {focusOrigin: 'mouse'})}),
    this._detachSubscription = t.detachments().subscribe(
        () => {e.closeOnOverlayDetachments !== !1 && this.close()})
  }
  close(t, e) {
    if (this.containerInstance) {
      let i = this.closed;
      this.containerInstance._closeInteractionType =
          e?.focusOrigin || 'program',
      this._detachSubscription.unsubscribe(), this.overlayRef.dispose(),
      i.next(t), i.complete(),
      this.componentInstance = this.containerInstance = null
    }
  }
  updatePosition() {
    return this.overlayRef.updatePosition(), this
  }
  updateSize(t = '', e = '') {
    return this.overlayRef.updateSize({width: t, height: e}), this
  }
  addPanelClass(t) {
    return this.overlayRef.addPanelClass(t), this
  }
  removePanelClass(t) {
    return this.overlayRef.removePanelClass(t), this
  }
}
, QB = new w('DialogScrollStrategy', {
    providedIn: 'root',
    factory: () => {
      let n = u(St);
      return () => n.scrollStrategies.block()
    }
  }),
  YB = new w('DialogData'), ZB = new w('DefaultDialogConfig');
var xS = (() => {
  class n {
    _overlay = u(St);
    _injector = u(he);
    _defaultOptions = u(ZB, {optional: !0});
    _parentDialog = u(n, {optional: !0, skipSelf: !0});
    _overlayContainer = u(ih);
    _idGenerator = u(et);
    _openDialogsAtThisLevel = [];
    _afterAllClosedAtThisLevel = new I;
    _afterOpenedAtThisLevel = new I;
    _ariaHiddenElements = new Map;
    _scrollStrategy = u(QB);
    get openDialogs() {
      return this._parentDialog ? this._parentDialog.openDialogs :
                                  this._openDialogsAtThisLevel
    }
    get afterOpened() {
      return this._parentDialog ? this._parentDialog.afterOpened :
                                  this._afterOpenedAtThisLevel
    }
    afterAllClosed =
        Xn(() => this.openDialogs.length ?
               this._getAfterAllClosed() :
               this._getAfterAllClosed().pipe(Xe(void 0)));
    constructor() {}
    open(e, i) {
      let r = this._defaultOptions || new $r;
      i = y(y({}, r), i), i.id = i.id || this._idGenerator.getId('cdk-dialog-'),
      i.id && this.getDialogById(i.id);
      let o = this._getOverlayConfig(i), s = this._overlay.create(o),
          a = new oc(s, i), l = this._attachContainer(s, a, i);
      return a.containerInstance = l, this._attachDialogContent(e, a, l, i),
             this.openDialogs.length ||
                 this._hideNonDialogContentFromAssistiveTechnology(),
             this.openDialogs.push(a),
             a.closed.subscribe(() => this._removeOpenDialog(a, !0)),
             this.afterOpened.next(a), a
    }
    closeAll() {
      Qb(this.openDialogs, e => e.close())
    }
    getDialogById(e) {
      return this.openDialogs.find(i => i.id === e)
    }
    ngOnDestroy() {
      Qb(this._openDialogsAtThisLevel,
         e => {
             e.config.closeOnDestroy === !1 && this._removeOpenDialog(e, !1)}),
          Qb(this._openDialogsAtThisLevel, e => e.close()),
          this._afterAllClosedAtThisLevel.complete(),
          this._afterOpenedAtThisLevel.complete(),
          this._openDialogsAtThisLevel = []
    }
    _getOverlayConfig(e) {
      let i = new ua({
        positionStrategy: e.positionStrategy ||
            this._overlay.position()
                .global()
                .centerHorizontally()
                .centerVertically(),
        scrollStrategy: e.scrollStrategy || this._scrollStrategy(),
        panelClass: e.panelClass,
        hasBackdrop: e.hasBackdrop,
        direction: e.direction,
        minWidth: e.minWidth,
        minHeight: e.minHeight,
        maxWidth: e.maxWidth,
        maxHeight: e.maxHeight,
        width: e.width,
        height: e.height,
        disposeOnNavigation: e.closeOnNavigation
      });
      return e.backdropClass && (i.backdropClass = e.backdropClass), i
    }
    _attachContainer(e, i, r) {
      let o = r.injector || r.viewContainerRef?.injector,
          s =
              [
                {provide: $r, useValue: r}, {provide: oc, useValue: i},
                {provide: ma, useValue: e}
              ],
          a;
      r.container ?
          typeof r.container == 'function' ?
          a = r.container :
          (a = r.container.type, s.push(...r.container.providers(r))) :
          a = Yb;
      let l = new jr(
          a, r.viewContainerRef,
          he.create({parent: o || this._injector, providers: s}));
      return e.attach(l).instance
    }
    _attachDialogContent(e, i, r, o) {
      if (e instanceof qe) {
        let s = this._createInjector(o, i, r, void 0),
            a = {$implicit: o.data, dialogRef: i};
        o.templateContext &&
            (a = y(
                 y({}, a),
                 typeof o.templateContext == 'function' ? o.templateContext() :
                                                          o.templateContext)),
            r.attachTemplatePortal(new vi(e, null, a, s))
      } else {
        let s = this._createInjector(o, i, r, this._injector),
            a = r.attachComponentPortal(new jr(e, o.viewContainerRef, s));
        i.componentRef = a, i.componentInstance = a.instance
      }
    }
    _createInjector(e, i, r, o) {
      let s = e.injector || e.viewContainerRef?.injector,
          a = [{provide: YB, useValue: e.data}, {provide: oc, useValue: i}];
      return e.providers &&
                 (typeof e.providers == 'function' ?
                      a.push(...e.providers(i, e, r)) :
                      a.push(...e.providers)),
             e.direction && (!s || !s.get(dt, null, {optional: !0})) && a.push({
               provide: dt,
               useValue: {value: e.direction, change: G()}
             }),
             he.create({parent: s || o, providers: a})
    }
    _removeOpenDialog(e, i) {
      let r = this.openDialogs.indexOf(e);
      r > -1 &&
          (this.openDialogs.splice(r, 1),
           this.openDialogs.length ||
               (this._ariaHiddenElements.forEach(
                    (o, s) => {
                        o ? s.setAttribute('aria-hidden', o) :
                            s.removeAttribute('aria-hidden')}),
                this._ariaHiddenElements.clear(),
                i && this._getAfterAllClosed().next()))
    }
    _hideNonDialogContentFromAssistiveTechnology() {
      let e = this._overlayContainer.getContainerElement();
      if (e.parentElement) {
        let i = e.parentElement.children;
        for (let r = i.length - 1; r > -1; r--) {
          let o = i[r];
          o !== e && o.nodeName !== 'SCRIPT' && o.nodeName !== 'STYLE' &&
              !o.hasAttribute('aria-live') &&
              (this._ariaHiddenElements.set(o, o.getAttribute('aria-hidden')),
               o.setAttribute('aria-hidden', 'true'))
        }
      }
    }
    _getAfterAllClosed() {
      let e = this._parentDialog;
      return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
  } return n
})();
function Qb(n, t) {
  let e = n.length;
  for (; e--;) t(n[e])
}
function KB(n, t) {}
var mh = class {
  viewContainerRef;
  injector;
  id;
  role = 'dialog';
  panelClass = '';
  hasBackdrop = !0;
  backdropClass = '';
  disableClose = !1;
  width = '';
  height = '';
  minWidth;
  minHeight;
  maxWidth;
  maxHeight;
  position;
  data = null;
  direction;
  ariaDescribedBy = null;
  ariaLabelledBy = null;
  ariaLabel = null;
  ariaModal = !1;
  autoFocus = 'first-tabbable';
  restoreFocus = !0;
  delayFocusTrap = !0;
  scrollStrategy;
  closeOnNavigation = !0;
  componentFactoryResolver;
  enterAnimationDuration;
  exitAnimationDuration
}
, Zb = 'mdc-dialog--open', CS = 'mdc-dialog--opening',
  DS = 'mdc-dialog--closing', XB = 150, JB = 75,
  ez = (() => {
    class n extends Yb {
      _animationMode = u(Ve, {optional: !0});
      _animationStateChanged = new H;
      _animationsEnabled = this._animationMode !== 'NoopAnimations';
      _actionSectionCount = 0;
      _hostElement = this._elementRef.nativeElement;
      _enterAnimationDuration = this._animationsEnabled ?
          kS(this._config.enterAnimationDuration) ?? XB :
          0;
      _exitAnimationDuration = this._animationsEnabled ?
          kS(this._config.exitAnimationDuration) ?? JB :
          0;
      _animationTimer = null;
      _contentAttached() {
        super._contentAttached(), this._startOpenAnimation()
      }
      _startOpenAnimation() {
        this._animationStateChanged.emit(
            {state: 'opening', totalTime: this._enterAnimationDuration}),
            this._animationsEnabled ?
            (this._hostElement.style.setProperty(
                 ES, `${this._enterAnimationDuration}ms`),
             this._requestAnimationFrame(
                 () => this._hostElement.classList.add(CS, Zb)),
             this._waitForAnimationToComplete(
                 this._enterAnimationDuration, this._finishDialogOpen)) :
            (this._hostElement.classList.add(Zb),
             Promise.resolve().then(() => this._finishDialogOpen()))
      }
      _startExitAnimation() {
        this._animationStateChanged.emit(
            {state: 'closing', totalTime: this._exitAnimationDuration}),
            this._hostElement.classList.remove(Zb),
            this._animationsEnabled ?
            (this._hostElement.style.setProperty(
                 ES, `${this._exitAnimationDuration}ms`),
             this._requestAnimationFrame(
                 () => this._hostElement.classList.add(DS)),
             this._waitForAnimationToComplete(
                 this._exitAnimationDuration, this._finishDialogClose)) :
            Promise.resolve().then(() => this._finishDialogClose())
      }
      _updateActionSectionCount(e) {
        this._actionSectionCount += e, this._changeDetectorRef.markForCheck()
      }
      _finishDialogOpen = () => {
        this._clearAnimationClasses(),
            this._openAnimationDone(this._enterAnimationDuration)
      };
      _finishDialogClose = () => {
        this._clearAnimationClasses(),
            this._animationStateChanged.emit(
                {state: 'closed', totalTime: this._exitAnimationDuration})
      };
      _clearAnimationClasses() {
        this._hostElement.classList.remove(CS, DS)
      }
      _waitForAnimationToComplete(e, i) {
        this._animationTimer !== null && clearTimeout(this._animationTimer),
            this._animationTimer = setTimeout(i, e)
      }
      _requestAnimationFrame(e) {
        this._ngZone.runOutsideAngular(
            () => {
                typeof requestAnimationFrame == 'function' ?
                    requestAnimationFrame(e) :
                    e()})
      }
      _captureInitialFocus() {
        this._config.delayFocusTrap || this._trapFocus()
      }
      _openAnimationDone(e) {
        this._config.delayFocusTrap && this._trapFocus(),
            this._animationStateChanged.next({state: 'opened', totalTime: e})
      }
      ngOnDestroy() {
        super.ngOnDestroy(),
            this._animationTimer !== null && clearTimeout(this._animationTimer)
      }
      attachComponentPortal(e) {
        let i = super.attachComponentPortal(e);
        return i.location.nativeElement.classList.add(
                   'mat-mdc-dialog-component-host'),
               i
      }
      static \u0275fac = (() => {
        let e;
        return function(r) {
          return (e || (e = Te(n)))(r || n)
        }
      })();
      static \u0275cmp = O({
        type: n,
        selectors: [['mat-dialog-container']],
        hostAttrs:
            ['tabindex', '-1', 1, 'mat-mdc-dialog-container', 'mdc-dialog'],
        hostVars: 10,
        hostBindings: function(i, r) {
          i&2 &&
              (en('id', r._config.id),
               J('aria-modal', r._config.ariaModal)('role', r._config.role)(
                   'aria-labelledby',
                   r._config.ariaLabel ? null : r._ariaLabelledByQueue[0])(
                   'aria-label', r._config.ariaLabel)(
                   'aria-describedby', r._config.ariaDescribedBy || null),
               Y('_mat-animation-noopable', !r._animationsEnabled)(
                   'mat-mdc-dialog-container-with-actions',
                   r._actionSectionCount > 0))
        },
        features: [te],
        decls: 3,
        vars: 0,
        consts: [
          [1, 'mat-mdc-dialog-inner-container', 'mdc-dialog__container'],
          [1, 'mat-mdc-dialog-surface', 'mdc-dialog__surface'],
          ['cdkPortalOutlet', '']
        ],
        template: function(i, r) {
          i&1 &&
              (f(0, 'div', 0)(1, 'div', 1), R(2, KB, 0, 0, 'ng-template', 2),
               g()())
        },
        dependencies: [Xi],
        styles: [
          '.mat-mdc-dialog-container{width:100%;height:100%;display:block;box-sizing:border-box;max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;outline:0}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 560px);min-width:var(--mat-dialog-container-min-width, 280px)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, calc(100vw - 32px))}}.mat-mdc-dialog-inner-container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;transition:opacity linear var(--mat-dialog-transition-duration, 0ms);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mdc-dialog--closing .mat-mdc-dialog-inner-container{transition:opacity 75ms linear;transform:none}.mdc-dialog--open .mat-mdc-dialog-inner-container{opacity:1}._mat-animation-noopable .mat-mdc-dialog-inner-container{transition:none}.mat-mdc-dialog-surface{display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;width:100%;height:100%;position:relative;overflow-y:auto;outline:0;transform:scale(0.8);transition:transform var(--mat-dialog-transition-duration, 0ms) cubic-bezier(0, 0, 0.2, 1);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;box-shadow:var(--mat-dialog-container-elevation-shadow, none);border-radius:var(--mdc-dialog-container-shape, var(--mat-sys-corner-extra-large, 4px));background-color:var(--mdc-dialog-container-color, var(--mat-sys-surface, white))}[dir=rtl] .mat-mdc-dialog-surface{text-align:right}.mdc-dialog--open .mat-mdc-dialog-surface,.mdc-dialog--closing .mat-mdc-dialog-surface{transform:none}._mat-animation-noopable .mat-mdc-dialog-surface{transition:none}.mat-mdc-dialog-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-dialog-title{display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:var(--mat-dialog-headline-padding, 6px 24px 13px)}.mat-mdc-dialog-title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mat-mdc-dialog-title{text-align:right}.mat-mdc-dialog-container .mat-mdc-dialog-title{color:var(--mdc-dialog-subhead-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mdc-dialog-subhead-font, var(--mat-sys-headline-small-font, inherit));line-height:var(--mdc-dialog-subhead-line-height, var(--mat-sys-headline-small-line-height, 1.5rem));font-size:var(--mdc-dialog-subhead-size, var(--mat-sys-headline-small-size, 1rem));font-weight:var(--mdc-dialog-subhead-weight, var(--mat-sys-headline-small-weight, 400));letter-spacing:var(--mdc-dialog-subhead-tracking, var(--mat-sys-headline-small-tracking, 0.03125em))}.mat-mdc-dialog-content{display:block;flex-grow:1;box-sizing:border-box;margin:0;overflow:auto;max-height:65vh}.mat-mdc-dialog-content>:first-child{margin-top:0}.mat-mdc-dialog-content>:last-child{margin-bottom:0}.mat-mdc-dialog-container .mat-mdc-dialog-content{color:var(--mdc-dialog-supporting-text-color, var(--mat-sys-on-surface-variant, rgba(0, 0, 0, 0.6)));font-family:var(--mdc-dialog-supporting-text-font, var(--mat-sys-body-medium-font, inherit));line-height:var(--mdc-dialog-supporting-text-line-height, var(--mat-sys-body-medium-line-height, 1.5rem));font-size:var(--mdc-dialog-supporting-text-size, var(--mat-sys-body-medium-size, 1rem));font-weight:var(--mdc-dialog-supporting-text-weight, var(--mat-sys-body-medium-weight, 400));letter-spacing:var(--mdc-dialog-supporting-text-tracking, var(--mat-sys-body-medium-tracking, 0.03125em))}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px 0)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0);padding:var(--mat-dialog-actions-padding, 16px 24px);justify-content:var(--mat-dialog-actions-alignment, flex-end)}@media(forced-colors: active){.mat-mdc-dialog-actions{border-top-color:CanvasText}}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}.mat-mdc-dialog-component-host{display:contents}'
        ],
        encapsulation: 2
      })
    } return n
  })(),
  ES = '--mat-dialog-transition-duration';
function kS(n) {
  return n == null         ? null :
      typeof n == 'number' ? n :
      n.endsWith('ms')     ? mn(n.substring(0, n.length - 2)) :
      n.endsWith('s')      ? mn(n.substring(0, n.length - 1)) * 1e3 :
      n === '0'            ? 0 :
                             null
}
var uh = function(n) {
  return n[n.OPEN = 0] = 'OPEN', n[n.CLOSING = 1] = 'CLOSING',
                    n[n.CLOSED = 2] = 'CLOSED', n
}(uh || {}), hn = class {
  _ref;
  _containerInstance;
  componentInstance;
  componentRef;
  disableClose;
  id;
  _afterOpened = new I;
  _beforeClosed = new I;
  _result;
  _closeFallbackTimeout;
  _state = uh.OPEN;
  _closeInteractionType;
  constructor(t, e, i) {
    this._ref = t, this._containerInstance = i,
    this.disableClose = e.disableClose, this.id = t.id,
    t.addPanelClass('mat-mdc-dialog-panel'),
    i._animationStateChanged.pipe(me(r => r.state === 'opened'), Ye(1))
        .subscribe(
            () => {this._afterOpened.next(), this._afterOpened.complete()}),
    i._animationStateChanged.pipe(me(r => r.state === 'closed'), Ye(1))
        .subscribe(() => {
          clearTimeout(this._closeFallbackTimeout),
          this._finishDialogClose()
        }),
    t.overlayRef.detachments().subscribe(() => {
      this._beforeClosed.next(this._result),
      this._beforeClosed.complete(),
      this._finishDialogClose()
    }),
    Ke(this.backdropClick(),
       this.keydownEvents().pipe(
           me(r => r.keyCode === 27 && !this.disableClose && !wt(r))))
        .subscribe(
            r => {
                this.disableClose ||
                (r.preventDefault(),
                 SS(this, r.type === 'keydown' ? 'keyboard' : 'mouse'))})
  }
  close(t) {
    this._result = t,
    this._containerInstance._animationStateChanged
        .pipe(me(e => e.state === 'closing'), Ye(1))
        .subscribe(e => {
          this._beforeClosed.next(t),
          this._beforeClosed.complete(),
          this._ref.overlayRef.detachBackdrop(),
          this._closeFallbackTimeout =
              setTimeout(() => this._finishDialogClose(), e.totalTime + 100)
        }),
    this._state = uh.CLOSING, this._containerInstance._startExitAnimation()
  }
  afterOpened() {
    return this._afterOpened
  }
  afterClosed() {
    return this._ref.closed
  }
  beforeClosed() {
    return this._beforeClosed
  }
  backdropClick() {
    return this._ref.backdropClick
  }
  keydownEvents() {
    return this._ref.keydownEvents
  }
  updatePosition(t) {
    let e = this._ref.config.positionStrategy;
    return t && (t.left || t.right) ?
               t.left ? e.left(t.left) : e.right(t.right) :
               e.centerHorizontally(),
           t && (t.top || t.bottom) ?
               t.top ? e.top(t.top) : e.bottom(t.bottom) :
               e.centerVertically(),
           this._ref.updatePosition(), this
  }
  updateSize(t = '', e = '') {
    return this._ref.updateSize(t, e), this
  }
  addPanelClass(t) {
    return this._ref.addPanelClass(t), this
  }
  removePanelClass(t) {
    return this._ref.removePanelClass(t), this
  }
  getState() {
    return this._state
  }
  _finishDialogClose() {
    this._state = uh.CLOSED,
    this._ref.close(this._result, {focusOrigin: this._closeInteractionType}),
    this.componentInstance = null
  }
};
function SS(n, t, e) {
  return n._closeInteractionType = t, n.close(e)
}
var nr = new w('MatMdcDialogData'),
    tz = new w('mat-mdc-dialog-default-options'),
    nz = new w('mat-mdc-dialog-scroll-strategy', {
      providedIn: 'root',
      factory: () => {
        let n = u(St);
        return () => n.scrollStrategies.block()
      }
    });
var Wr =
        (() => {
          class n {
            _overlay = u(St);
            _defaultOptions = u(tz, {optional: !0});
            _scrollStrategy = u(nz);
            _parentDialog = u(n, {optional: !0, skipSelf: !0});
            _idGenerator = u(et);
            _dialog = u(xS);
            _openDialogsAtThisLevel = [];
            _afterAllClosedAtThisLevel = new I;
            _afterOpenedAtThisLevel = new I;
            dialogConfigClass = mh;
            _dialogRefConstructor;
            _dialogContainerType;
            _dialogDataToken;
            get openDialogs() {
              return this._parentDialog ? this._parentDialog.openDialogs :
                                          this._openDialogsAtThisLevel
            }
            get afterOpened() {
              return this._parentDialog ? this._parentDialog.afterOpened :
                                          this._afterOpenedAtThisLevel
            }
            _getAfterAllClosed() {
              let e = this._parentDialog;
              return e ? e._getAfterAllClosed() :
                         this._afterAllClosedAtThisLevel
            }
            afterAllClosed =
                Xn(() => this.openDialogs.length ?
                       this._getAfterAllClosed() :
                       this._getAfterAllClosed().pipe(Xe(void 0)));
            constructor() {
              this._dialogRefConstructor = hn, this._dialogContainerType = ez,
              this._dialogDataToken = nr
            }
            open(e, i) {
              let r;
              i = y(y({}, this._defaultOptions || new mh), i),
              i.id = i.id || this._idGenerator.getId('mat-mdc-dialog-'),
              i.scrollStrategy = i.scrollStrategy || this._scrollStrategy();
              let o = this._dialog.open(
                  e, ae(y({}, i), {
                    positionStrategy: this._overlay.position()
                                          .global()
                                          .centerHorizontally()
                                          .centerVertically(),
                    disableClose: !0,
                    closeOnDestroy: !1,
                    closeOnOverlayDetachments: !1,
                    container: {
                      type: this._dialogContainerType,
                      providers: () =>
                          [{provide: this.dialogConfigClass, useValue: i},
                           {provide: $r, useValue: i}]
                    },
                    templateContext: () => ({dialogRef: r}),
                    providers: (s, a, l) =>
                        (r = new this._dialogRefConstructor(s, i, l),
                         r.updatePosition(i?.position),
                         [
                           {provide: this._dialogContainerType, useValue: l},
                           {provide: this._dialogDataToken, useValue: a.data},
                           {provide: this._dialogRefConstructor, useValue: r}
                         ])
                  }));
              return r.componentRef = o.componentRef,
                     r.componentInstance = o.componentInstance,
                     this.openDialogs.push(r), this.afterOpened.next(r),
                     r.afterClosed().subscribe(() => {
                       let s = this.openDialogs.indexOf(r);
                       s > -1 &&
                           (this.openDialogs.splice(s, 1),
                            this.openDialogs.length ||
                                this._getAfterAllClosed().next())
                     }),
                     r
            }
            closeAll() {
              this._closeDialogs(this.openDialogs)
            }
            getDialogById(e) {
              return this.openDialogs.find(i => i.id === e)
            }
            ngOnDestroy() {
              this._closeDialogs(this._openDialogsAtThisLevel),
                  this._afterAllClosedAtThisLevel.complete(),
                  this._afterOpenedAtThisLevel.complete()
            }
            _closeDialogs(e) {
              let i = e.length;
              for (; i--;) e[i].close()
            }
            static \u0275fac = function(i) {
              return new (i || n)
            };
            static \u0275prov =
                C({token: n, factory: n.\u0275fac, providedIn: 'root'})
          } return n
        })(),
    fa = (() => {
      class n {
        dialogRef = u(hn, {optional: !0});
        _elementRef = u(L);
        _dialog = u(Wr);
        ariaLabel;
        type = 'button';
        dialogResult;
        _matDialogClose;
        constructor() {}
        ngOnInit() {
          this.dialogRef ||
              (this.dialogRef = MS(this._elementRef, this._dialog.openDialogs))
        }
        ngOnChanges(e) {
          let i = e._matDialogClose || e._matDialogCloseResult;
          i && (this.dialogResult = i.currentValue)
        }
        _onButtonClick(e) {
          SS(this.dialogRef,
             e.screenX === 0 && e.screenY === 0 ? 'keyboard' : 'mouse',
             this.dialogResult)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'mat-dialog-close', ''], ['', 'matDialogClose', '']],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&1 && M('click', function(s) {
              return r._onButtonClick(s)
            }), i&2 && J('aria-label', r.ariaLabel || null)('type', r.type)
          },
          inputs: {
            ariaLabel: [0, 'aria-label', 'ariaLabel'],
            type: 'type',
            dialogResult: [0, 'mat-dialog-close', 'dialogResult'],
            _matDialogClose: [0, 'matDialogClose', '_matDialogClose']
          },
          exportAs: ['matDialogClose'],
          features: [Pe]
        })
      } return n
    })(),
    IS = (() => {
      class n {
        _dialogRef = u(hn, {optional: !0});
        _elementRef = u(L);
        _dialog = u(Wr);
        constructor() {}
        ngOnInit() {
          this._dialogRef ||
              (this._dialogRef =
                   MS(this._elementRef, this._dialog.openDialogs)),
              this._dialogRef && Promise.resolve().then(() => {this._onAdd()})
        }
        ngOnDestroy() {
          this._dialogRef?._containerInstance &&
              Promise.resolve().then(() => {this._onRemove()})
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({type: n})
      } return n
    })(),
    qr = (() => {
      class n extends IS {
        id = u(et).getId('mat-mdc-dialog-title-');
        _onAdd() {
          this._dialogRef._containerInstance?._addAriaLabelledBy?.(this.id)
        }
        _onRemove() {
          this._dialogRef?._containerInstance?._removeAriaLabelledBy?.(this.id)
        }
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'mat-dialog-title', ''], ['', 'matDialogTitle', '']],
          hostAttrs: [1, 'mat-mdc-dialog-title', 'mdc-dialog__title'],
          hostVars: 1,
          hostBindings: function(i, r) {
            i&2 && en('id', r.id)
          },
          inputs: {id: 'id'},
          exportAs: ['matDialogTitle'],
          features: [te]
        })
      } return n
    })(),
    Gr = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['', 'mat-dialog-content', ''], ['mat-dialog-content'],
            ['', 'matDialogContent', '']
          ],
          hostAttrs: [1, 'mat-mdc-dialog-content', 'mdc-dialog__content'],
          features: [wC([Ki])]
        })
      } return n
    })(),
    Qr = (() => {
      class n extends IS {
        align;
        _onAdd() {
          this._dialogRef._containerInstance?._updateActionSectionCount?.(1)
        }
        _onRemove() {
          this._dialogRef._containerInstance?._updateActionSectionCount?.(-1)
        }
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [
            ['', 'mat-dialog-actions', ''], ['mat-dialog-actions'],
            ['', 'matDialogActions', '']
          ],
          hostAttrs: [1, 'mat-mdc-dialog-actions', 'mdc-dialog__actions'],
          hostVars: 6,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mat-mdc-dialog-actions-align-start', r.align === 'start')(
                    'mat-mdc-dialog-actions-align-center',
                    r.align === 'center')(
                    'mat-mdc-dialog-actions-align-end', r.align === 'end')
          },
          inputs: {align: 'align'},
          features: [te]
        })
      } return n
    })();
function MS(n, t) {
  let e = n.nativeElement.parentElement;
  for (; e && !e.classList.contains('mat-mdc-dialog-container');)
    e = e.parentElement;
  return e ? t.find(i => i.id === e.id) : null
}
var iz = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['ng-component']],
      hostAttrs: ['cdk-text-field-style-loader', ''],
      decls: 0,
      vars: 0,
      template: function(i, r) {},
      styles: [
        'textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0 !important;box-sizing:content-box !important;height:auto !important;overflow:hidden !important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0 !important;box-sizing:content-box !important;height:0 !important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}'
      ],
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})(),
    TS = _i({passive: !0}),
    RS = (() => {
      class n {
        _platform = u(Ie);
        _ngZone = u(U);
        _styleLoader = u(lt);
        _monitoredElements = new Map;
        constructor() {}
        monitor(e) {
          if (!this._platform.isBrowser) return mt;
          this._styleLoader.load(iz);
          let i = nn(e), r = this._monitoredElements.get(i);
          if (r) return r.subject;
          let o = new I, s = 'cdk-text-field-autofilled', a = l => {
            l.animationName === 'cdk-text-field-autofill-start' &&
                    !i.classList.contains(s) ?
                (i.classList.add(s),
                 this._ngZone.run(
                     () => o.next({target: l.target, isAutofilled: !0}))) :
                l.animationName === 'cdk-text-field-autofill-end' &&
                    i.classList.contains(s) &&
                    (i.classList.remove(s),
                     this._ngZone.run(
                         () => o.next({target: l.target, isAutofilled: !1})))
          };
          return this._ngZone.runOutsideAngular(() => {
            i.addEventListener('animationstart', a, TS),
            i.classList.add('cdk-text-field-autofill-monitored')
          }),
                 this._monitoredElements.set(i, {
                   subject: o,
                   unlisten: () => {
                     i.removeEventListener('animationstart', a, TS)
                   }
                 }),
                 o
        }
        stopMonitoring(e) {
          let i = nn(e), r = this._monitoredElements.get(i);
          r &&
              (r.unlisten(), r.subject.complete(),
               i.classList.remove('cdk-text-field-autofill-monitored'),
               i.classList.remove('cdk-text-field-autofilled'),
               this._monitoredElements.delete(i))
        }
        ngOnDestroy() {
          this._monitoredElements.forEach((e, i) => this.stopMonitoring(i))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275prov =
            C({token: n, factory: n.\u0275fac, providedIn: 'root'})
      } return n
    })();
var AS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({})
  } return n
})();
var rz = new w('MAT_INPUT_VALUE_ACCESSOR'),
    oz =
        [
          'button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range',
          'reset', 'submit'
        ],
    sz = new w('MAT_INPUT_CONFIG'),
    Yr = (() => {
      class n {
        _elementRef = u(L);
        _platform = u(Ie);
        ngControl = u(Bn, {optional: !0, self: !0});
        _autofillMonitor = u(RS);
        _ngZone = u(U);
        _formField = u(rc, {optional: !0});
        _renderer = u(rt);
        _uid = u(et).getId('mat-input-');
        _previousNativeValue;
        _inputValueAccessor;
        _signalBasedValueAccessor;
        _previousPlaceholder;
        _errorStateTracker;
        _config = u(sz, {optional: !0});
        _cleanupIosKeyup;
        _cleanupWebkitWheel;
        _formFieldDescribedBy;
        _isServer;
        _isNativeSelect;
        _isTextarea;
        _isInFormField;
        focused = !1;
        stateChanges = new I;
        controlType = 'mat-input';
        autofilled = !1;
        get disabled() {
          return this._disabled
        }
        set disabled(e) {
          this._disabled = Je(e),
          this.focused && (this.focused = !1, this.stateChanges.next())
        }
        _disabled = !1;
        get id() {
          return this._id
        }
        set id(e) {
          this._id = e || this._uid
        }
        _id;
        placeholder;
        name;
        get required() {
          return this._required ??
              this.ngControl?.control?.hasValidator(Ls.required) ?? !1
        }
        set required(e) {
          this._required = Je(e)
        }
        _required;
        get type() {
          return this._type
        }
        set type(e) {
          let i = this._type;
          this._type = e || 'text', this._validateType(),
          !this._isTextarea && ob().has(this._type) &&
              (this._elementRef.nativeElement.type = this._type),
          this._type !== i && this._ensureWheelDefaultBehavior()
        }
        _type = 'text';
        get errorStateMatcher() {
          return this._errorStateTracker.matcher
        }
        set errorStateMatcher(e) {
          this._errorStateTracker.matcher = e
        }
        userAriaDescribedBy;
        get value() {
          return this._signalBasedValueAccessor ?
              this._signalBasedValueAccessor.value() :
              this._inputValueAccessor.value
        }
        set value(e) {
          e !== this.value &&
              (this._signalBasedValueAccessor ?
                   this._signalBasedValueAccessor.value.set(e) :
                   this._inputValueAccessor.value = e,
               this.stateChanges.next())
        }
        get readonly() {
          return this._readonly
        }
        set readonly(e) {
          this._readonly = Je(e)
        }
        _readonly = !1;
        disabledInteractive;
        get errorState() {
          return this._errorStateTracker.errorState
        }
        set errorState(e) {
          this._errorStateTracker.errorState = e
        }
        _neverEmptyInputTypes = [
          'date', 'datetime', 'datetime-local', 'month', 'time', 'week'
        ].filter(e => ob().has(e));
        constructor() {
          let e = u(El, {optional: !0}), i = u(kl, {optional: !0}), r = u(Gm),
              o = u(rz, {optional: !0, self: !0}),
              s = this._elementRef.nativeElement, a = s.nodeName.toLowerCase();
          o ? br(o.value) ?
              this._signalBasedValueAccessor = o :
              this._inputValueAccessor = o :
              this._inputValueAccessor = s,
              this._previousNativeValue = this.value, this.id = this.id,
              this._platform.IOS &&
              this._ngZone.runOutsideAngular(
                  () => {
                      this._cleanupIosKeyup = this._renderer.listen(
                          s, 'keyup', this._iOSKeyupListener)}),
              this._errorStateTracker =
                  new na(r, this.ngControl, i, e, this.stateChanges),
              this._isServer = !this._platform.isBrowser,
              this._isNativeSelect = a === 'select',
              this._isTextarea = a === 'textarea',
              this._isInFormField = !!this._formField,
              this.disabledInteractive =
                  this._config?.disabledInteractive || !1,
              this._isNativeSelect &&
              (this.controlType = s.multiple ? 'mat-native-select-multiple' :
                                               'mat-native-select'),
              this._signalBasedValueAccessor && ul(() => {
                this._signalBasedValueAccessor.value(),
                this.stateChanges.next()
              })
        }
        ngAfterViewInit() {
          this._platform.isBrowser &&
              this._autofillMonitor.monitor(this._elementRef.nativeElement)
                  .subscribe(e => {
                    this.autofilled = e.isAutofilled,
                    this.stateChanges.next()
                  })
        }
        ngOnChanges() {
          this.stateChanges.next()
        }
        ngOnDestroy() {
          this.stateChanges.complete(),
              this._platform.isBrowser &&
              this._autofillMonitor.stopMonitoring(
                  this._elementRef.nativeElement),
              this._cleanupIosKeyup?.(), this._cleanupWebkitWheel?.()
        }
        ngDoCheck() {
          this.ngControl &&
              (this.updateErrorState(),
               this.ngControl.disabled !== null &&
                   this.ngControl.disabled !== this.disabled &&
                   (this.disabled = this.ngControl.disabled,
                    this.stateChanges.next())),
              this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder()
        }
        focus(e) {
          this._elementRef.nativeElement.focus(e)
        }
        updateErrorState() {
          this._errorStateTracker.updateErrorState()
        }
        _focusChanged(e) {
          if (e !== this.focused) {
            if (!this._isNativeSelect && e && this.disabled &&
                this.disabledInteractive) {
              let i = this._elementRef.nativeElement;
              i.type === 'number' ? (i.type = 'text', i.setSelectionRange(0, 0),
                                     i.type = 'number') :
                                    i.setSelectionRange(0, 0)
            }
            this.focused = e, this.stateChanges.next()
          }
        }
        _onInput() {}
        _dirtyCheckNativeValue() {
          let e = this._elementRef.nativeElement.value;
          this._previousNativeValue !== e &&
              (this._previousNativeValue = e, this.stateChanges.next())
        }
        _dirtyCheckPlaceholder() {
          let e = this._getPlaceholder();
          if (e !== this._previousPlaceholder) {
            let i = this._elementRef.nativeElement;
            this._previousPlaceholder = e,
            e ? i.setAttribute('placeholder', e) :
                i.removeAttribute('placeholder')
          }
        }
        _getPlaceholder() {
          return this.placeholder || null
        }
        _validateType() {
          oz.indexOf(this._type) > -1
        }
        _isNeverEmpty() {
          return this._neverEmptyInputTypes.indexOf(this._type) > -1
        }
        _isBadInput() {
          let e = this._elementRef.nativeElement.validity;
          return e && e.badInput
        }
        get empty() {
          return !this._isNeverEmpty() &&
              !this._elementRef.nativeElement.value && !this._isBadInput() &&
              !this.autofilled
        }
        get shouldLabelFloat() {
          if (this._isNativeSelect) {
            let e = this._elementRef.nativeElement, i = e.options[0];
            return this.focused || e.multiple || !this.empty ||
                !!(e.selectedIndex > -1 && i && i.label)
          } else
            return this.focused && !this.disabled || !this.empty
        }
        setDescribedByIds(e) {
          let i = this._elementRef.nativeElement,
              r = i.getAttribute('aria-describedby'), o;
          if (r) {
            let s = this._formFieldDescribedBy || e;
            o = e.concat(r.split(' ').filter(a => a && !s.includes(a)))
          } else
            o = e;
          this._formFieldDescribedBy = e,
          o.length ? i.setAttribute('aria-describedby', o.join(' ')) :
                     i.removeAttribute('aria-describedby')
        }
        onContainerClick() {
          this.focused || this.focus()
        }
        _isInlineSelect() {
          let e = this._elementRef.nativeElement;
          return this._isNativeSelect && (e.multiple || e.size > 1)
        }
        _iOSKeyupListener = e => {
          let i = e.target;
          !i.value && i.selectionStart === 0 && i.selectionEnd === 0 &&
              (i.setSelectionRange(1, 1), i.setSelectionRange(0, 0))
        };
        _webkitBlinkWheelListener = () => {};
        _ensureWheelDefaultBehavior() {
          this._cleanupWebkitWheel?.(),
              this._type === 'number' &&
              (this._platform.BLINK || this._platform.WEBKIT) &&
              (this._cleanupWebkitWheel = this._renderer.listen(
                   this._elementRef.nativeElement, 'wheel',
                   this._webkitBlinkWheelListener))
        }
        _getReadonlyAttribute() {
          return this._isNativeSelect ? null :
              this.readonly || this.disabled && this.disabledInteractive ?
                                        'true' :
                                        null
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [
            ['input', 'matInput', ''], ['textarea', 'matInput', ''],
            ['select', 'matNativeControl', ''],
            ['input', 'matNativeControl', ''],
            ['textarea', 'matNativeControl', '']
          ],
          hostAttrs: [1, 'mat-mdc-input-element'],
          hostVars: 21,
          hostBindings: function(i, r) {
            i&1 &&
                M('focus',
                  function() {
                    return r._focusChanged(!0)
                  })(
                    'blur',
                    function() {
                      return r._focusChanged(!1)
                    })(
                    'input',
                    function() {
                      return r._onInput()
                    }),
                i&2 &&
                (en('id', r.id)(
                     'disabled', r.disabled && !r.disabledInteractive)(
                     'required', r.required),
                 J('name', r.name || null)(
                     'readonly', r._getReadonlyAttribute())(
                     'aria-disabled',
                     r.disabled && r.disabledInteractive ? 'true' : null)(
                     'aria-invalid',
                     r.empty && r.required ? null : r.errorState)(
                     'aria-required', r.required)('id', r.id),
                 Y('mat-input-server', r._isServer)(
                     'mat-mdc-form-field-textarea-control',
                     r._isInFormField && r._isTextarea)(
                     'mat-mdc-form-field-input-control', r._isInFormField)(
                     'mat-mdc-input-disabled-interactive',
                     r.disabledInteractive)(
                     'mdc-text-field__input', r._isInFormField)(
                     'mat-mdc-native-select-inline', r._isInlineSelect()))
          },
          inputs: {
            disabled: 'disabled',
            id: 'id',
            placeholder: 'placeholder',
            name: 'name',
            required: 'required',
            type: 'type',
            errorStateMatcher: 'errorStateMatcher',
            userAriaDescribedBy: [0, 'aria-describedby', 'userAriaDescribedBy'],
            value: 'value',
            readonly: 'readonly',
            disabledInteractive:
                [2, 'disabledInteractive', 'disabledInteractive', q]
          },
          exportAs: ['matInput'],
          features: [ye([{provide: ic, useExisting: n}]), Pe]
        })
      } return n
    })(),
    hh = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe, tr, tr, AS, pe]})
      } return n
    })();
function az(n, t) {
  n&1 && (f(0, 'h2', 4), E(1, 'Events List'), g())
}
function lz(n, t) {
  n&1 && (f(0, 'h2', 4), E(1, 'Send Response To Pending Event'), g())
}
function cz(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div')(1, 'p'), E(2, 'Name'), g(), f(3, 'p'), E(4), g(), f(5, 'p'),
        E(6, 'Args'), g(), f(7, 'p'), E(8), g(),
        f(9, 'mat-form-field', 5)(10, 'mat-label'), E(11, 'Response'), g(),
        f(12, 'textarea', 6), $i('ngModelChange', function(r) {
          N(e);
          let o = D();
          return xr(o.selectedEvent.response, r) ||
                     (o.selectedEvent.response = r),
                 P(r)
        }), g()()()
  }
  if (n & 2) {
    let e = D();
    b(4), Re(e.selectedEvent.name), b(4),
        Re(e.argsToJson(e.selectedEvent.args)), b(4),
        Ui('ngModel', e.selectedEvent.response)
  }
}
function dz(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 7), M('click', function() {
      N(e);
      let r = D();
      return P(r.sendResponse())
    }), E(1), g()
  }
  if (n & 2) {
    let e = D();
    x('disabled', e.sending), b(), Re(e.sending ? 'Sending...' : 'Send')
  }
}
var sc = class n {
  constructor(t, e, i) {
    this.dialogRef = t;
    this.data = e;
    this.agentService = i;
    this.selectedEvent = e.event, this.app_name = e.app_name,
    this.user_id = e.user_id, this.session_id = e.session_id,
    this.function_call_event_id = e.function_call_event_id
  }
  selectedEvent = null;
  app_name;
  user_id;
  session_id;
  function_call_event_id;
  sending = !1;
  argsToJson(t) {
    return JSON.stringify(t)
  }
  sendResponse() {
    this.sending = !0;
    let t = {
      app_name: this.app_name,
      user_id: this.user_id,
      session_id: this.session_id,
      new_message: {role: 'user', parts: []}
    };
    this.selectedEvent.response &&
        (t.function_call_event_id = this.function_call_event_id,
         t.new_message.parts.push({
           function_response: {
             id: this.selectedEvent.id,
             name: this.selectedEvent.name,
             response: {response: this.selectedEvent.response}
           }
         })),
        this.agentService.run(t).subscribe(e => {
          this.sending = !1;
          for (let i of e)
            i.content.parts[0].text && this.dialogRef.close({
              text: i.content.parts[0].text,
              events: [this.selectedEvent]
            })
        })
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(hn), z(nr), z(Hr))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-pending-event-dialog']],
    standalone: !1,
    decls: 8,
    vars: 4,
    consts:
        [
          ['mat-dialog-title', '', 4, 'ngIf'], [4, 'ngIf'],
          ['mat-button', '', 3, 'disabled', 'click', 4, 'ngIf'],
          ['mat-button', '', 'mat-dialog-close', ''], ['mat-dialog-title', ''],
          ['appearance', 'outline', 1, 'full-width'],
          ['matInput', '', 3, 'ngModelChange', 'ngModel'],
          ['mat-button', '', 3, 'click', 'disabled']
        ],
    template:
        function(e, i) {
          e&1 &&
              (R(0, az, 2, 0, 'h2', 0)(1, lz, 2, 0, 'h2', 0),
               f(2, 'mat-dialog-content'), R(3, cz, 13, 3, 'div', 1), g(),
               f(4, 'mat-dialog-actions'), R(5, dz, 2, 2, 'button', 2),
               f(6, 'button', 3), E(7, 'Close'), g()()),
              e&2 &&
              (x('ngIf', !i.selectedEvent), b(), x('ngIf', i.selectedEvent),
               b(2), x('ngIf', i.selectedEvent), b(2),
               x('ngIf', i.selectedEvent && i.selectedEvent.response))
        },
    dependencies: [fi, pi, Tr, Gi, xi, ah, Yr, bi, qr, Gr, Qr, fa],
    encapsulation: 2
  })
};
var ac = class n {
  constructor(t, e) {
    this.dialogRef = t;
    this.data = e
  }
  onConfirm() {
    this.dialogRef.close(!0)
  }
  onCancel() {
    this.dialogRef.close(!1)
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(hn), z(nr))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-delete-session-dialog']],
    standalone: !1,
    decls: 11,
    vars: 4,
    consts:
        [
          [1, 'confirm-delete-wrapper'], ['mat-dialog-title', ''],
          ['align', 'end'], ['mat-button', '', 3, 'click'],
          ['mat-button', '', 'cdkFocusInitial', '', 3, 'click']
        ],
    template:
        function(e, i) {
          e&1 &&
              (f(0, 'div', 0)(1, 'h2', 1), E(2), g(),
               f(3, 'mat-dialog-content')(4, 'p'), E(5), g()(),
               f(6, 'mat-dialog-actions', 2)(7, 'button', 3),
               M('click',
                 function() {
                   return i.onCancel()
                 }),
               E(8), g(), f(9, 'button', 4),
               M('click',
                 function() {
                   return i.onConfirm()
                 }),
               E(10), g()()()),
              e&2 &&
              (b(2), Re(i.data.title), b(3), Re(i.data.message), b(3),
               Re(i.data.cancelButtonText), b(2), Re(i.data.confirmButtonText))
        },
    dependencies: [bi, qr, Gr, Qr],
    encapsulation: 2
  })
};
var Wn = class n {
  constructor(t) {
    this.http = t
  }
  apiServerDomain = rn.getApiServerBaseUrl();
  createSession(t, e) {
    let i = this.apiServerDomain + `/apps/${e}/users/${t}/sessions`;
    return this.http.post(i, {_time: new Date})
  }
  listSessions(t, e) {
    let i = this.apiServerDomain + `/apps/${e}/users/${t}/sessions`;
    return this.http.get(i)
  }
  deleteSession(t, e, i) {
    let r = this.apiServerDomain + `/apps/${e}/users/${t}/sessions/${i}`;
    return this.http.delete(r)
  }
  getSession(t, e, i) {
    let r = this.apiServerDomain + `/apps/${e}/users/${t}/sessions/${i}`;
    return this.http.get(r)
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(zt))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
function uz(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 3), M('click', function() {
      let r = N(e).$implicit, o = D();
      return P(o.getSession(r))
    }), f(1, 'div', 4)(2, 'div', 5), E(3), g()()()
  }
  if (n & 2) {
    let e = t.$implicit, i = D();
    x('ngClass', e === i.sessionId ? 'session-item current' : 'session-item'),
        b(3), at(' ', e, ' ')
  }
}
var zo = class n {
  constructor(t, e) {
    this.sessionService = t;
    this.dialog = e;
    this.refreshSessionsSubject
        .pipe($e(
            () => this.sessionService.listSessions(this.userId, this.appName)))
        .subscribe(i => {
          i = i.map(r => r.id),
          i = i.sort((r, o) => Number(o) - Number(r)),
          this.sessions = i
        })
  }
  userId = '';
  appName = '';
  sessionId = '';
  sessionSelected = new H;
  sessions = [];
  refreshSessionsSubject = new I;
  ngOnInit() {
    setTimeout(() => {this.refreshSessionsSubject.next()}, 500)
  }
  getSession(t) {
    this.sessionService.getSession(this.userId, this.appName, t)
        .subscribe(e => {
          let i = this.fromApiResultToSession(e);
          this.sessionSelected.emit(i),
              console.dir('get session: ' + JSON.stringify(i))
        })
  }
  getDate(t) {
    let e = +t;
    return t.includes('|') && (e = +t.split('|')[1]),
           new Date(e).toLocaleString()
  }
  fromApiResultToSession(t) {
    return {
      id: t?.id ?? '', app_name: t?.app_name ?? '', user_id: t?.user_id ?? '',
          state: t?.state ?? [], events: t?.events ?? []
    }
  }
  refreshSession() {
    this.refreshSessionsSubject.next()
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Wn), z(Wr))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-session-tab']],
    inputs: {userId: 'userId', appName: 'appName', sessionId: 'sessionId'},
    outputs: {sessionSelected: 'sessionSelected'},
    standalone: !1,
    decls: 3,
    vars: 1,
    consts:
        [
          [1, 'session-wrapper'],
          [1, 'session-tab-container', 2, 'margin-top', '16px'],
          [3, 'ngClass', 'click', 4, 'ngFor', 'ngForOf'],
          [3, 'click', 'ngClass'], [1, 'session-info'], [1, 'session-id']
        ],
    template:
        function(e, i) {
          e&1 && (f(0, 'div', 0)(1, 'div', 1), R(2, uz, 4, 2, 'div', 2), g()()),
              e&2 && (b(2), x('ngForOf', i.sessions))
        },
    dependencies: [vn, yn],
    styles:
        [
          '.session-wrapper[_ngcontent-%COMP%]{padding-left:25px;padding-right:25px;color:#9aa0a6;font-size:14px;font-weight:700}.session-item[_ngcontent-%COMP%]{display:flex;justify-content:space-between;border:none;background-color:#303030;border-radius:8px;margin-bottom:4px;cursor:pointer}.session-item[_ngcontent-%COMP%]:hover{background-color:#141414}.session-item.current[_ngcontent-%COMP%]{background-color:#004a77}.session-id[_ngcontent-%COMP%]{color:#e8eaed;font-family:Google Sans;font-size:14px;font-style:normal;font-weight:500;line-height:20px;letter-spacing:.25px}.session-date[_ngcontent-%COMP%]{color:#9aa0a6;font-family:Roboto;font-size:12px;font-style:normal;font-weight:400;line-height:16px;letter-spacing:.3px}.session-info[_ngcontent-%COMP%]{padding:11px}'
        ]
  })
};
var ga = class n {
  constructor(t) {
    this.http = t
  }
  apiServerDomain = rn.getApiServerBaseUrl();
  getLatestArtifact(t, e, i, r) {
    let o = this.apiServerDomain +
        `/apps/${e}/users/${t}/sessions/${i}/artifacts/${r}`;
    return this.http.get(o)
  }
  getArtifactVersion(t, e, i, r, o) {
    let s = this.apiServerDomain +
        `/apps/${e}/users/${t}/sessions/${i}/artifacts/${r}/versions/${o}`;
    return this.http.get(s)
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(zt))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var fz = {
  url: '',
  deserializer: n => JSON.parse(n.data),
  serializer: n => JSON.stringify(n)
},
    pz =
        'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }',
    lc = class n extends is {
  constructor(t, e) {
    if (super(), this._socket = null, t instanceof ie)
      this.destination = e, this.source = t;
    else {
      let i = this._config = Object.assign({}, fz);
      if (this._output = new I, typeof t == 'string')
        i.url = t;
      else
        for (let r in t) t.hasOwnProperty(r) && (i[r] = t[r]);
      if (!i.WebSocketCtor && WebSocket)
        i.WebSocketCtor = WebSocket;
      else if (!i.WebSocketCtor)
        throw new Error('no WebSocket constructor can be found');
      this.destination = new In
    }
  }
  lift(t) {
    let e = new n(this._config, this.destination);
    return e.operator = t, e.source = this, e
  }
  _resetState() {
    this._socket = null, this.source || (this.destination = new In),
    this._output = new I
  }
  multiplex(t, e, i) {
    let r = this;
    return new ie(o => {
      try {
        r.next(t())
      } catch (a) {
        o.error(a)
      }
      let s = r.subscribe({
        next: a => {
          try {
            i(a) && o.next(a)
          } catch (l) {
            o.error(l)
          }
        },
        error: a => o.error(a),
        complete: () => o.complete()
      });
      return () => {
        try {
          r.next(e())
        } catch (a) {
          o.error(a)
        }
        s.unsubscribe()
      }
    })
  }
  _connectSocket() {
    let {WebSocketCtor: t, protocol: e, url: i, binaryType: r} = this._config,
                                                            o = this._output,
                                                            s = null;
    try {
      s = e ? new t(i, e) : new t(i), this._socket = s,
      r && (this._socket.binaryType = r)
    } catch (l) {
      o.error(l);
      return
    }
    let a = new ge(
        () => {this._socket = null, s && s.readyState === 1 && s.close()});
    s.onopen = l => {
      let {_socket: c} = this;
      if (!c) {
        s.close(), this._resetState();
        return
      }
      let {openObserver: d} = this._config;
      d && d.next(l);
      let m = this.destination;
      this.destination = Ti.create(
          p => {
            if (s.readyState === 1) try {
                let {serializer: h} = this._config;
                s.send(h(p))
              } catch (h) {
                this.destination.error(h)
              }
          },
          p => {
            let {closingObserver: h} = this._config;
            h && h.next(void 0),
                p && p.code ? s.close(p.code, p.reason) :
                              o.error(new TypeError(pz)),
                this._resetState()
          },
          () => {
            let {closingObserver: p} = this._config;
            p && p.next(void 0), s.close(), this._resetState()
          }),
      m && m instanceof In && a.add(m.subscribe(this.destination))
    }, s.onerror = l => {
      this._resetState(), o.error(l)
    }, s.onclose = l => {
      s === this._socket && this._resetState();
      let {closeObserver: c} = this._config;
      c && c.next(l), l.wasClean ? o.complete() : o.error(l)
    }, s.onmessage = l => {
      try {
        let {deserializer: c} = this._config;
        o.next(c(l))
      } catch (c) {
        o.error(c)
      }
    }
  }
  _subscribe(t) {
    let {source: e} = this;
    return e ?
        e.subscribe(t) :
        (this._socket || this._connectSocket(), this._output.subscribe(t),
         t.add(() => {
           let {_socket: i} = this;
           this._output.observers.length === 0 &&
               (i && (i.readyState === 1 || i.readyState === 0) && i.close(),
                this._resetState())
         }),
         t)
  }
  unsubscribe() {
    let {_socket: t} = this;
    t && (t.readyState === 1 || t.readyState === 0) && t.close(),
        this._resetState(), super.unsubscribe()
  }
};
var Di = class n {
  socket$;
  messages$ = new Le('');
  audioContext = new AudioContext({sampleRate: 22e3});
  audioBuffer = [];
  audioIntervalId = null;
  lastAudioTime = 0;
  constructor() {}
  connect(t) {
    this.socket$ = new lc({
      url: t,
      serializer: e => JSON.stringify(e),
      deserializer: e => e.data
    }),
    this.socket$.subscribe(
        e => {this.handleIncomingAudio(e), this.messages$.next(e)}, e => {
          console.error('WebSocket error:', e),
          setTimeout(() => this.connect(t), 3e3)
        },
        () => {
          console.log('WebSocket closed, reconnecting...'),
          setTimeout(() => this.connect(t), 3e3)
        }),
    this.audioIntervalId = setInterval(() => this.processBufferedAudio(), 250)
  }
  sendMessage(t) {
    if (t.blob.data = this.arrayBufferToBase64(t.blob.data.buffer),
        !this.socket$ || this.socket$.closed) {
      console.error('WebSocket is not open.');
      return
    }
    this.socket$.next(t)
  }
  closeConnection() {
    clearInterval(this.audioIntervalId), this.audioIntervalId = null,
                                         this.socket$ && this.socket$.complete()
  }
  getMessages() {
    return this.messages$.asObservable()
  }
  arrayBufferToBase64(t) {
    let e = '', i = new Uint8Array(t), r = i.byteLength;
    for (let o = 0; o < r; o++) e += String.fromCharCode(i[o]);
    return btoa(e)
  }
  handleIncomingAudio(t) {
    let e = JSON.parse(t);
    if (e.content.parts && e.content.parts[0].inlineData) {
      let i = this.base64ToUint8Array(e.content.parts[0].inlineData.data);
      this.audioBuffer.push(i)
    }
  }
  processBufferedAudio() {
    if (this.audioBuffer.length === 0) return;
    let t = this.audioBuffer.reduce((r, o) => r + o.length, 0),
        e = new Uint8Array(t), i = 0;
    for (let r of this.audioBuffer) e.set(r, i), i += r.length;
    this.playPCM(e), this.audioBuffer = []
  }
  base64ToUint8Array(t) {
    let e = atob(this.urlSafeBase64ToBase64(t)), i = e.length,
        r = new Uint8Array(i);
    for (let o = 0; o < i; o++) r[o] = e.charCodeAt(o);
    return r
  }
  playPCM(t) {
    let e = new Float32Array(t.length / 2);
    for (let a = 0; a < e.length; a++) {
      let l = t[a * 2] | t[a * 2 + 1] << 8;
      l >= 32768 && (l -= 65536), e[a] = l / 32768
    }
    let i = this.audioContext.createBuffer(1, e.length, 22e3);
    i.copyToChannel(e, 0);
    let r = this.audioContext.createBufferSource();
    r.buffer = i, r.connect(this.audioContext.destination);
    let o = this.audioContext.currentTime, s = Math.max(this.lastAudioTime, o);
    r.start(s), this.lastAudioTime = s + i.duration
  }
  urlSafeBase64ToBase64(t) {
    let e = t.replace(/_/g, '/').replace(/-/g, '+');
    for (; e.length % 4 !== 0;) e += '=';
    return e
  }
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var _a = class n {
  constructor(t) {
    this.wsService = t
  }
  mediaRecorder;
  stream;
  audioContext;
  source;
  processor;
  audioBuffer = [];
  audioIntervalId = null;
  startRecording() {
    return Tt(this, null, function*() {
      try {
        this.stream = yield navigator.mediaDevices.getUserMedia({audio: !0}),
        this.audioContext = new AudioContext,
        yield this.audioContext.audioWorklet.addModule(
            '/assets/audio-processor.js'),
        this.source = this.audioContext.createMediaStreamSource(this.stream);
        let t = new AudioWorkletNode(this.audioContext, 'audio-processor');
        t.port.onmessage =
            e => {
              let i = e.data, r = this.float32ToPCM(i);
              this.audioBuffer.push(r)
            },
        this.source.connect(t), t.connect(this.audioContext.destination),
        this.audioIntervalId = setInterval(() => this.sendBufferedAudio(), 250)
      } catch (t) {
        console.error('Error accessing microphone:', t)
      }
    })
  }
  sendBufferedAudio() {
    if (this.audioBuffer.length === 0) return;
    let t = this.audioBuffer.reduce((o, s) => o + s.length, 0),
        e = new Uint8Array(t), i = 0;
    for (let o of this.audioBuffer) e.set(o, i), i += o.length;
    let r = {blob: {mime_type: 'audio/pcm', data: e}};
    this.wsService.sendMessage(r), this.audioBuffer = []
  }
  stopRecording() {
    this.processor && this.processor.disconnect(),
        this.source && this.source.disconnect(),
        this.audioContext && this.audioContext.close(),
        this.stream && this.stream.getTracks().forEach(t => t.stop()),
        this.audioIntervalId &&
        (clearInterval(this.audioIntervalId), this.audioIntervalId = null)
  }
  float32ToPCM(t) {
    let e = new ArrayBuffer(t.length * 2), i = new DataView(e);
    for (let r = 0; r < t.length; r++) {
      let o = Math.max(-1, Math.min(1, t[r]));
      o = o < 0 ? o * 32768 : o * 32767, i.setInt16(r * 2, o, !0)
    }
    return new Uint8Array(e)
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(Di))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var ba = class n {
  constructor(t, e) {
    this.wsService = t;
    this.renderer = e.createRenderer(null, null)
  }
  mediaRecorder;
  stream;
  renderer;
  videoElement;
  videoBuffer = [];
  videoIntervalId = null;
  createVideoElement(t) {
    this.clearVideoElement(t),
        this.videoElement = this.renderer.createElement('video'),
        this.renderer.setAttribute(this.videoElement, 'width', '400'),
        this.renderer.setAttribute(this.videoElement, 'height', '300'),
        this.renderer.setAttribute(this.videoElement, 'autoplay', 'true'),
        this.renderer.setAttribute(this.videoElement, 'muted', 'true'),
        this.renderer.appendChild(t.nativeElement, this.videoElement)
  }
  startRecording(t) {
    return Tt(this, null, function*() {
      this.createVideoElement(t);
      try {
        this.stream = yield navigator.mediaDevices.getUserMedia({video: !0}),
        this.videoElement.srcObject = this.stream,
        this.mediaRecorder =
            new MediaRecorder(this.stream, {mimeType: 'video/webm'}),
        this.mediaRecorder.start(1e3),
        this.videoIntervalId =
            setInterval(() => this.captureAndSendFrame(), 1e3)
      } catch (e) {
        console.error('Error accessing camera/microphone:', e)
      }
    })
  }
  captureAndSendFrame() {
    return Tt(this, null, function*() {
      try {
        let t = yield this.captureFrame(), i = {
          blob: {mime_type: 'image/jpeg', data: yield this.blobToUint8Array(t)}
        };
        this.wsService.sendMessage(i)
      } catch (t) {
        console.error('Error capturing frame:', t)
      }
    })
  }
  blobToUint8Array(t) {
    return Tt(this, null, function*() {
      let e = yield t.arrayBuffer();
      return new Uint8Array(e)
    })
  }
  captureFrame() {
    return Tt(this, null, function*() {
      return new Promise((t, e) => {
        try {
          let i = document.createElement('canvas');
          i.width = this.videoElement.videoWidth,
          i.height = this.videoElement.videoHeight;
          let r = i.getContext('2d');
          if (!r) {
            e(new Error('Canvas context not supported'));
            return
          }
          r.drawImage(this.videoElement, 0, 0, i.width, i.height),
              i.toBlob(
                  o => {o ? t(o) : e(new Error('Failed to create image blob'))},
                  'image/png')
        } catch (i) {
          e(i)
        }
      })
    })
  }
  sendBufferedVideo() {
    if (this.videoBuffer.length === 0) return;
    let t = this.videoBuffer.reduce((o, s) => o + s.length, 0),
        e = new Uint8Array(t), i = 0;
    for (let o of this.videoBuffer) e.set(o, i), i += o.length;
    let r = {blob: {mime_type: 'image/jpeg', data: e}};
    this.wsService.sendMessage(r), this.videoBuffer = []
  }
  stopRecording(t) {
    this.mediaRecorder && this.mediaRecorder.stop(),
        this.stream && this.stream.getTracks().forEach(e => e.stop()),
        clearInterval(this.videoIntervalId), this.clearVideoElement(t)
  }
  clearVideoElement(t) {
    let e = t.nativeElement.querySelector('video');
    e && this.renderer.removeChild(t.nativeElement, e)
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(Di), A(Ot))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var bz = ['*'];
var vz = new w('MAT_CARD_CONFIG'),
    OS = (() => {
      class n {
        appearance;
        constructor() {
          let e = u(vz, {optional: !0});
          this.appearance = e?.appearance || 'raised'
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-card']],
          hostAttrs: [1, 'mat-mdc-card', 'mdc-card'],
          hostVars: 4,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mat-mdc-card-outlined', r.appearance === 'outlined')(
                    'mdc-card--outlined', r.appearance === 'outlined')
          },
          inputs: {appearance: 'appearance'},
          exportAs: ['matCard'],
          ngContentSelectors: bz,
          decls: 1,
          vars: 0,
          template: function(i, r) {
            i&1 && (Se(), Z(0))
          },
          styles: [
            '.mat-mdc-card{display:flex;flex-direction:column;box-sizing:border-box;position:relative;border-style:solid;border-width:0;background-color:var(--mdc-elevated-card-container-color, var(--mat-sys-surface-container-low));border-color:var(--mdc-elevated-card-container-color, var(--mat-sys-surface-container-low));border-radius:var(--mdc-elevated-card-container-shape, var(--mat-sys-corner-medium));box-shadow:var(--mdc-elevated-card-container-elevation, var(--mat-sys-level1))}.mat-mdc-card::after{position:absolute;top:0;left:0;width:100%;height:100%;border:solid 1px rgba(0,0,0,0);content:"";display:block;pointer-events:none;box-sizing:border-box;border-radius:var(--mdc-elevated-card-container-shape, var(--mat-sys-corner-medium))}.mat-mdc-card-outlined{background-color:var(--mdc-outlined-card-container-color, var(--mat-sys-surface));border-radius:var(--mdc-outlined-card-container-shape, var(--mat-sys-corner-medium));border-width:var(--mdc-outlined-card-outline-width, 1px);border-color:var(--mdc-outlined-card-outline-color, var(--mat-sys-outline-variant));box-shadow:var(--mdc-outlined-card-container-elevation, var(--mat-sys-level0))}.mat-mdc-card-outlined::after{border:none}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mat-mdc-card-actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mat-mdc-card-title{font-family:var(--mat-card-title-text-font, var(--mat-sys-title-large-font));line-height:var(--mat-card-title-text-line-height, var(--mat-sys-title-large-line-height));font-size:var(--mat-card-title-text-size, var(--mat-sys-title-large-size));letter-spacing:var(--mat-card-title-text-tracking, var(--mat-sys-title-large-tracking));font-weight:var(--mat-card-title-text-weight, var(--mat-sys-title-large-weight))}.mat-mdc-card-subtitle{color:var(--mat-card-subtitle-text-color, var(--mat-sys-on-surface));font-family:var(--mat-card-subtitle-text-font, var(--mat-sys-title-medium-font));line-height:var(--mat-card-subtitle-text-line-height, var(--mat-sys-title-medium-line-height));font-size:var(--mat-card-subtitle-text-size, var(--mat-sys-title-medium-size));letter-spacing:var(--mat-card-subtitle-text-tracking, var(--mat-sys-title-medium-tracking));font-weight:var(--mat-card-subtitle-text-weight, var(--mat-sys-title-medium-weight))}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var NS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe, pe]})
  } return n
})();
var wz = ['*'], ph;
function xz() {
  if (ph === void 0 && (ph = null, typeof window < 'u')) {
    let n = window;
    n.trustedTypes !== void 0 &&
        (ph = n.trustedTypes.createPolicy(
             'angular#components', {createHTML: t => t}))
  }
  return ph
}
function cc(n) {
  return xz()?.createHTML(n) || n
}
function PS(n) {
  return Error(`Unable to find icon with the name "${n}"`)
}
function Cz() {
  return Error(
      'Could not find HttpClient for use with Angular Material icons. Please add provideHttpClient() to your providers.')
}
function FS(n) {
  return Error(
      `The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${
          n}".`)
}
function LS(n) {
  return Error(
      `The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${
          n}".`)
}
var ir = class {
  url;
  svgText;
  options;
  svgElement;
  constructor(t, e, i) {
    this.url = t, this.svgText = e, this.options = i
  }
}
, Dz = (() => {
    class n {
      _httpClient;
      _sanitizer;
      _errorHandler;
      _document;
      _svgIconConfigs = new Map;
      _iconSetConfigs = new Map;
      _cachedIconsByUrl = new Map;
      _inProgressUrlFetches = new Map;
      _fontCssClassesByAlias = new Map;
      _resolvers = [];
      _defaultFontSetClass = ['material-icons', 'mat-ligature-font'];
      constructor(e, i, r, o) {
        this._httpClient = e, this._sanitizer = i, this._errorHandler = o,
        this._document = r
      }
      addSvgIcon(e, i, r) {
        return this.addSvgIconInNamespace('', e, i, r)
      }
      addSvgIconLiteral(e, i, r) {
        return this.addSvgIconLiteralInNamespace('', e, i, r)
      }
      addSvgIconInNamespace(e, i, r, o) {
        return this._addSvgIconConfig(e, i, new ir(r, null, o))
      }
      addSvgIconResolver(e) {
        return this._resolvers.push(e), this
      }
      addSvgIconLiteralInNamespace(e, i, r, o) {
        let s = this._sanitizer.sanitize(Et.HTML, r);
        if (!s) throw LS(r);
        let a = cc(s);
        return this._addSvgIconConfig(e, i, new ir('', a, o))
      }
      addSvgIconSet(e, i) {
        return this.addSvgIconSetInNamespace('', e, i)
      }
      addSvgIconSetLiteral(e, i) {
        return this.addSvgIconSetLiteralInNamespace('', e, i)
      }
      addSvgIconSetInNamespace(e, i, r) {
        return this._addSvgIconSetConfig(e, new ir(i, null, r))
      }
      addSvgIconSetLiteralInNamespace(e, i, r) {
        let o = this._sanitizer.sanitize(Et.HTML, i);
        if (!o) throw LS(i);
        let s = cc(o);
        return this._addSvgIconSetConfig(e, new ir('', s, r))
      }
      registerFontClassAlias(e, i = e) {
        return this._fontCssClassesByAlias.set(e, i), this
      }
      classNameForFontAlias(e) {
        return this._fontCssClassesByAlias.get(e) || e
      }
      setDefaultFontSetClass(...e) {
        return this._defaultFontSetClass = e, this
      }
      getDefaultFontSetClass() {
        return this._defaultFontSetClass
      }
      getSvgIconFromUrl(e) {
        let i = this._sanitizer.sanitize(Et.RESOURCE_URL, e);
        if (!i) throw FS(e);
        let r = this._cachedIconsByUrl.get(i);
        return r ?
            G(gh(r)) :
            this._loadSvgIconFromConfig(new ir(e, null))
                .pipe(He(o => this._cachedIconsByUrl.set(i, o)), Q(o => gh(o)))
      }
      getNamedSvgIcon(e, i = '') {
        let r = VS(i, e), o = this._svgIconConfigs.get(r);
        if (o) return this._getSvgFromConfig(o);
        if (o = this._getIconConfigFromResolvers(i, e), o)
          return this._svgIconConfigs.set(r, o), this._getSvgFromConfig(o);
        let s = this._iconSetConfigs.get(i);
        return s ? this._getSvgFromIconSetConfigs(e, s) : ar(PS(r))
      }
      ngOnDestroy() {
        this._resolvers = [], this._svgIconConfigs.clear(),
        this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear()
      }
      _getSvgFromConfig(e) {
        return e.svgText ? G(gh(this._svgElementFromConfig(e))) :
                           this._loadSvgIconFromConfig(e).pipe(Q(i => gh(i)))
      }
      _getSvgFromIconSetConfigs(e, i) {
        let r = this._extractIconWithNameFromAnySet(e, i);
        if (r) return G(r);
        let o = i.filter(s => !s.svgText)
                    .map(s => this._loadSvgIconSetFromConfig(s).pipe(sn(a => {
                      let c = `Loading icon set URL: ${
                          this._sanitizer.sanitize(
                              Et.RESOURCE_URL, s.url)} failed: ${a.message}`;
                      return this._errorHandler.handleError(new Error(c)),
                             G(null)
                    })));
        return Fa(o).pipe(Q(() => {
          let s = this._extractIconWithNameFromAnySet(e, i);
          if (!s) throw PS(e);
          return s
        }))
      }
      _extractIconWithNameFromAnySet(e, i) {
        for (let r = i.length - 1; r >= 0; r--) {
          let o = i[r];
          if (o.svgText && o.svgText.toString().indexOf(e) > -1) {
            let s = this._svgElementFromConfig(o),
                a = this._extractSvgIconFromSet(s, e, o.options);
            if (a) return a
          }
        }
        return null
      }
      _loadSvgIconFromConfig(e) {
        return this._fetchIcon(e).pipe(
            He(i => e.svgText = i), Q(() => this._svgElementFromConfig(e)))
      }
      _loadSvgIconSetFromConfig(e) {
        return e.svgText ? G(null) :
                           this._fetchIcon(e).pipe(He(i => e.svgText = i))
      }
      _extractSvgIconFromSet(e, i, r) {
        let o = e.querySelector(`[id="${i}"]`);
        if (!o) return null;
        let s = o.cloneNode(!0);
        if (s.removeAttribute('id'), s.nodeName.toLowerCase() === 'svg')
          return this._setSvgAttributes(s, r);
        if (s.nodeName.toLowerCase() === 'symbol')
          return this._setSvgAttributes(this._toSvgElement(s), r);
        let a = this._svgElementFromString(cc('<svg></svg>'));
        return a.appendChild(s), this._setSvgAttributes(a, r)
      }
      _svgElementFromString(e) {
        let i = this._document.createElement('DIV');
        i.innerHTML = e;
        let r = i.querySelector('svg');
        if (!r) throw Error('<svg> tag not found');
        return r
      }
      _toSvgElement(e) {
        let i = this._svgElementFromString(cc('<svg></svg>')), r = e.attributes;
        for (let o = 0; o < r.length; o++) {
          let {name: s, value: a} = r[o];
          s !== 'id' && i.setAttribute(s, a)
        }
        for (let o = 0; o < e.childNodes.length; o++)
          e.childNodes[o].nodeType === this._document.ELEMENT_NODE &&
              i.appendChild(e.childNodes[o].cloneNode(!0));
        return i
      }
      _setSvgAttributes(e, i) {
        return e.setAttribute('fit', ''), e.setAttribute('height', '100%'),
               e.setAttribute('width', '100%'),
               e.setAttribute('preserveAspectRatio', 'xMidYMid meet'),
               e.setAttribute('focusable', 'false'),
               i && i.viewBox && e.setAttribute('viewBox', i.viewBox), e
      }
      _fetchIcon(e) {
        let {url: i, options: r} = e, o = r?.withCredentials ?? !1;
        if (!this._httpClient) throw Cz();
        if (i == null) throw Error(`Cannot fetch icon from URL "${i}".`);
        let s = this._sanitizer.sanitize(Et.RESOURCE_URL, i);
        if (!s) throw FS(i);
        let a = this._inProgressUrlFetches.get(s);
        if (a) return a;
        let l =
            this._httpClient.get(s, {responseType: 'text', withCredentials: o})
                .pipe(
                    Q(c => cc(c)),
                    Jn(() => this._inProgressUrlFetches.delete(s)), Va());
        return this._inProgressUrlFetches.set(s, l), l
      }
      _addSvgIconConfig(e, i, r) {
        return this._svgIconConfigs.set(VS(e, i), r), this
      }
      _addSvgIconSetConfig(e, i) {
        let r = this._iconSetConfigs.get(e);
        return r ? r.push(i) : this._iconSetConfigs.set(e, [i]), this
      }
      _svgElementFromConfig(e) {
        if (!e.svgElement) {
          let i = this._svgElementFromString(e.svgText);
          this._setSvgAttributes(i, e.options), e.svgElement = i
        }
        return e.svgElement
      }
      _getIconConfigFromResolvers(e, i) {
        for (let r = 0; r < this._resolvers.length; r++) {
          let o = this._resolvers[r](i, e);
          if (o) return Ez(o) ? new ir(o.url, null, o.options) : new ir(o, null)
        }
      }
      static \u0275fac = function(i) {
        return new (i || n)(A(zt, 8), A(bl), A(ce, 8), A(ln))
      };
      static \u0275prov =
          C({token: n, factory: n.\u0275fac, providedIn: 'root'})
    } return n
  })();
function gh(n) {
  return n.cloneNode(!0)
}
function VS(n, t) {
  return n + ':' + t
}
function Ez(n) {
  return !!(n.url && n.options)
}
var kz = new w('MAT_ICON_DEFAULT_OPTIONS'),
    Sz = new w('mat-icon-location', {providedIn: 'root', factory: Iz});
function Iz() {
  let n = u(ce), t = n ? n.location : null;
  return {
    getPathname: () => t ? t.pathname + t.search : ''
  }
}
var jS =
        [
          'clip-path', 'color-profile', 'src', 'cursor', 'fill', 'filter',
          'marker', 'marker-start', 'marker-mid', 'marker-end', 'mask', 'stroke'
        ],
    Mz = jS.map(n => `[${n}]`).join(', '), Tz = /^url\(['"]?#(.*?)['"]?\)$/,
    va = (() => {
      class n {
        _elementRef = u(L);
        _iconRegistry = u(Dz);
        _location = u(Sz);
        _errorHandler = u(ln);
        _defaultColor;
        get color() {
          return this._color || this._defaultColor
        }
        set color(e) {
          this._color = e
        }
        _color;
        inline = !1;
        get svgIcon() {
          return this._svgIcon
        }
        set svgIcon(e) {
          e !== this._svgIcon &&
              (e ? this._updateSvgIcon(e) :
                   this._svgIcon && this._clearSvgElement(),
               this._svgIcon = e)
        }
        _svgIcon;
        get fontSet() {
          return this._fontSet
        }
        set fontSet(e) {
          let i = this._cleanupFontValue(e);
          i !== this._fontSet &&
              (this._fontSet = i, this._updateFontIconClasses())
        }
        _fontSet;
        get fontIcon() {
          return this._fontIcon
        }
        set fontIcon(e) {
          let i = this._cleanupFontValue(e);
          i !== this._fontIcon &&
              (this._fontIcon = i, this._updateFontIconClasses())
        }
        _fontIcon;
        _previousFontSetClass = [];
        _previousFontIconClass;
        _svgName;
        _svgNamespace;
        _previousPath;
        _elementsWithExternalReferences;
        _currentIconFetch = ge.EMPTY;
        constructor() {
          let e = u(new Qt('aria-hidden'), {optional: !0}),
              i = u(kz, {optional: !0});
          i &&
              (i.color && (this.color = this._defaultColor = i.color),
               i.fontSet && (this.fontSet = i.fontSet)),
              e ||
              this._elementRef.nativeElement.setAttribute('aria-hidden', 'true')
        }
        _splitIconName(e) {
          if (!e) return ['', ''];
          let i = e.split(':');
          switch (i.length) {
            case 1:
              return ['', i[0]];
            case 2:
              return i;
            default:
              throw Error(`Invalid icon name: "${e}"`)
          }
        }
        ngOnInit() {
          this._updateFontIconClasses()
        }
        ngAfterViewChecked() {
          let e = this._elementsWithExternalReferences;
          if (e && e.size) {
            let i = this._location.getPathname();
            i !== this._previousPath &&
                (this._previousPath = i, this._prependPathToReferences(i))
          }
        }
        ngOnDestroy() {
          this._currentIconFetch.unsubscribe(),
              this._elementsWithExternalReferences &&
              this._elementsWithExternalReferences.clear()
        }
        _usingFontIcon() {
          return !this.svgIcon
        }
        _setSvgElement(e) {
          this._clearSvgElement();
          let i = this._location.getPathname();
          this._previousPath = i, this._cacheChildrenWithExternalReferences(e),
          this._prependPathToReferences(i),
          this._elementRef.nativeElement.appendChild(e)
        }
        _clearSvgElement() {
          let e = this._elementRef.nativeElement, i = e.childNodes.length;
          for (this._elementsWithExternalReferences &&
                   this._elementsWithExternalReferences.clear();
               i--;) {
            let r = e.childNodes[i];
            (r.nodeType !== 1 || r.nodeName.toLowerCase() === 'svg') &&
                r.remove()
          }
        }
        _updateFontIconClasses() {
          if (!this._usingFontIcon()) return;
          let e = this._elementRef.nativeElement,
              i = (this.fontSet ?
                       this._iconRegistry.classNameForFontAlias(this.fontSet)
                           .split(/ +/) :
                       this._iconRegistry.getDefaultFontSetClass())
                      .filter(r => r.length > 0);
          this._previousFontSetClass.forEach(r => e.classList.remove(r)),
              i.forEach(r => e.classList.add(r)),
              this._previousFontSetClass = i,
              this.fontIcon !== this._previousFontIconClass &&
              !i.includes('mat-ligature-font') &&
              (this._previousFontIconClass &&
                   e.classList.remove(this._previousFontIconClass),
               this.fontIcon && e.classList.add(this.fontIcon),
               this._previousFontIconClass = this.fontIcon)
        }
        _cleanupFontValue(e) {
          return typeof e == 'string' ? e.trim().split(' ')[0] : e
        }
        _prependPathToReferences(e) {
          let i = this._elementsWithExternalReferences;
          i &&
              i.forEach(
                  (r, o) => {r.forEach(
                      s => {o.setAttribute(s.name, `url('${e}#${s.value}')`)})})
        }
        _cacheChildrenWithExternalReferences(e) {
          let i = e.querySelectorAll(Mz),
              r = this._elementsWithExternalReferences =
                  this._elementsWithExternalReferences || new Map;
          for (let o = 0; o < i.length; o++)
            jS.forEach(s => {
              let a = i[o], l = a.getAttribute(s), c = l ? l.match(Tz) : null;
              if (c) {
                let d = r.get(a);
                d || (d = [], r.set(a, d)), d.push({name: s, value: c[1]})
              }
            })
        }
        _updateSvgIcon(e) {
          if (this._svgNamespace = null, this._svgName = null,
              this._currentIconFetch.unsubscribe(), e) {
            let [i, r] = this._splitIconName(e);
            i && (this._svgNamespace = i), r && (this._svgName = r),
                this._currentIconFetch =
                    this._iconRegistry.getNamedSvgIcon(r, i)
                        .pipe(Ye(1))
                        .subscribe(o => this._setSvgElement(o), o => {
                          let s =
                              `Error retrieving icon ${i}:${r}! ${o.message}`;
                          this._errorHandler.handleError(new Error(s))
                        })
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-icon']],
          hostAttrs: ['role', 'img', 1, 'mat-icon', 'notranslate'],
          hostVars: 10,
          hostBindings: function(i, r) {
            i&2 &&
                (J('data-mat-icon-type', r._usingFontIcon() ? 'font' : 'svg')(
                     'data-mat-icon-name', r._svgName || r.fontIcon)(
                     'data-mat-icon-namespace', r._svgNamespace || r.fontSet)(
                     'fontIcon', r._usingFontIcon() ? r.fontIcon : null),
                 kt(r.color ? 'mat-' + r.color : ''),
                 Y('mat-icon-inline', r.inline)(
                     'mat-icon-no-color',
                     r.color !== 'primary' && r.color !== 'accent' &&
                         r.color !== 'warn'))
          },
          inputs: {
            color: 'color',
            inline: [2, 'inline', 'inline', q],
            svgIcon: 'svgIcon',
            fontSet: 'fontSet',
            fontIcon: 'fontIcon'
          },
          exportAs: ['matIcon'],
          ngContentSelectors: wz,
          decls: 1,
          vars: 0,
          template: function(i, r) {
            i&1 && (Se(), Z(0))
          },
          styles: [
            'mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })(),
    BS = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({imports: [pe, pe]})
      } return n
    })();
var Rz = n => ['segment', n],
    Az = (n, t) => ({'segment-main': !0, expandable: n, expanded: t});
function Oz(n, t) {
  n&1 && B(0, 'div', 9)
}
function Nz(n, t) {
  if (n & 1 && (f(0, 'span', 10), E(1), g()), n & 2) {
    let e = D().$implicit;
    b(), Re(e.description)
  }
}
function Pz(n, t) {
  if (n & 1 && (f(0, 'section', 11), B(1, 'ngx-json-viewer', 12), g()), n & 2) {
    let e = D().$implicit, i = D();
    b(),
        x('json', e.value)('expanded', i.expanded)('depth', i.depth)(
            '_currentDepth', i._currentDepth + 1)
  }
}
function Fz(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'section', 2)(1, 'section', 3),
        M('click',
          function() {
            let r = N(e).$implicit, o = D();
            return P(o.toggle(r))
          }),
        R(2, Oz, 1, 0, 'div', 4), f(3, 'span', 5), E(4), g(), f(5, 'span', 6),
        E(6, ': '), g(), R(7, Nz, 2, 1, 'span', 7), g(),
        R(8, Pz, 2, 4, 'section', 8), g()
  }
  if (n & 2) {
    let e = t.$implicit, i = D();
    x('ngClass', ko(6, Rz, 'segment-type-' + e.type)), b(),
        x('ngClass', Rs(8, Az, i.isExpandable(e), e.expanded)), b(),
        x('ngIf', i.isExpandable(e)), b(2), Re(e.key), b(3),
        x('ngIf', !e.expanded || !i.isExpandable(e)), b(),
        x('ngIf', e.expanded && i.isExpandable(e))
  }
}
var _h = (() => {
  class n {
    constructor() {
      this.expanded = !0, this.depth = -1, this._currentDepth = 0,
      this.segments = []
    }
    ngOnChanges() {
      this.segments = [], this.json = this.decycle(this.json),
      typeof this.json == 'object' ?
          Object.keys(this.json).forEach(
              e => {this.segments.push(this.parseKeyValue(e, this.json[e]))}) :
          this.segments.push(
              this.parseKeyValue(`(${typeof this.json})`, this.json))
    }
    isExpandable(e) {
      return e.type === 'object' || e.type === 'array'
    }
    toggle(e) {
      this.isExpandable(e) && (e.expanded = !e.expanded)
    }
    parseKeyValue(e, i) {
      let r = {
        key: e,
        value: i,
        type: void 0,
        description: '' + i,
        expanded: this.isExpanded()
      };
      switch (typeof r.value) {
        case 'number': {
          r.type = 'number';
          break
        }
        case 'boolean': {
          r.type = 'boolean';
          break
        }
        case 'function': {
          r.type = 'function';
          break
        }
        case 'string': {
          r.type = 'string', r.description = '"' + r.value + '"';
          break
        }
        case 'undefined': {
          r.type = 'undefined', r.description = 'undefined';
          break
        }
        case 'object': {
          r.value === null ?
              (r.type = 'null', r.description = 'null') :
              Array.isArray(r.value) ?
              (r.type = 'array',
               r.description =
                   'Array[' + r.value.length + '] ' + JSON.stringify(r.value)) :
              r.value instanceof Date ?
              r.type = 'date' :
              (r.type = 'object',
               r.description = 'Object ' + JSON.stringify(r.value));
          break
        }
      }
      return r
    }
    isExpanded() {
      return this.expanded &&
          !(this.depth > -1 && this._currentDepth >= this.depth)
    }
    decycle(e) {
      let i = new WeakMap;
      return function r(o, s) {
        let a, l;
        return typeof o == 'object' && o !== null && !(o instanceof Boolean) &&
                !(o instanceof Date) && !(o instanceof Number) &&
                !(o instanceof RegExp) && !(o instanceof String) ?
            (a = i.get(o),
             a !== void 0 ?
                 {$ref: a} :
                 (i.set(o, s),
                  Array.isArray(o) ?
                      (l = [], o.forEach(function(c, d) {
                        l[d] = r(c, s + '[' + d + ']')
                      })) :
                      (l = {}, Object.keys(o).forEach(function(c) {
                        l[c] = r(o[c], s + '[' + JSON.stringify(c) + ']')
                      })),
                  l)) :
            o
      }(e, '$')
    }
  } return n.\u0275fac =
      function(e) {
        return new (e || n)
      },
  n.\u0275cmp =
      O(
          {
            type: n,
            selectors: [['ngx-json-viewer']],
            inputs: {
              json: 'json',
              expanded: 'expanded',
              depth: 'depth',
              _currentDepth: '_currentDepth'
            },
            standalone: !1,
            features: [Pe],
            decls: 2,
            vars: 1,
            consts: [
              [1, 'ngx-json-viewer'], [3, 'ngClass', 4, 'ngFor', 'ngForOf'],
              [3, 'ngClass'], [3, 'click', 'ngClass'],
              ['class', 'toggler', 4, 'ngIf'], [1, 'segment-key'],
              [1, 'segment-separator'], ['class', 'segment-value', 4, 'ngIf'],
              ['class', 'children', 4, 'ngIf'], [1, 'toggler'],
              [1, 'segment-value'], [1, 'children'],
              [3, 'json', 'expanded', 'depth', '_currentDepth']
            ],
            template: function(e, i) {
              e&1 && (f(0, 'section', 0), R(1, Fz, 9, 11, 'section', 1), g()),
                  e&2 && (b(), x('ngForOf', i.segments))
            },
            dependencies: [vn, yn, fi, n],
            styles: [
              '@charset "UTF-8";.ngx-json-viewer[_ngcontent-%COMP%]{font-family:var(--ngx-json-font-family, monospace);font-size:var(--ngx-json-font-size, 1em);width:100%;height:100%;overflow:hidden;position:relative}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]{padding:2px;margin:1px 1px 1px 12px}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]{word-wrap:break-word}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]   .toggler[_ngcontent-%COMP%]{position:absolute;margin-left:-14px;margin-top:3px;font-size:.8em;line-height:1.2em;vertical-align:middle;color:var(--ngx-json-toggler, #787878)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]   .toggler[_ngcontent-%COMP%]:after{display:inline-block;content:"\\25ba";transition:transform .1s ease-in}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]   .segment-key[_ngcontent-%COMP%]{color:var(--ngx-json-key, #4E187C)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]   .segment-separator[_ngcontent-%COMP%]{color:var(--ngx-json-separator, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .segment-main[_ngcontent-%COMP%]   .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-value, #000)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment[_ngcontent-%COMP%]   .children[_ngcontent-%COMP%]{margin-left:12px}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-string[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-string, #FF6B6B)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-number[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-number, #009688)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-boolean[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-boolean, #B938A4)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-date[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-date, #05668D)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-array[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-array, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-object[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-object, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-function[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-function, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-null[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-null, #fff)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-undefined[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{color:var(--ngx-json-undefined, #fff)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-null[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{background-color:var(--ngx-json-null-bg, red)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-undefined[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-key[_ngcontent-%COMP%]{color:var(--ngx-json-undefined-key, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-undefined[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%] > .segment-value[_ngcontent-%COMP%]{background-color:var(--ngx-json-undefined-key, #999)}.ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-object[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%], .ngx-json-viewer[_ngcontent-%COMP%]   .segment-type-array[_ngcontent-%COMP%] > .segment-main[_ngcontent-%COMP%]{white-space:nowrap}.ngx-json-viewer[_ngcontent-%COMP%]   .expanded[_ngcontent-%COMP%] > .toggler[_ngcontent-%COMP%]:after{transform:rotate(90deg)}.ngx-json-viewer[_ngcontent-%COMP%]   .expandable[_ngcontent-%COMP%], .ngx-json-viewer[_ngcontent-%COMP%]   .expandable[_ngcontent-%COMP%] > .toggler[_ngcontent-%COMP%]{cursor:pointer}'
            ]
          }),
  n
})(),
    zS = (() => {
      class n {} return n.\u0275fac =
          function(e) {
            return new (e || n)
          },
      n.\u0275mod = j({type: n}),
      n.\u0275inj = V({imports: [Er]}),
      n
    })();
var US = ['*'], Lz = ['content'],
    Vz = [[['mat-drawer']], [['mat-drawer-content']], '*'],
    jz = ['mat-drawer', 'mat-drawer-content', '*'];
function Bz(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 1), M('click', function() {
      N(e);
      let r = D();
      return P(r._onBackdropClicked())
    }), g()
  }
  if (n & 2) {
    let e = D();
    Y('mat-drawer-shown', e._isShowingBackdrop())
  }
}
function zz(n, t) {
  n&1 && (f(0, 'mat-drawer-content'), Z(1, 2), g())
}
var Hz =
        new w('MAT_DRAWER_DEFAULT_AUTOSIZE', {providedIn: 'root', factory: Uz}),
    $S = new w('MAT_DRAWER_CONTAINER');
function Uz() {
  return !1
}
var ev = (() => {
  class n extends Ki {
    _platform = u(Ie);
    _changeDetectorRef = u(Ae);
    _container = u(nv);
    constructor() {
      let e = u(L), i = u(Vr), r = u(U);
      super(e, i, r)
    }
    ngAfterContentInit() {
      this._container._contentMarginChanges.subscribe(
          () => {this._changeDetectorRef.markForCheck()})
    }
    _shouldBeHidden() {
      if (this._platform.isBrowser) return !1;
      let {start: e, end: i} = this._container;
      return e != null && e.mode !== 'over' && e.opened ||
          i != null && i.mode !== 'over' && i.opened
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['mat-drawer-content']],
      hostAttrs: [1, 'mat-drawer-content'],
      hostVars: 6,
      hostBindings: function(i, r) {
        i&2 &&
            (Pt('margin-left', r._container._contentMargins.left, 'px')(
                 'margin-right', r._container._contentMargins.right, 'px'),
             Y('mat-drawer-content-hidden', r._shouldBeHidden()))
      },
      features: [ye([{provide: Ki, useExisting: n}]), te],
      ngContentSelectors: US,
      decls: 1,
      vars: 0,
      template: function(i, r) {
        i&1 && (Se(), Z(0))
      },
      encapsulation: 2,
      changeDetection: 0
    })
  } return n
})(),
    tv = (() => {
      class n {
        _elementRef = u(L);
        _focusTrapFactory = u($m);
        _focusMonitor = u(xn);
        _platform = u(Ie);
        _ngZone = u(U);
        _renderer = u(rt);
        _interactivityChecker = u(Ql);
        _doc = u(ce, {optional: !0});
        _container = u($S, {optional: !0});
        _focusTrap = null;
        _elementFocusedBeforeDrawerWasOpened = null;
        _eventCleanups;
        _isAttached;
        _anchor;
        get position() {
          return this._position
        }
        set position(e) {
          e = e === 'end' ? 'end' : 'start',
          e !== this._position &&
              (this._isAttached && this._updatePositionInParent(e),
               this._position = e, this.onPositionChanged.emit())
        }
        _position = 'start';
        get mode() {
          return this._mode
        }
        set mode(e) {
          this._mode = e, this._updateFocusTrapState(), this._modeChanged.next()
        }
        _mode = 'over';
        get disableClose() {
          return this._disableClose
        }
        set disableClose(e) {
          this._disableClose = Je(e)
        }
        _disableClose = !1;
        get autoFocus() {
          let e = this._autoFocus;
          return e ?? (this.mode === 'side' ? 'dialog' : 'first-tabbable')
        }
        set autoFocus(e) {
          (e === 'true' || e === 'false' || e == null) && (e = Je(e)),
              this._autoFocus = e
        }
        _autoFocus;
        get opened() {
          return this._opened
        }
        set opened(e) {
          this.toggle(Je(e))
        }
        _opened = !1;
        _openedVia;
        _animationStarted = new I;
        _animationEnd = new I;
        openedChange = new H(!0);
        _openedStream = this.openedChange.pipe(me(e => e), Q(() => {}));
        openedStart =
            this._animationStarted.pipe(me(() => this.opened), as (void 0));
        _closedStream = this.openedChange.pipe(me(e => !e), Q(() => {}));
        closedStart =
            this._animationStarted.pipe(me(() => !this.opened), as (void 0));
        _destroyed = new I;
        onPositionChanged = new H;
        _content;
        _modeChanged = new I;
        _injector = u(he);
        _changeDetectorRef = u(Ae);
        constructor() {
          this.openedChange.pipe(re(this._destroyed))
              .subscribe(
                  e => {
                      e ? (this._doc &&
                               (this._elementFocusedBeforeDrawerWasOpened =
                                    this._doc.activeElement),
                           this._takeFocus()) :
                          this._isFocusWithinDrawer() &&
                              this._restoreFocus(
                                  this._openedVia || 'program')}),
              this._ngZone.runOutsideAngular(() => {
                let e = this._elementRef.nativeElement;
                La(e, 'keydown')
                    .pipe(
                        me(i => i.keyCode === 27 && !this.disableClose &&
                               !wt(i)),
                        re(this._destroyed))
                    .subscribe(i => this._ngZone.run(() => {
                      this.close(),
                      i.stopPropagation(),
                      i.preventDefault()
                    })),
                    this._eventCleanups = [
                      this._renderer.listen(
                          e, 'transitionrun', this._handleTransitionEvent),
                      this._renderer.listen(
                          e, 'transitionend', this._handleTransitionEvent),
                      this._renderer.listen(
                          e, 'transitioncancel', this._handleTransitionEvent)
                    ]
              }),
              this._animationEnd.subscribe(
                  () => {this.openedChange.emit(this._opened)})
        }
        _forceFocus(e, i) {
          this._interactivityChecker.isFocusable(e) ||
              (e.tabIndex = -1, this._ngZone.runOutsideAngular(() => {
                let r = () => {o(), s(), e.removeAttribute('tabindex')},
                o = this._renderer.listen(e, 'blur', r),
                s = this._renderer.listen(e, 'mousedown', r)
              })),
              e.focus(i)
        }
        _focusByCssSelector(e, i) {
          let r = this._elementRef.nativeElement.querySelector(e);
          r && this._forceFocus(r, i)
        }
        _takeFocus() {
          if (!this._focusTrap) return;
          let e = this._elementRef.nativeElement;
          switch (this.autoFocus) {
            case !1:
            case 'dialog':
              return;
            case !0:
            case 'first-tabbable':
              ht(
                  () => {
                      !this._focusTrap.focusInitialElement() &&
                      typeof e.focus == 'function' && e.focus()},
                  {injector: this._injector});
              break;
            case 'first-heading':
              this._focusByCssSelector(
                  'h1, h2, h3, h4, h5, h6, [role="heading"]');
              break;
            default:
              this._focusByCssSelector(this.autoFocus);
              break
          }
        }
        _restoreFocus(e) {
          this.autoFocus !== 'dialog' &&
              (this._elementFocusedBeforeDrawerWasOpened ?
                   this._focusMonitor.focusVia(
                       this._elementFocusedBeforeDrawerWasOpened, e) :
                   this._elementRef.nativeElement.blur(),
               this._elementFocusedBeforeDrawerWasOpened = null)
        }
        _isFocusWithinDrawer() {
          let e = this._doc.activeElement;
          return !!e && this._elementRef.nativeElement.contains(e)
        }
        ngAfterViewInit() {
          this._isAttached = !0,
          this._position === 'end' && this._updatePositionInParent('end'),
          this._platform.isBrowser &&
              (this._focusTrap = this._focusTrapFactory.create(
                   this._elementRef.nativeElement),
               this._updateFocusTrapState())
        }
        ngOnDestroy() {
          this._eventCleanups.forEach(e => e()), this._focusTrap?.destroy(),
              this._anchor?.remove(),
              this._anchor = null, this._animationStarted.complete(),
              this._animationEnd.complete(), this._modeChanged.complete(),
              this._destroyed.next(), this._destroyed.complete()
        }
        open(e) {
          return this.toggle(!0, e)
        }
        close() {
          return this.toggle(!1)
        }
        _closeViaBackdropClick() {
          return this._setOpen(!1, !0, 'mouse')
        }
        toggle(e = !this.opened, i) {
          e && i && (this._openedVia = i);
          let r = this._setOpen(
              e, !e && this._isFocusWithinDrawer(),
              this._openedVia || 'program');
          return e || (this._openedVia = null), r
        }
        _setOpen(e, i, r) {
          return e === this._opened ?
              Promise.resolve(e ? 'open' : 'close') :
              (this._opened = e,
               this._container?._transitionsEnabled ?
                   this._setIsAnimating(!0) :
                   setTimeout(() => {
                     this._animationStarted.next(),
                     this._animationEnd.next()
                   }),
               this._elementRef.nativeElement.classList.toggle(
                   'mat-drawer-opened', e),
               !e && i && this._restoreFocus(r),
               this._changeDetectorRef.markForCheck(),
               this._updateFocusTrapState(),
               new Promise(
                   o => {this.openedChange.pipe(Ye(1)).subscribe(
                       s => o(s ? 'open' : 'close'))}))
        }
        _setIsAnimating(e) {
          this._elementRef.nativeElement.classList.toggle(
              'mat-drawer-animating', e)
        }
        _getWidth() {
          return this._elementRef.nativeElement.offsetWidth || 0
        }
        _updateFocusTrapState() {
          this._focusTrap &&
              (this._focusTrap.enabled =
                   !!this._container?.hasBackdrop && this.opened)
        }
        _updatePositionInParent(e) {
          if (!this._platform.isBrowser) return;
          let i = this._elementRef.nativeElement, r = i.parentNode;
          e === 'end' ?
              (this._anchor ||
                   (this._anchor = this._doc.createComment('mat-drawer-anchor'),
                    r.insertBefore(this._anchor, i)),
               r.appendChild(i)) :
              this._anchor &&
                  this._anchor.parentNode.insertBefore(i, this._anchor)
        }
        _handleTransitionEvent = e => {
          let i = this._elementRef.nativeElement;
          e.target === i &&
              this._ngZone.run(
                  () => {
                      e.type === 'transitionrun' ?
                          this._animationStarted.next(e) :
                          (e.type === 'transitionend' &&
                               this._setIsAnimating(!1),
                           this._animationEnd.next(e))})
        };
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-drawer']],
          viewQuery: function(i, r) {
            if (i & 1 && oe(Lz, 5), i & 2) {
              let o;
              $(o = W()) && (r._content = o.first)
            }
          },
          hostAttrs: ['tabIndex', '-1', 1, 'mat-drawer'],
          hostVars: 11,
          hostBindings: function(i, r) {
            i&2 &&
                (J('align', null),
                 Pt('visibility', !r._container && !r.opened ? 'hidden' : null),
                 Y('mat-drawer-end', r.position === 'end')(
                     'mat-drawer-over', r.mode === 'over')(
                     'mat-drawer-push', r.mode === 'push')(
                     'mat-drawer-side', r.mode === 'side'))
          },
          inputs: {
            position: 'position',
            mode: 'mode',
            disableClose: 'disableClose',
            autoFocus: 'autoFocus',
            opened: 'opened'
          },
          outputs: {
            openedChange: 'openedChange',
            _openedStream: 'opened',
            openedStart: 'openedStart',
            _closedStream: 'closed',
            closedStart: 'closedStart',
            onPositionChanged: 'positionChanged'
          },
          exportAs: ['matDrawer'],
          ngContentSelectors: US,
          decls: 3,
          vars: 0,
          consts: [
            ['content', ''],
            ['cdkScrollable', '', 1, 'mat-drawer-inner-container']
          ],
          template: function(i, r) {
            i&1 && (Se(), f(0, 'div', 1, 0), Z(2), g())
          },
          dependencies: [Ki],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })(),
    nv = (() => {
      class n {
        _dir = u(dt, {optional: !0});
        _element = u(L);
        _ngZone = u(U);
        _changeDetectorRef = u(Ae);
        _animationMode = u(Ve, {optional: !0});
        _transitionsEnabled = !1;
        _allDrawers;
        _drawers = new si;
        _content;
        _userContent;
        get start() {
          return this._start
        }
        get end() {
          return this._end
        }
        get autosize() {
          return this._autosize
        }
        set autosize(e) {
          this._autosize = Je(e)
        }
        _autosize = u(Hz);
        get hasBackdrop() {
          return this._drawerHasBackdrop(this._start) ||
              this._drawerHasBackdrop(this._end)
        }
        set hasBackdrop(e) {
          this._backdropOverride = e == null ? null : Je(e)
        }
        _backdropOverride;
        backdropClick = new H;
        _start;
        _end;
        _left;
        _right;
        _destroyed = new I;
        _doCheckSubject = new I;
        _contentMargins = {left: null, right: null};
        _contentMarginChanges = new I;
        get scrollable() {
          return this._userContent || this._content
        }
        _injector = u(he);
        constructor() {
          let e = u(Ie), i = u(Dn);
          this._dir?.change.pipe(re(this._destroyed)).subscribe(() => {
            this._validateDrawers(),
            this.updateContentMargins()
          }),
              i.change()
                  .pipe(re(this._destroyed))
                  .subscribe(() => this.updateContentMargins()),
              this._animationMode !== 'NoopAnimations' && e.isBrowser &&
              this._ngZone.runOutsideAngular(
                  () => {setTimeout(
                      () => {
                        this._element.nativeElement.classList.add(
                            'mat-drawer-transition'),
                        this._transitionsEnabled = !0
                      },
                      200)})
        }
        ngAfterContentInit() {
          this._allDrawers.changes
              .pipe(Xe(this._allDrawers), re(this._destroyed))
              .subscribe(e => {
                this._drawers.reset(
                    e.filter(i => !i._container || i._container === this)),
                this._drawers.notifyOnChanges()
              }),
              this._drawers.changes.pipe(Xe(null)).subscribe(() => {
                this._validateDrawers(),
                this._drawers.forEach(e => {
                  this._watchDrawerToggle(e),
                  this._watchDrawerPosition(e),
                  this._watchDrawerMode(e)
                }),
                (!this._drawers.length || this._isDrawerOpen(this._start) ||
                 this._isDrawerOpen(this._end)) &&
                    this.updateContentMargins(),
                this._changeDetectorRef.markForCheck()
              }),
              this._ngZone.runOutsideAngular(
                  () => {this._doCheckSubject.pipe(Tn(10), re(this._destroyed))
                             .subscribe(() => this.updateContentMargins())})
        }
        ngOnDestroy() {
          this._contentMarginChanges.complete(),
              this._doCheckSubject.complete(), this._drawers.destroy(),
              this._destroyed.next(), this._destroyed.complete()
        }
        open() {
          this._drawers.forEach(e => e.open())
        }
        close() {
          this._drawers.forEach(e => e.close())
        }
        updateContentMargins() {
          let e = 0, i = 0;
          if (this._left && this._left.opened) {
            if (this._left.mode == 'side')
              e += this._left._getWidth();
            else if (this._left.mode == 'push') {
              let r = this._left._getWidth();
              e += r, i -= r
            }
          }
          if (this._right && this._right.opened) {
            if (this._right.mode == 'side')
              i += this._right._getWidth();
            else if (this._right.mode == 'push') {
              let r = this._right._getWidth();
              i += r, e -= r
            }
          }
          e = e || null, i = i || null,
          (e !== this._contentMargins.left ||
           i !== this._contentMargins.right) &&
              (this._contentMargins = {left: e, right: i},
               this._ngZone.run(
                   () => this._contentMarginChanges.next(this._contentMargins)))
        }
        ngDoCheck() {
          this._autosize && this._isPushed() &&
              this._ngZone.runOutsideAngular(() => this._doCheckSubject.next())
        }
        _watchDrawerToggle(e) {
          e._animationStarted.pipe(re(this._drawers.changes)).subscribe(() => {
            this.updateContentMargins(),
            this._changeDetectorRef.markForCheck()
          }),
              e.mode !== 'side' &&
              e.openedChange.pipe(re(this._drawers.changes))
                  .subscribe(() => this._setContainerClass(e.opened))
        }
        _watchDrawerPosition(e) {
          e.onPositionChanged.pipe(re(this._drawers.changes))
              .subscribe(() => {ht({read: () => this._validateDrawers()}, {
                           injector: this._injector
                         })})
        }
        _watchDrawerMode(e) {
          e._modeChanged.pipe(re(Ke(this._drawers.changes, this._destroyed)))
              .subscribe(() => {
                this.updateContentMargins(),
                this._changeDetectorRef.markForCheck()
              })
        }
        _setContainerClass(e) {
          let i = this._element.nativeElement.classList,
              r = 'mat-drawer-container-has-open';
          e ? i.add(r) : i.remove(r)
        }
        _validateDrawers() {
          this._start = this._end = null,
          this._drawers.forEach(
              e => {
                  e.position == 'end' ?
                      (this._end != null, this._end = e) :
                      (this._start != null, this._start = e)}),
          this._right = this._left = null,
          this._dir && this._dir.value === 'rtl' ?
              (this._left = this._end, this._right = this._start) :
              (this._left = this._start, this._right = this._end)
        }
        _isPushed() {
          return this._isDrawerOpen(this._start) &&
              this._start.mode != 'over' ||
              this._isDrawerOpen(this._end) && this._end.mode != 'over'
        }
        _onBackdropClicked() {
          this.backdropClick.emit(), this._closeModalDrawersViaBackdrop()
        }
        _closeModalDrawersViaBackdrop() {
          [this._start, this._end]
              .filter(e => e && !e.disableClose && this._drawerHasBackdrop(e))
              .forEach(e => e._closeViaBackdropClick())
        }
        _isShowingBackdrop() {
          return this._isDrawerOpen(this._start) &&
              this._drawerHasBackdrop(this._start) ||
              this._isDrawerOpen(this._end) &&
              this._drawerHasBackdrop(this._end)
        }
        _isDrawerOpen(e) {
          return e != null && e.opened
        }
        _drawerHasBackdrop(e) {
          return this._backdropOverride == null ? !!e && e.mode !== 'side' :
                                                  this._backdropOverride
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-drawer-container']],
          contentQueries: function(i, r, o) {
            if (i & 1 && (Oe(o, ev, 5), Oe(o, tv, 5)), i & 2) {
              let s;
              $(s = W()) && (r._content = s.first),
                  $(s = W()) && (r._allDrawers = s)
            }
          },
          viewQuery: function(i, r) {
            if (i & 1 && oe(ev, 5), i & 2) {
              let o;
              $(o = W()) && (r._userContent = o.first)
            }
          },
          hostAttrs: [1, 'mat-drawer-container'],
          hostVars: 2,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mat-drawer-container-explicit-backdrop', r._backdropOverride)
          },
          inputs: {autosize: 'autosize', hasBackdrop: 'hasBackdrop'},
          outputs: {backdropClick: 'backdropClick'},
          exportAs: ['matDrawerContainer'],
          features: [ye([{provide: $S, useExisting: n}])],
          ngContentSelectors: jz,
          decls: 4,
          vars: 2,
          consts: [
            [1, 'mat-drawer-backdrop', 3, 'mat-drawer-shown'],
            [1, 'mat-drawer-backdrop', 3, 'click']
          ],
          template: function(i, r) {
            i&1 &&
                (Se(Vz), R(0, Bz, 1, 2, 'div', 0), Z(1), Z(2, 1),
                 R(3, zz, 2, 0, 'mat-drawer-content')),
                i&2 &&
                (de(r.hasBackdrop ? 0 : -1), b(3), de(r._content ? -1 : 3))
          },
          dependencies: [ev],
          styles: [
            '.mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}'
          ],
          encapsulation: 2,
          changeDetection: 0
        })
      } return n
    })();
var WS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe, Zi, Zi, pe]})
  } return n
})();
var sv = ['*'];
function Wz(n, t) {
  n&1 && Z(0)
}
var qz = ['tabListContainer'], Gz = ['tabList'], Qz = ['tabListInner'],
    Yz = ['nextPaginator'], Zz = ['previousPaginator'],
    Kz = n => ({animationDuration: n}), Xz = (n, t) => ({value: n, params: t});
function Jz(n, t) {}
var e3 = ['tabBodyWrapper'], t3 = ['tabHeader'];
function n3(n, t) {}
function i3(n, t) {
  if (n & 1 && R(0, n3, 0, 0, 'ng-template', 12), n & 2) {
    let e = D().$implicit;
    x('cdkPortalOutlet', e.templateLabel)
  }
}
function r3(n, t) {
  if (n & 1 && E(0), n & 2) {
    let e = D().$implicit;
    Re(e.textLabel)
  }
}
function o3(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 7, 2),
        M('click',
          function() {
            let r = N(e), o = r.$implicit, s = r.$index, a = D(), l = yt(1);
            return P(a._handleClick(o, l, s))
          })(
            'cdkFocusChange',
            function(r) {
              let o = N(e).$index, s = D();
              return P(s._tabFocusChanged(r, o))
            }),
        B(2, 'span', 8)(3, 'div', 9), f(4, 'span', 10)(5, 'span', 11),
        R(6, i3, 1, 1, null, 12)(7, r3, 1, 1), g()()()
  }
  if (n & 2) {
    let e = t.$implicit, i = t.$index, r = yt(1), o = D();
    kt(e.labelClass), Y('mdc-tab--active', o.selectedIndex === i),
        x('id', o._getTabLabelId(i))('disabled', e.disabled)(
            'fitInkBarToContent', o.fitInkBarToContent),
        J('tabIndex', o._getTabIndex(i))('aria-posinset', i + 1)(
            'aria-setsize', o._tabs.length)(
            'aria-controls', o._getTabContentId(i))(
            'aria-selected', o.selectedIndex === i)(
            'aria-label', e.ariaLabel || null)(
            'aria-labelledby',
            !e.ariaLabel && e.ariaLabelledby ? e.ariaLabelledby : null),
        b(3),
        x('matRippleTrigger', r)(
            'matRippleDisabled', e.disabled || o.disableRipple),
        b(3), de(e.templateLabel ? 6 : 7)
  }
}
function s3(n, t) {
  n&1 && Z(0)
}
function a3(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'mat-tab-body', 13), M('_onCentered', function() {
      N(e);
      let r = D();
      return P(r._removeTabBodyWrapperHeight())
    })('_onCentering', function(r) {
      N(e);
      let o = D();
      return P(o._setTabBodyWrapperHeight(r))
    }), g()
  }
  if (n & 2) {
    let e = t.$implicit, i = t.$index, r = D();
    kt(e.bodyClass), Y('mat-mdc-tab-body-active', r.selectedIndex === i),
        x('id', r._getTabContentId(i))('content', e.content)(
            'position', e.position)('origin', e.origin)(
            'animationDuration', r.animationDuration)(
            'preserveContent', r.preserveContent),
        J('tabindex',
          r.contentTabIndex != null && r.selectedIndex === i ?
              r.contentTabIndex :
              null)('aria-labelledby', r._getTabLabelId(i))(
            'aria-hidden', r.selectedIndex !== i)
  }
}
var l3 = new w('MatTabContent'),
    c3 = (() => {
      class n {
        template = u(qe);
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matTabContent', '']],
          features: [ye([{provide: l3, useExisting: n}])]
        })
      } return n
    })(),
    d3 = new w('MatTabLabel'), QS = new w('MAT_TAB'),
    u3 = (() => {
      class n extends Lk {
        _closestTab = u(QS, {optional: !0});
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'mat-tab-label', ''], ['', 'matTabLabel', '']],
          features: [ye([{provide: d3, useExisting: n}]), te]
        })
      } return n
    })(),
    YS = new w('MAT_TAB_GROUP'),
    av = (() => {
      class n {
        _viewContainerRef = u(Ge);
        _closestTabGroup = u(YS, {optional: !0});
        disabled = !1;
        get templateLabel() {
          return this._templateLabel
        }
        set templateLabel(e) {
          this._setTemplateLabelInput(e)
        }
        _templateLabel;
        _explicitContent = void 0;
        _implicitContent;
        textLabel = '';
        ariaLabel;
        ariaLabelledby;
        labelClass;
        bodyClass;
        _contentPortal = null;
        get content() {
          return this._contentPortal
        }
        _stateChanges = new I;
        position = null;
        origin = null;
        isActive = !1;
        constructor() {
          u(lt).load($n)
        }
        ngOnChanges(e) {
          (e.hasOwnProperty('textLabel') || e.hasOwnProperty('disabled')) &&
              this._stateChanges.next()
        }
        ngOnDestroy() {
          this._stateChanges.complete()
        }
        ngOnInit() {
          this._contentPortal = new vi(
              this._explicitContent || this._implicitContent,
              this._viewContainerRef)
        }
        _setTemplateLabelInput(e) {
          e && e._closestTab === this && (this._templateLabel = e)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-tab']],
          contentQueries: function(i, r, o) {
            if (i & 1 && (Oe(o, u3, 5), Oe(o, c3, 7, qe)), i & 2) {
              let s;
              $(s = W()) && (r.templateLabel = s.first),
                  $(s = W()) && (r._explicitContent = s.first)
            }
          },
          viewQuery: function(i, r) {
            if (i & 1 && oe(qe, 7), i & 2) {
              let o;
              $(o = W()) && (r._implicitContent = o.first)
            }
          },
          hostAttrs: ['hidden', ''],
          inputs: {
            disabled: [2, 'disabled', 'disabled', q],
            textLabel: [0, 'label', 'textLabel'],
            ariaLabel: [0, 'aria-label', 'ariaLabel'],
            ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby'],
            labelClass: 'labelClass',
            bodyClass: 'bodyClass'
          },
          exportAs: ['matTab'],
          features: [ye([{provide: QS, useExisting: n}]), Pe],
          ngContentSelectors: sv,
          decls: 1,
          vars: 0,
          template: function(i, r) {
            i&1 && (Se(), R(0, Wz, 1, 0, 'ng-template'))
          },
          encapsulation: 2
        })
      } return n
    })(),
    iv = 'mdc-tab-indicator--active', qS = 'mdc-tab-indicator--no-transition',
    rv = class {
  _items;
  _currentItem;
  constructor(t) {
    this._items = t
  }
  hide() {
    this._items.forEach(t => t.deactivateInkBar()), this._currentItem = void 0
  }
  alignToElement(t) {
    let e = this._items.find(r => r.elementRef.nativeElement === t),
        i = this._currentItem;
    if (e !== i && (i?.deactivateInkBar(), e)) {
      let r = i?.elementRef.nativeElement.getBoundingClientRect?.();
      e.activateInkBar(r), this._currentItem = e
    }
  }
}
, m3 = (() => {
    class n {
      _elementRef = u(L);
      _inkBarElement;
      _inkBarContentElement;
      _fitToContent = !1;
      get fitInkBarToContent() {
        return this._fitToContent
      }
      set fitInkBarToContent(e) {
        this._fitToContent !== e &&
            (this._fitToContent = e,
             this._inkBarElement && this._appendInkBarElement())
      }
      activateInkBar(e) {
        let i = this._elementRef.nativeElement;
        if (!e || !i.getBoundingClientRect || !this._inkBarContentElement) {
          i.classList.add(iv);
          return
        }
        let r = i.getBoundingClientRect(), o = e.width / r.width,
            s = e.left - r.left;
        i.classList.add(qS),
            this._inkBarContentElement.style.setProperty(
                'transform', `translateX(${s}px) scaleX(${o})`),
            i.getBoundingClientRect(), i.classList.remove(qS),
            i.classList.add(iv),
            this._inkBarContentElement.style.setProperty('transform', '')
      }
      deactivateInkBar() {
        this._elementRef.nativeElement.classList.remove(iv)
      }
      ngOnInit() {
        this._createInkBarElement()
      }
      ngOnDestroy() {
        this._inkBarElement?.remove(),
            this._inkBarElement = this._inkBarContentElement = null
      }
      _createInkBarElement() {
        let e = this._elementRef.nativeElement.ownerDocument || document,
            i = this._inkBarElement = e.createElement('span'),
            r = this._inkBarContentElement = e.createElement('span');
        i.className = 'mdc-tab-indicator',
        r.className =
            'mdc-tab-indicator__content mdc-tab-indicator__content--underline',
        i.appendChild(this._inkBarContentElement), this._appendInkBarElement()
      }
      _appendInkBarElement() {
        this._inkBarElement;
        let e = this._fitToContent ?
            this._elementRef.nativeElement.querySelector('.mdc-tab__content') :
            this._elementRef.nativeElement;
        e.appendChild(this._inkBarElement)
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275dir = T({
        type: n,
        inputs: {
          fitInkBarToContent: [2, 'fitInkBarToContent', 'fitInkBarToContent', q]
        }
      })
    } return n
  })();
var ZS = (() => {
  class n extends m3 {
    elementRef = u(L);
    disabled = !1;
    focus() {
      this.elementRef.nativeElement.focus()
    }
    getOffsetLeft() {
      return this.elementRef.nativeElement.offsetLeft
    }
    getOffsetWidth() {
      return this.elementRef.nativeElement.offsetWidth
    }
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275dir = T({
      type: n,
      selectors: [['', 'matTabLabelWrapper', '']],
      hostVars: 3,
      hostBindings: function(i, r) {
        i&2 &&
            (J('aria-disabled', !!r.disabled),
             Y('mat-mdc-tab-disabled', r.disabled))
      },
      inputs: {disabled: [2, 'disabled', 'disabled', q]},
      features: [te]
    })
  } return n
})(),
    GS = {passive: !0}, h3 = 650, f3 = 100,
    p3 = (() => {
      class n {
        _elementRef = u(L);
        _changeDetectorRef = u(Ae);
        _viewportRuler = u(Dn);
        _dir = u(dt, {optional: !0});
        _ngZone = u(U);
        _platform = u(Ie);
        _sharedResizeObserver = u(rh);
        _injector = u(he);
        _renderer = u(rt);
        _animationMode = u(Ve, {optional: !0});
        _eventCleanups;
        _scrollDistance = 0;
        _selectedIndexChanged = !1;
        _destroyed = new I;
        _showPaginationControls = !1;
        _disableScrollAfter = !0;
        _disableScrollBefore = !0;
        _tabLabelCount;
        _scrollDistanceChanged;
        _keyManager;
        _currentTextContent;
        _stopScrolling = new I;
        disablePagination = !1;
        get selectedIndex() {
          return this._selectedIndex
        }
        set selectedIndex(e) {
          let i = isNaN(e) ? 0 : e;
          this._selectedIndex != i &&
              (this._selectedIndexChanged = !0, this._selectedIndex = i,
               this._keyManager && this._keyManager.updateActiveItem(i))
        }
        _selectedIndex = 0;
        selectFocusedIndex = new H;
        indexFocused = new H;
        constructor() {
          this._eventCleanups = this._ngZone.runOutsideAngular(
              () => [this._renderer.listen(
                  this._elementRef.nativeElement, 'mouseleave',
                  () => this._stopInterval())])
        }
        ngAfterViewInit() {
          this._eventCleanups.push(
              ab(this._renderer, this._previousPaginator.nativeElement,
                 'touchstart', () => this._handlePaginatorPress('before'), GS),
              ab(this._renderer, this._nextPaginator.nativeElement,
                 'touchstart', () => this._handlePaginatorPress('after'), GS))
        }
        ngAfterContentInit() {
          let e = this._dir ? this._dir.change : G('ltr'),
              i = this._sharedResizeObserver
                      .observe(this._elementRef.nativeElement)
                      .pipe(Tn(32), re(this._destroyed)),
              r = this._viewportRuler.change(150).pipe(re(this._destroyed)),
              o = () => {
                this.updatePagination(), this._alignInkBarToSelectedTab()
              };
          this._keyManager =
              new Bm(this._items)
                  .withHorizontalOrientation(this._getLayoutDirection())
                  .withHomeAndEnd()
                  .withWrap()
                  .skipPredicate(() => !1),
          this._keyManager.updateActiveItem(this._selectedIndex),
          ht(o, {injector: this._injector}),
          Ke(e, r, i, this._items.changes, this._itemsResized())
              .pipe(re(this._destroyed))
              .subscribe(() => {
                this._ngZone.run(() => {Promise.resolve().then(() => {
                                   this._scrollDistance = Math.max(
                                       0,
                                       Math.min(
                                           this._getMaxScrollDistance(),
                                           this._scrollDistance)),
                                   o()
                                 })}),
                this._keyManager.withHorizontalOrientation(
                    this._getLayoutDirection())
              }),
          this._keyManager.change.subscribe(
              s => {this.indexFocused.emit(s), this._setTabFocus(s)})
        }
        _itemsResized() {
          return typeof ResizeObserver != 'function' ?
              mt :
              this._items.changes.pipe(
                  Xe(this._items),
                  $e(e => new ie(i => this._ngZone.runOutsideAngular(() => {
                       let r = new ResizeObserver(o => i.next(o));
                       return e.forEach(
                                  o => r.observe(o.elementRef.nativeElement)),
                              () => {
                                r.disconnect()
                              }
                     }))),
                  ro(1),
                  me(e => e.some(
                         i => i.contentRect.width > 0 &&
                             i.contentRect.height > 0)))
        }
        ngAfterContentChecked() {
          this._tabLabelCount != this._items.length &&
              (this.updatePagination(),
               this._tabLabelCount = this._items.length,
               this._changeDetectorRef.markForCheck()),
              this._selectedIndexChanged &&
              (this._scrollToLabel(this._selectedIndex),
               this._checkScrollingControls(), this._alignInkBarToSelectedTab(),
               this._selectedIndexChanged = !1,
               this._changeDetectorRef.markForCheck()),
              this._scrollDistanceChanged &&
              (this._updateTabScrollPosition(),
               this._scrollDistanceChanged = !1,
               this._changeDetectorRef.markForCheck())
        }
        ngOnDestroy() {
          this._eventCleanups.forEach(e => e()), this._keyManager?.destroy(),
              this._destroyed.next(), this._destroyed.complete(),
              this._stopScrolling.complete()
        }
        _handleKeydown(e) {
          if (!wt(e)) switch (e.keyCode) {
              case 13:
              case 32:
                if (this.focusIndex !== this.selectedIndex) {
                  let i = this._items.get(this.focusIndex);
                  i && !i.disabled &&
                      (this.selectFocusedIndex.emit(this.focusIndex),
                       this._itemSelected(e))
                }
                break;
              default:
                this._keyManager.onKeydown(e)
            }
        }
        _onContentChanges() {
          let e = this._elementRef.nativeElement.textContent;
          e !== this._currentTextContent &&
              (this._currentTextContent = e || '', this._ngZone.run(() => {
                this.updatePagination(),
                this._alignInkBarToSelectedTab(),
                this._changeDetectorRef.markForCheck()
              }))
        }
        updatePagination() {
          this._checkPaginationEnabled(), this._checkScrollingControls(),
              this._updateTabScrollPosition()
        }
        get focusIndex() {
          return this._keyManager ? this._keyManager.activeItemIndex : 0
        }
        set focusIndex(e) {
          !this._isValidIndex(e) || this.focusIndex === e ||
              !this._keyManager || this._keyManager.setActiveItem(e)
        }
        _isValidIndex(e) {
          return this._items ? !!this._items.toArray()[e] : !0
        }
        _setTabFocus(e) {
          if (this._showPaginationControls && this._scrollToLabel(e),
              this._items && this._items.length) {
            this._items.toArray()[e].focus();
            let i = this._tabListContainer.nativeElement;
            this._getLayoutDirection() == 'ltr' ?
                i.scrollLeft = 0 :
                i.scrollLeft = i.scrollWidth - i.offsetWidth
          }
        }
        _getLayoutDirection() {
          return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr'
        }
        _updateTabScrollPosition() {
          if (this.disablePagination) return;
          let e = this.scrollDistance,
              i = this._getLayoutDirection() === 'ltr' ? -e : e;
          this._tabList.nativeElement.style.transform =
              `translateX(${Math.round(i)}px)`,
          (this._platform.TRIDENT || this._platform.EDGE) &&
              (this._tabListContainer.nativeElement.scrollLeft = 0)
        }
        get scrollDistance() {
          return this._scrollDistance
        }
        set scrollDistance(e) {
          this._scrollTo(e)
        }
        _scrollHeader(e) {
          let i = this._tabListContainer.nativeElement.offsetWidth,
              r = (e == 'before' ? -1 : 1) * i / 3;
          return this._scrollTo(this._scrollDistance + r)
        }
        _handlePaginatorClick(e) {
          this._stopInterval(), this._scrollHeader(e)
        }
        _scrollToLabel(e) {
          if (this.disablePagination) return;
          let i = this._items ? this._items.toArray()[e] : null;
          if (!i) return;
          let r = this._tabListContainer.nativeElement.offsetWidth,
              {offsetLeft: o, offsetWidth: s} = i.elementRef.nativeElement, a,
              l;
          this._getLayoutDirection() == 'ltr' ?
              (a = o, l = a + s) :
              (l = this._tabListInner.nativeElement.offsetWidth - o, a = l - s);
          let c = this.scrollDistance, d = this.scrollDistance + r;
          a<c ? this.scrollDistance -= c - a : l>d &&
              (this.scrollDistance += Math.min(l - d, a - c))
        }
        _checkPaginationEnabled() {
          if (this.disablePagination)
            this._showPaginationControls = !1;
          else {
            let e = this._tabListInner.nativeElement.scrollWidth,
                i = this._elementRef.nativeElement.offsetWidth, r = e - i >= 5;
            r || (this.scrollDistance = 0),
                r !== this._showPaginationControls &&
                (this._showPaginationControls = r,
                 this._changeDetectorRef.markForCheck())
          }
        }
        _checkScrollingControls() {
          this.disablePagination ?
              this._disableScrollAfter = this._disableScrollBefore = !0 :
              (this._disableScrollBefore = this.scrollDistance == 0,
               this._disableScrollAfter =
                   this.scrollDistance == this._getMaxScrollDistance(),
               this._changeDetectorRef.markForCheck())
        }
        _getMaxScrollDistance() {
          let e = this._tabListInner.nativeElement.scrollWidth,
              i = this._tabListContainer.nativeElement.offsetWidth;
          return e - i || 0
        }
        _alignInkBarToSelectedTab() {
          let e = this._items && this._items.length ?
              this._items.toArray()[this.selectedIndex] :
              null,
              i = e ? e.elementRef.nativeElement : null;
          i ? this._inkBar.alignToElement(i) : this._inkBar.hide()
        }
        _stopInterval() {
          this._stopScrolling.next()
        }
        _handlePaginatorPress(e, i) {
          i && i.button != null && i.button !== 0 ||
              (this._stopInterval(),
               io(h3, f3)
                   .pipe(re(Ke(this._stopScrolling, this._destroyed)))
                   .subscribe(() => {
                     let {maxScrollDistance: r, distance: o} =
                         this._scrollHeader(e);
                     (o === 0 || o >= r) && this._stopInterval()
                   }))
        }
        _scrollTo(e) {
          if (this.disablePagination)
            return {maxScrollDistance: 0, distance: 0};
          let i = this._getMaxScrollDistance();
          return this._scrollDistance = Math.max(0, Math.min(i, e)),
                 this._scrollDistanceChanged = !0,
                 this._checkScrollingControls(), {
            maxScrollDistance: i, distance: this._scrollDistance
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          inputs: {
            disablePagination: [2, 'disablePagination', 'disablePagination', q],
            selectedIndex: [2, 'selectedIndex', 'selectedIndex', st]
          },
          outputs: {
            selectFocusedIndex: 'selectFocusedIndex',
            indexFocused: 'indexFocused'
          }
        })
      } return n
    })(),
    g3 = (() => {
      class n extends p3 {
        _items;
        _tabListContainer;
        _tabList;
        _tabListInner;
        _nextPaginator;
        _previousPaginator;
        _inkBar;
        ariaLabel;
        ariaLabelledby;
        disableRipple = !1;
        ngAfterContentInit() {
          this._inkBar = new rv(this._items), super.ngAfterContentInit()
        }
        _itemSelected(e) {
          e.preventDefault()
        }
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-tab-header']],
          contentQueries: function(i, r, o) {
            if (i & 1 && Oe(o, ZS, 4), i & 2) {
              let s;
              $(s = W()) && (r._items = s)
            }
          },
          viewQuery: function(i, r) {
            if (i & 1 &&
                    (oe(qz, 7), oe(Gz, 7), oe(Qz, 7), oe(Yz, 5), oe(Zz, 5)),
                i & 2) {
              let o;
              $(o = W()) && (r._tabListContainer = o.first),
                  $(o = W()) && (r._tabList = o.first),
                  $(o = W()) && (r._tabListInner = o.first),
                  $(o = W()) && (r._nextPaginator = o.first),
                  $(o = W()) && (r._previousPaginator = o.first)
            }
          },
          hostAttrs: [1, 'mat-mdc-tab-header'],
          hostVars: 4,
          hostBindings: function(i, r) {
            i&2 &&
                Y('mat-mdc-tab-header-pagination-controls-enabled',
                  r._showPaginationControls)(
                    'mat-mdc-tab-header-rtl', r._getLayoutDirection() == 'rtl')
          },
          inputs: {
            ariaLabel: [0, 'aria-label', 'ariaLabel'],
            ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby'],
            disableRipple: [2, 'disableRipple', 'disableRipple', q]
          },
          features: [te],
          ngContentSelectors: sv,
          decls: 13,
          vars: 10,
          consts: [
            ['previousPaginator', ''], ['tabListContainer', ''],
            ['tabList', ''], ['tabListInner', ''], ['nextPaginator', ''],
            [
              'mat-ripple', '', 1, 'mat-mdc-tab-header-pagination',
              'mat-mdc-tab-header-pagination-before', 3, 'click', 'mousedown',
              'touchend', 'matRippleDisabled'
            ],
            [1, 'mat-mdc-tab-header-pagination-chevron'],
            [1, 'mat-mdc-tab-label-container', 3, 'keydown'],
            ['role', 'tablist', 1, 'mat-mdc-tab-list', 3, 'cdkObserveContent'],
            [1, 'mat-mdc-tab-labels'],
            [
              'mat-ripple', '', 1, 'mat-mdc-tab-header-pagination',
              'mat-mdc-tab-header-pagination-after', 3, 'mousedown', 'click',
              'touchend', 'matRippleDisabled'
            ]
          ],
          template: function(i, r) {
            if (i & 1) {
              let o = ee();
              Se(), f(0, 'div', 5, 0),
                  M('click',
                    function() {
                      return N(o), P(r._handlePaginatorClick('before'))
                    })(
                      'mousedown',
                      function(a) {
                        return N(o), P(r._handlePaginatorPress('before', a))
                      })(
                      'touchend',
                      function() {
                        return N(o), P(r._stopInterval())
                      }),
                  B(2, 'div', 6), g(), f(3, 'div', 7, 1),
                  M('keydown',
                    function(a) {
                      return N(o), P(r._handleKeydown(a))
                    }),
                  f(5, 'div', 8, 2),
                  M('cdkObserveContent',
                    function() {
                      return N(o), P(r._onContentChanges())
                    }),
                  f(7, 'div', 9, 3), Z(9), g()()(), f(10, 'div', 10, 4),
                  M('mousedown', function(a) {
                    return N(o), P(r._handlePaginatorPress('after', a))
                  })('click', function() {
                    return N(o), P(r._handlePaginatorClick('after'))
                  })('touchend', function() {
                    return N(o), P(r._stopInterval())
                  }), B(12, 'div', 6), g()
            }
            i&2 &&
                (Y('mat-mdc-tab-header-pagination-disabled',
                   r._disableScrollBefore),
                 x('matRippleDisabled',
                   r._disableScrollBefore || r.disableRipple),
                 b(3),
                 Y('_mat-animation-noopable',
                   r._animationMode === 'NoopAnimations'),
                 b(2),
                 J('aria-label', r.ariaLabel || null)(
                     'aria-labelledby', r.ariaLabelledby || null),
                 b(5),
                 Y('mat-mdc-tab-header-pagination-disabled',
                   r._disableScrollAfter),
                 x('matRippleDisabled',
                   r._disableScrollAfter || r.disableRipple))
          },
          dependencies: [Fr, Om],
          styles: [
            '.mat-mdc-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mdc-tab-indicator .mdc-tab-indicator__content{transition-duration:var(--mat-tab-animation-duration, 250ms)}.mat-mdc-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0);touch-action:none;box-sizing:content-box;outline:0}.mat-mdc-tab-header-pagination::-moz-focus-inner{border:0}.mat-mdc-tab-header-pagination .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab-header-pagination-controls-enabled .mat-mdc-tab-header-pagination{display:flex}.mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after{padding-left:4px}.mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-pagination-after{padding-right:4px}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-mdc-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px;border-color:var(--mat-tab-header-pagination-icon-color, var(--mat-sys-on-surface))}.mat-mdc-tab-header-pagination-disabled{box-shadow:none;cursor:default;pointer-events:none}.mat-mdc-tab-header-pagination-disabled .mat-mdc-tab-header-pagination-chevron{opacity:.4}.mat-mdc-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-mdc-tab-list{transition:none}.mat-mdc-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1;border-bottom-style:solid;border-bottom-width:var(--mat-tab-header-divider-height, 1px);border-bottom-color:var(--mat-tab-header-divider-color, var(--mat-sys-surface-variant))}.mat-mdc-tab-group-inverted-header .mat-mdc-tab-label-container{border-bottom:none;border-top-style:solid;border-top-width:var(--mat-tab-header-divider-height, 1px);border-top-color:var(--mat-tab-header-divider-color, var(--mat-sys-surface-variant))}.mat-mdc-tab-labels{display:flex;flex:1 0 auto}[mat-align-tabs=center]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:flex-end}.cdk-drop-list .mat-mdc-tab-labels,.mat-mdc-tab-labels.cdk-drop-list{min-height:var(--mdc-secondary-navigation-tab-container-height, 48px)}.mat-mdc-tab::before{margin:5px}@media(forced-colors: active){.mat-mdc-tab[aria-disabled=true]{color:GrayText}}'
          ],
          encapsulation: 2
        })
      } return n
    })(),
    _3 = new w('MAT_TABS_CONFIG'), b3 = {
      translateTab:
          Vo('translateTab',
             [
               zr('center, void, left-origin-center, right-origin-center',
                  Ft({transform: 'none', visibility: 'visible'})),
               zr('left', Ft({
                    transform: 'translate3d(-100%, 0, 0)',
                    minHeight: '1px',
                    visibility: 'hidden'
                  })),
               zr('right', Ft({
                    transform: 'translate3d(100%, 0, 0)',
                    minHeight: '1px',
                    visibility: 'hidden'
                  })),
               wi('* => left, * => right, left => center, right => center',
                  er('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),
               wi('void => left-origin-center',
                  [
                    Ft({
                      transform: 'translate3d(-100%, 0, 0)',
                      visibility: 'hidden'
                    }),
                    er('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                  ]),
               wi('void => right-origin-center',
                  [
                    Ft({
                      transform: 'translate3d(100%, 0, 0)',
                      visibility: 'hidden'
                    }),
                    er('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                  ])
             ])
    },
    v3 = (() => {
      class n extends Xi {
        _host = u(KS);
        _centeringSub = ge.EMPTY;
        _leavingSub = ge.EMPTY;
        constructor() {
          super()
        }
        ngOnInit() {
          super.ngOnInit(),
              this._centeringSub =
                  this._host._beforeCentering
                      .pipe(Xe(
                          this._host._isCenterPosition(this._host._position)))
                      .subscribe(
                          e => {
                              this._host._content && e && !this.hasAttached() &&
                              this.attach(this._host._content)}),
              this._leavingSub = this._host._afterLeavingCenter.subscribe(
                  () => {this._host.preserveContent || this.detach()})
        }
        ngOnDestroy() {
          super.ngOnDestroy(), this._centeringSub.unsubscribe(),
              this._leavingSub.unsubscribe()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T(
            {type: n, selectors: [['', 'matTabBodyHost', '']], features: [te]})
      } return n
    })(),
    KS = (() => {
      class n {
        _elementRef = u(L);
        _dir = u(dt, {optional: !0});
        _positionIndex;
        _dirChangeSubscription = ge.EMPTY;
        _position;
        _translateTabComplete = new I;
        _onCentering = new H;
        _beforeCentering = new H;
        _afterLeavingCenter = new H;
        _onCentered = new H(!0);
        _portalHost;
        _content;
        origin;
        animationDuration = '500ms';
        preserveContent = !1;
        set position(e) {
          this._positionIndex = e, this._computePositionAnimationState()
        }
        constructor() {
          if (this._dir) {
            let e = u(Ae);
            this._dirChangeSubscription = this._dir.change.subscribe(
                i => {this._computePositionAnimationState(i), e.markForCheck()})
          }
          this._translateTabComplete.subscribe(e => {
            this._isCenterPosition(e.toState) &&
                this._isCenterPosition(this._position) &&
                this._onCentered.emit(),
            this._isCenterPosition(e.fromState) &&
                !this._isCenterPosition(this._position) &&
                this._afterLeavingCenter.emit()
          })
        }
        ngOnInit() {
          this._position == 'center' && this.origin != null &&
              (this._position = this._computePositionFromOrigin(this.origin))
        }
        ngOnDestroy() {
          this._dirChangeSubscription.unsubscribe(),
              this._translateTabComplete.complete()
        }
        _onTranslateTabStarted(e) {
          let i = this._isCenterPosition(e.toState);
          this._beforeCentering.emit(i),
              i &&
              this._onCentering.emit(
                  this._elementRef.nativeElement.clientHeight)
        }
        _getLayoutDirection() {
          return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr'
        }
        _isCenterPosition(e) {
          return e == 'center' || e == 'left-origin-center' ||
              e == 'right-origin-center'
        }
        _computePositionAnimationState(e = this._getLayoutDirection()) {
          this._positionIndex < 0 ?
              this._position = e == 'ltr' ? 'left' : 'right' :
              this._positionIndex > 0 ?
              this._position = e == 'ltr' ? 'right' : 'left' :
              this._position = 'center'
        }
        _computePositionFromOrigin(e) {
          let i = this._getLayoutDirection();
          return i == 'ltr' && e <= 0 || i == 'rtl' && e > 0 ?
              'left-origin-center' :
              'right-origin-center'
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-tab-body']],
          viewQuery: function(i, r) {
            if (i & 1 && oe(Xi, 5), i & 2) {
              let o;
              $(o = W()) && (r._portalHost = o.first)
            }
          },
          hostAttrs: [1, 'mat-mdc-tab-body'],
          inputs: {
            _content: [0, 'content', '_content'],
            origin: 'origin',
            animationDuration: 'animationDuration',
            preserveContent: 'preserveContent',
            position: 'position'
          },
          outputs: {
            _onCentering: '_onCentering',
            _beforeCentering: '_beforeCentering',
            _afterLeavingCenter: '_afterLeavingCenter',
            _onCentered: '_onCentered'
          },
          decls: 3,
          vars: 6,
          consts: [
            ['content', ''],
            ['cdkScrollable', '', 1, 'mat-mdc-tab-body-content'],
            ['matTabBodyHost', '']
          ],
          template: function(i, r) {
            if (i & 1) {
              let o = ee();
              f(0, 'div', 1, 0), M('@translateTab.start', function(a) {
                return N(o), P(r._onTranslateTabStarted(a))
              })('@translateTab.done', function(a) {
                return N(o), P(r._translateTabComplete.next(a))
              }), R(2, Jz, 0, 0, 'ng-template', 2), g()
            }
            i&2 &&
                x('@translateTab',
                  Rs(3, Xz, r._position, ko(1, Kz, r.animationDuration)))
          },
          dependencies: [v3, Ki],
          styles: [
            '.mat-mdc-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-mdc-tab-body.mat-mdc-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-mdc-tab-group.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body.mat-mdc-tab-body-active{overflow-y:hidden}.mat-mdc-tab-body-content{height:100%;overflow:auto}.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body-content{overflow:hidden}.mat-mdc-tab-body-content[style*="visibility: hidden"]{display:none}'
          ],
          encapsulation: 2,
          data: {animation: [b3.translateTab]}
        })
      } return n
    })(),
    y3 = !0, XS = (() => {
               class n {
                 _elementRef = u(L);
                 _changeDetectorRef = u(Ae);
                 _animationMode = u(Ve, {optional: !0});
                 _allTabs;
                 _tabBodyWrapper;
                 _tabHeader;
                 _tabs = new si;
                 _indexToSelect = 0;
                 _lastFocusedTabIndex = null;
                 _tabBodyWrapperHeight = 0;
                 _tabsSubscription = ge.EMPTY;
                 _tabLabelSubscription = ge.EMPTY;
                 color;
                 get fitInkBarToContent() {
                   return this._fitInkBarToContent
                 }
                 set fitInkBarToContent(e) {
                   this._fitInkBarToContent = e,
                   this._changeDetectorRef.markForCheck()
                 }
                 _fitInkBarToContent = !1;
                 stretchTabs = !0;
                 alignTabs = null;
                 dynamicHeight = !1;
                 get selectedIndex() {
                   return this._selectedIndex
                 }
                 set selectedIndex(e) {
                   this._indexToSelect = isNaN(e) ? null : e
                 }
                 _selectedIndex = null;
                 headerPosition = 'above';
                 get animationDuration() {
                   return this._animationDuration
                 }
                 set animationDuration(e) {
                   let i = e + '';
                   this._animationDuration = /^\d+$/.test(i) ? e + 'ms' : i
                 }
                 _animationDuration;
                 get contentTabIndex() {
                   return this._contentTabIndex
                 }
                 set contentTabIndex(e) {
                   this._contentTabIndex = isNaN(e) ? null : e
                 }
                 _contentTabIndex;
                 disablePagination = !1;
                 disableRipple = !1;
                 preserveContent = !1;
                 get backgroundColor() {
                   return this._backgroundColor
                 }
                 set backgroundColor(e) {
                   if (!y3)
                     throw new Error(
                         'mat-tab-group background color must be set through the Sass theming API');
                   let i = this._elementRef.nativeElement.classList;
                   i.remove(
                       'mat-tabs-with-background',
                       `mat-background-${this.backgroundColor}`),
                       e &&
                       i.add('mat-tabs-with-background', `mat-background-${e}`),
                       this._backgroundColor = e
                 }
                 _backgroundColor;
                 ariaLabel;
                 ariaLabelledby;
                 selectedIndexChange = new H;
                 focusChange = new H;
                 animationDone = new H;
                 selectedTabChange = new H(!0);
                 _groupId;
                 _isServer = !u(Ie).isBrowser;
                 constructor() {
                   let e = u(_3, {optional: !0});
                   this._groupId = u(et).getId('mat-tab-group-'),
                   this.animationDuration =
                       e && e.animationDuration ? e.animationDuration : '500ms',
                   this.disablePagination = e && e.disablePagination != null ?
                       e.disablePagination :
                       !1,
                   this.dynamicHeight =
                       e && e.dynamicHeight != null ? e.dynamicHeight : !1,
                   e?.contentTabIndex != null &&
                       (this.contentTabIndex = e.contentTabIndex),
                   this.preserveContent = !!e?.preserveContent,
                   this.fitInkBarToContent = e && e.fitInkBarToContent != null ?
                       e.fitInkBarToContent :
                       !1,
                   this.stretchTabs =
                       e && e.stretchTabs != null ? e.stretchTabs : !0,
                   this.alignTabs =
                       e && e.alignTabs != null ? e.alignTabs : null
                 }
                 ngAfterContentChecked() {
                   let e = this._indexToSelect =
                       this._clampTabIndex(this._indexToSelect);
                   if (this._selectedIndex != e) {
                     let i = this._selectedIndex == null;
                     if (!i) {
                       this.selectedTabChange.emit(this._createChangeEvent(e));
                       let r = this._tabBodyWrapper.nativeElement;
                       r.style.minHeight = r.clientHeight + 'px'
                     }
                     Promise.resolve().then(() => {
                       this._tabs.forEach((r, o) => r.isActive = o === e),
                       i ||
                           (this.selectedIndexChange.emit(e),
                            this._tabBodyWrapper.nativeElement.style.minHeight =
                                '')
                     })
                   }
                   this._tabs.forEach((i, r) => {
                     i.position = r - e,
                     this._selectedIndex != null && i.position == 0 &&
                         !i.origin && (i.origin = e - this._selectedIndex)
                   }),
                       this._selectedIndex !== e &&
                       (this._selectedIndex = e,
                        this._lastFocusedTabIndex = null,
                        this._changeDetectorRef.markForCheck())
                 }
                 ngAfterContentInit() {
                   this._subscribeToAllTabChanges(),
                       this._subscribeToTabLabels(),
                       this._tabsSubscription =
                           this._tabs.changes.subscribe(() => {
                             let e = this._clampTabIndex(this._indexToSelect);
                             if (e === this._selectedIndex) {
                               let i = this._tabs.toArray(), r;
                               for (let o = 0; o < i.length; o++)
                                 if (i[o].isActive) {
                                   this._indexToSelect = this._selectedIndex =
                                       o,
                                   this._lastFocusedTabIndex = null, r = i[o];
                                   break
                                 }
                               !r && i[e] && Promise.resolve().then(() => {
                                 i[e].isActive = !0,
                                 this.selectedTabChange.emit(
                                     this._createChangeEvent(e))
                               })
                             }
                             this._changeDetectorRef.markForCheck()
                           })
                 }
                 _subscribeToAllTabChanges() {
                   this._allTabs.changes.pipe(Xe(this._allTabs))
                       .subscribe(e => {
                         this._tabs.reset(e.filter(
                             i => i._closestTabGroup === this ||
                                 !i._closestTabGroup)),
                         this._tabs.notifyOnChanges()
                       })
                 }
                 ngOnDestroy() {
                   this._tabs.destroy(), this._tabsSubscription.unsubscribe(),
                       this._tabLabelSubscription.unsubscribe()
                 }
                 realignInkBar() {
                   this._tabHeader &&
                       this._tabHeader._alignInkBarToSelectedTab()
                 }
                 updatePagination() {
                   this._tabHeader && this._tabHeader.updatePagination()
                 }
                 focusTab(e) {
                   let i = this._tabHeader;
                   i && (i.focusIndex = e)
                 }
                 _focusChanged(e) {
                   this._lastFocusedTabIndex = e,
                   this.focusChange.emit(this._createChangeEvent(e))
                 }
                 _createChangeEvent(e) {
                   let i = new ov;
                   return i.index = e,
                          this._tabs && this._tabs.length &&
                              (i.tab = this._tabs.toArray()[e]),
                          i
                 }
                 _subscribeToTabLabels() {
                   this._tabLabelSubscription &&
                       this._tabLabelSubscription.unsubscribe(),
                       this._tabLabelSubscription =
                           Ke(...this._tabs.map(e => e._stateChanges))
                               .subscribe(
                                   () => this._changeDetectorRef.markForCheck())
                 }
                 _clampTabIndex(e) {
                   return Math.min(this._tabs.length - 1, Math.max(e || 0, 0))
                 }
                 _getTabLabelId(e) {
                   return `${this._groupId}-label-${e}`
                 }
                 _getTabContentId(e) {
                   return `${this._groupId}-content-${e}`
                 }
                 _setTabBodyWrapperHeight(e) {
                   if (!this.dynamicHeight || !this._tabBodyWrapperHeight)
                     return;
                   let i = this._tabBodyWrapper.nativeElement;
                   i.style.height = this._tabBodyWrapperHeight + 'px',
                   this._tabBodyWrapper.nativeElement.offsetHeight &&
                       (i.style.height = e + 'px')
                 }
                 _removeTabBodyWrapperHeight() {
                   let e = this._tabBodyWrapper.nativeElement;
                   this._tabBodyWrapperHeight = e.clientHeight,
                   e.style.height = '', this.animationDone.emit()
                 }
                 _handleClick(e, i, r) {
                   i.focusIndex = r, e.disabled || (this.selectedIndex = r)
                 }
                 _getTabIndex(e) {
                   let i = this._lastFocusedTabIndex ?? this.selectedIndex;
                   return e === i ? 0 : -1
                 }
                 _tabFocusChanged(e, i) {
                   e && e !== 'mouse' && e !== 'touch' &&
                       (this._tabHeader.focusIndex = i)
                 }
                 static \u0275fac = function(i) {
                   return new (i || n)
                 };
                 static \u0275cmp = O({
                   type: n,
                   selectors: [['mat-tab-group']],
                   contentQueries: function(i, r, o) {
                     if (i & 1 && Oe(o, av, 5), i & 2) {
                       let s;
                       $(s = W()) && (r._allTabs = s)
                     }
                   },
                   viewQuery: function(i, r) {
                     if (i & 1 && (oe(e3, 5), oe(t3, 5)), i & 2) {
                       let o;
                       $(o = W()) && (r._tabBodyWrapper = o.first),
                           $(o = W()) && (r._tabHeader = o.first)
                     }
                   },
                   hostAttrs: [1, 'mat-mdc-tab-group'],
                   hostVars: 11,
                   hostBindings: function(i, r) {
                     i&2 &&
                         (J('mat-align-tabs', r.alignTabs),
                          kt('mat-' + (r.color || 'primary')),
                          Pt('--mat-tab-animation-duration',
                             r.animationDuration),
                          Y('mat-mdc-tab-group-dynamic-height',
                            r.dynamicHeight)(
                              'mat-mdc-tab-group-inverted-header',
                              r.headerPosition === 'below')(
                              'mat-mdc-tab-group-stretch-tabs', r.stretchTabs))
                   },
                   inputs: {
                     color: 'color',
                     fitInkBarToContent:
                         [2, 'fitInkBarToContent', 'fitInkBarToContent', q],
                     stretchTabs: [2, 'mat-stretch-tabs', 'stretchTabs', q],
                     alignTabs: [0, 'mat-align-tabs', 'alignTabs'],
                     dynamicHeight: [2, 'dynamicHeight', 'dynamicHeight', q],
                     selectedIndex: [2, 'selectedIndex', 'selectedIndex', st],
                     headerPosition: 'headerPosition',
                     animationDuration: 'animationDuration',
                     contentTabIndex:
                         [2, 'contentTabIndex', 'contentTabIndex', st],
                     disablePagination:
                         [2, 'disablePagination', 'disablePagination', q],
                     disableRipple: [2, 'disableRipple', 'disableRipple', q],
                     preserveContent:
                         [2, 'preserveContent', 'preserveContent', q],
                     backgroundColor: 'backgroundColor',
                     ariaLabel: [0, 'aria-label', 'ariaLabel'],
                     ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby']
                   },
                   outputs: {
                     selectedIndexChange: 'selectedIndexChange',
                     focusChange: 'focusChange',
                     animationDone: 'animationDone',
                     selectedTabChange: 'selectedTabChange'
                   },
                   exportAs: ['matTabGroup'],
                   features: [ye([{provide: YS, useExisting: n}])],
                   ngContentSelectors: sv,
                   decls: 9,
                   vars: 8,
                   consts: [
                     ['tabHeader', ''], ['tabBodyWrapper', ''], ['tabNode', ''],
                     [
                       3, 'indexFocused', 'selectFocusedIndex', 'selectedIndex',
                       'disableRipple', 'disablePagination', 'aria-label',
                       'aria-labelledby'
                     ],
                     [
                       'role', 'tab', 'matTabLabelWrapper', '',
                       'cdkMonitorElementFocus', '', 1, 'mdc-tab',
                       'mat-mdc-tab', 'mat-focus-indicator', 3, 'id',
                       'mdc-tab--active', 'class', 'disabled',
                       'fitInkBarToContent'
                     ],
                     [1, 'mat-mdc-tab-body-wrapper'],
                     [
                       'role', 'tabpanel', 3, 'id', 'mat-mdc-tab-body-active',
                       'class', 'content', 'position', 'origin',
                       'animationDuration', 'preserveContent'
                     ],
                     [
                       'role', 'tab', 'matTabLabelWrapper', '',
                       'cdkMonitorElementFocus', '', 1, 'mdc-tab',
                       'mat-mdc-tab', 'mat-focus-indicator', 3, 'click',
                       'cdkFocusChange', 'id', 'disabled', 'fitInkBarToContent'
                     ],
                     [1, 'mdc-tab__ripple'],
                     [
                       'mat-ripple', '', 1, 'mat-mdc-tab-ripple', 3,
                       'matRippleTrigger', 'matRippleDisabled'
                     ],
                     [1, 'mdc-tab__content'], [1, 'mdc-tab__text-label'],
                     [3, 'cdkPortalOutlet'],
                     [
                       'role', 'tabpanel', 3, '_onCentered', '_onCentering',
                       'id', 'content', 'position', 'origin',
                       'animationDuration', 'preserveContent'
                     ]
                   ],
                   template: function(i, r) {
                     if (i & 1) {
                       let o = ee();
                       Se(), f(0, 'mat-tab-header', 3, 0),
                           M('indexFocused',
                             function(a) {
                               return N(o), P(r._focusChanged(a))
                             })(
                               'selectFocusedIndex',
                               function(a) {
                                 return N(o), P(r.selectedIndex = a)
                               }),
                           Do(2, o3, 8, 17, 'div', 4, Co), g(), R(4, s3, 1, 0),
                           f(5, 'div', 5, 1),
                           Do(7, a3, 1, 13, 'mat-tab-body', 6, Co), g()
                     }
                     i&2 &&
                         (x('selectedIndex', r.selectedIndex || 0)(
                              'disableRipple', r.disableRipple)(
                              'disablePagination', r.disablePagination)(
                              'aria-label', r.ariaLabel)(
                              'aria-labelledby', r.ariaLabelledby),
                          b(2), Eo(r._tabs), b(2), de(r._isServer ? 4 : -1),
                          b(),
                          Y('_mat-animation-noopable',
                            r._animationMode === 'NoopAnimations'),
                          b(2), Eo(r._tabs))
                   },
                   dependencies: [g3, ZS, xk, Fr, Xi, KS],
                   styles: [
                     '.mdc-tab{min-width:90px;padding:0 24px;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;border:none;outline:none;text-align:center;white-space:nowrap;cursor:pointer;z-index:1}.mdc-tab__content{display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__text-label{transition:150ms color linear;display:inline-block;line-height:1;z-index:2}.mdc-tab--active .mdc-tab__text-label{transition-delay:100ms}._mat-animation-noopable .mdc-tab__text-label{transition:none}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;justify-content:center;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator__content{transition:var(--mat-tab-animation-duration, 250ms) transform cubic-bezier(0.4, 0, 0.2, 1);transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}._mat-animation-noopable .mdc-tab-indicator__content,.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mat-mdc-tab-ripple.mat-mdc-tab-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-mdc-tab{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-decoration:none;background:none;height:var(--mdc-secondary-navigation-tab-container-height, 48px);font-family:var(--mat-tab-header-label-text-font, var(--mat-sys-title-small-font));font-size:var(--mat-tab-header-label-text-size, var(--mat-sys-title-small-size));letter-spacing:var(--mat-tab-header-label-text-tracking, var(--mat-sys-title-small-tracking));line-height:var(--mat-tab-header-label-text-line-height, var(--mat-sys-title-small-line-height));font-weight:var(--mat-tab-header-label-text-weight, var(--mat-sys-title-small-weight))}.mat-mdc-tab.mdc-tab{flex-grow:0}.mat-mdc-tab .mdc-tab-indicator__content--underline{border-color:var(--mdc-tab-indicator-active-indicator-color, var(--mat-sys-primary));border-top-width:var(--mdc-tab-indicator-active-indicator-height, 2px);border-radius:var(--mdc-tab-indicator-active-indicator-shape, 0)}.mat-mdc-tab:hover .mdc-tab__text-label{color:var(--mat-tab-header-inactive-hover-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab:focus .mdc-tab__text-label{color:var(--mat-tab-header-inactive-focus-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active .mdc-tab__text-label{color:var(--mat-tab-header-active-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active .mdc-tab__ripple::before,.mat-mdc-tab.mdc-tab--active .mat-ripple-element{background-color:var(--mat-tab-header-active-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab__text-label{color:var(--mat-tab-header-active-hover-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-hover-indicator-color, var(--mat-sys-primary))}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab__text-label{color:var(--mat-tab-header-active-focus-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-focus-indicator-color, var(--mat-sys-primary))}.mat-mdc-tab.mat-mdc-tab-disabled{opacity:.4;pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__content{pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__ripple::before,.mat-mdc-tab.mat-mdc-tab-disabled .mat-ripple-element{background-color:var(--mat-tab-header-disabled-ripple-color)}.mat-mdc-tab .mdc-tab__ripple::before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;pointer-events:none;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-inactive-label-text-color, var(--mat-sys-on-surface));display:inline-flex;align-items:center}.mat-mdc-tab .mdc-tab__content{position:relative;pointer-events:auto}.mat-mdc-tab:hover .mdc-tab__ripple::before{opacity:.04}.mat-mdc-tab.cdk-program-focused .mdc-tab__ripple::before,.mat-mdc-tab.cdk-keyboard-focused .mdc-tab__ripple::before{opacity:.12}.mat-mdc-tab .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab-group.mat-mdc-tab-group-stretch-tabs>.mat-mdc-tab-header .mat-mdc-tab{flex-grow:1}.mat-mdc-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination{background-color:var(--mat-tab-header-with-background-background-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-focus-indicator::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-focus-indicator::before{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mdc-tab__ripple::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mdc-tab__ripple::before{background-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header{flex-direction:column-reverse}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header .mdc-tab-indicator__content--underline{align-self:flex-start}.mat-mdc-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-mdc-tab-body-wrapper._mat-animation-noopable{transition:none !important;animation:none !important}'
                   ],
                   encapsulation: 2
                 })
               } return n
             })(),
    ov = class {
  index;
  tab
};
var JS = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe, pe]})
  } return n
})();
function dv() {
  return {
    async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1,
        renderer: null, silent: !1, tokenizer: null, walkTokens: null
  }
}
var Uo = dv();
function oI(n) {
  Uo = n
}
var mc = {exec: () => null};
function Be(n, t = '') {
  let e = typeof n == 'string' ? n : n.source, i = {
    replace: (r, o) => {
      let s = typeof o == 'string' ? o : o.source;
      return s = s.replace(Ht.caret, '$1'), e = e.replace(r, s), i
    },
    getRegex: () => new RegExp(e, t)
  };
  return i
}
var Ht = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: n => new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: n => new RegExp(`^ {0,${
      Math.min(
          3, n - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: n => new RegExp(`^ {0,${
      Math.min(3, n - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: n =>
      new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}#`),
  htmlBeginRegex: n =>
      new RegExp(`^ {0,${Math.min(3, n - 1)}}<(?:[a-z].*>|!--)`, 'i')
},
    x3 = /^(?:[ \t]*(?:\n|$))+/,
    C3 = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,
    D3 =
        /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    fc = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    E3 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, uv = /(?:[*+-]|\d{1,9}[.)])/,
    sI =
        /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    aI = Be(sI)
             .replace(/bull/g, uv)
             .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
             .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
             .replace(/blockquote/g, / {0,3}>/)
             .replace(/heading/g, / {0,3}#{1,6}/)
             .replace(/html/g, / {0,3}<[^\n>]+>\n/)
             .replace(/\|table/g, '')
             .getRegex(),
    k3 = Be(sI)
             .replace(/bull/g, uv)
             .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
             .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
             .replace(/blockquote/g, / {0,3}>/)
             .replace(/heading/g, / {0,3}#{1,6}/)
             .replace(/html/g, / {0,3}<[^\n>]+>\n/)
             .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/)
             .getRegex(),
    mv =
        /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    S3 = /^[^\n]+/, hv = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
    I3 =
        Be(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/)
            .replace('label', hv)
            .replace(
                'title',
                /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
            .getRegex(),
    M3 = Be(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
             .replace(/bull/g, uv)
             .getRegex(),
    yh =
        'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul',
    fv = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
    T3 =
        Be('^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))',
           'i')
            .replace('comment', fv)
            .replace('tag', yh)
            .replace(
                'attribute',
                / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
            .getRegex(),
    lI =
        Be(mv)
            .replace('hr', fc)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('|lheading', '')
            .replace('|table', '')
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
            .replace(
                'html',
                '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
            .replace('tag', yh)
            .getRegex(),
    R3 = Be(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
             .replace('paragraph', lI)
             .getRegex(),
    pv = {
      blockquote: R3,
      code: C3,
      def: I3,
      fences: D3,
      heading: E3,
      hr: fc,
      html: T3,
      lheading: aI,
      list: M3,
      newline: x3,
      paragraph: lI,
      table: mc,
      text: S3
    },
    eI =
        Be('^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)')
            .replace('hr', fc)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('blockquote', ' {0,3}>')
            .replace('code', '(?: {4}| {0,3}	)[^\\n]')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
            .replace(
                'html',
                '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
            .replace('tag', yh)
            .getRegex(),
    A3 = ae(y({}, pv), {
      lheading: k3,
      table: eI,
      paragraph:
          Be(mv)
              .replace('hr', fc)
              .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
              .replace('|lheading', '')
              .replace('table', eI)
              .replace('blockquote', ' {0,3}>')
              .replace(
                  'fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
              .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
              .replace(
                  'html',
                  '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
              .replace('tag', yh)
              .getRegex()
    }),
    O3 = ae(y({}, pv), {
      html:
          Be(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`)
              .replace('comment', fv)
              .replace(
                  /tag/g,
                  '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
              .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: mc,
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: Be(mv)
                     .replace('hr', fc)
                     .replace('heading', ` *#{1,6} *[^
]`)
                     .replace('lheading', aI)
                     .replace('|table', '')
                     .replace('blockquote', ' {0,3}>')
                     .replace('|fences', '')
                     .replace('|list', '')
                     .replace('|html', '')
                     .replace('|tag', '')
                     .getRegex()
    }),
    N3 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    P3 = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, cI = /^( {2,}|\\)\n(?!\s*$)/,
    F3 =
        /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    wh = /[\p{P}\p{S}]/u, gv = /[\s\p{P}\p{S}]/u, dI = /[^\s\p{P}\p{S}]/u,
    L3 = Be(/^((?![*_])punctSpace)/, 'u').replace(/punctSpace/g, gv).getRegex(),
    uI = /(?!~)[\p{P}\p{S}]/u, V3 = /(?!~)[\s\p{P}\p{S}]/u,
    j3 = /(?:[^\s\p{P}\p{S}]|~)/u,
    B3 =
        /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g,
    mI = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,
    z3 = Be(mI, 'u').replace(/punct/g, wh).getRegex(),
    H3 = Be(mI, 'u').replace(/punct/g, uI).getRegex(),
    hI =
        '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)',
    U3 = Be(hI, 'gu')
             .replace(/notPunctSpace/g, dI)
             .replace(/punctSpace/g, gv)
             .replace(/punct/g, wh)
             .getRegex(),
    $3 = Be(hI, 'gu')
             .replace(/notPunctSpace/g, j3)
             .replace(/punctSpace/g, V3)
             .replace(/punct/g, uI)
             .getRegex(),
    W3 =
        Be('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)',
           'gu')
            .replace(/notPunctSpace/g, dI)
            .replace(/punctSpace/g, gv)
            .replace(/punct/g, wh)
            .getRegex(),
    q3 = Be(/\\(punct)/, 'gu').replace(/punct/g, wh).getRegex(),
    G3 =
        Be(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
            .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
            .replace(
                'email',
                /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
            .getRegex(),
    Q3 = Be(fv).replace('(?:-->|$)', '-->').getRegex(),
    Y3 =
        Be('^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>')
            .replace('comment', Q3)
            .replace(
                'attribute',
                /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
            .getRegex(),
    vh = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
    Z3 = Be(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
             .replace('label', vh)
             .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
             .replace(
                 'title',
                 /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
             .getRegex(),
    fI = Be(/^!?\[(label)\]\[(ref)\]/)
             .replace('label', vh)
             .replace('ref', hv)
             .getRegex(),
    pI = Be(/^!?\[(ref)\](?:\[\])?/).replace('ref', hv).getRegex(),
    K3 = Be('reflink|nolink(?!\\()', 'g')
             .replace('reflink', fI)
             .replace('nolink', pI)
             .getRegex(),
    _v = {
      _backpedal: mc,
      anyPunctuation: q3,
      autolink: G3,
      blockSkip: B3,
      br: cI,
      code: P3,
      del: mc,
      emStrongLDelim: z3,
      emStrongRDelimAst: U3,
      emStrongRDelimUnd: W3,
      escape: N3,
      link: Z3,
      nolink: pI,
      punctuation: L3,
      reflink: fI,
      reflinkSearch: K3,
      tag: Y3,
      text: F3,
      url: mc
    },
    X3 = ae(y({}, _v), {
      link: Be(/^!?\[(label)\]\((.*?)\)/).replace('label', vh).getRegex(),
      reflink:
          Be(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', vh).getRegex()
    }),
    lv = ae(y({}, _v), {
      emStrongRDelimAst: $3,
      emStrongLDelim: H3,
      url:
          Be(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
             'i')
              .replace(
                  'email',
                  /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
              .getRegex(),
      _backpedal:
          /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
      text:
          /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    }),
    J3 = ae(y({}, lv), {
      br: Be(cI).replace('{2,}', '*').getRegex(),
      text: Be(lv.text)
                .replace('\\b_', '\\b_| {2,}\\n')
                .replace(/\{2,\}/g, '*')
                .getRegex()
    }),
    bh = {normal: pv, gfm: A3, pedantic: O3},
    dc = {normal: _v, gfm: lv, breaks: J3, pedantic: X3},
    eH = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;'},
    tI = n => eH[n];
function Ei(n, t) {
  if (t) {
    if (Ht.escapeTest.test(n)) return n.replace(Ht.escapeReplace, tI)
  } else if (Ht.escapeTestNoEncode.test(n))
    return n.replace(Ht.escapeReplaceNoEncode, tI);
  return n
}
function nI(n) {
  try {
    n = encodeURI(n).replace(Ht.percentDecode, '%')
  } catch {
    return null
  }
  return n
}
function iI(n, t) {
  let e = n.replace(Ht.findPipe, (o, s, a) => {
    let l = !1, c = s;
    for (; --c >= 0 && a[c] === '\\';) l = !l;
    return l ? '|' : ' |'
  }), i = e.split(Ht.splitPipe), r = 0;
  if (i[0].trim() || i.shift(), i.length > 0 && !i.at(-1)?.trim() && i.pop(), t)
    if (i.length > t)
      i.splice(t);
    else
      for (; i.length < t;) i.push('');
  for (; r < i.length; r++) i[r] = i[r].trim().replace(Ht.slashPipe, '|');
  return i
}
function uc(n, t, e) {
  let i = n.length;
  if (i === 0) return '';
  let r = 0;
  for (; r < i && n.charAt(i - r - 1) === t;) r++;
  return n.slice(0, i - r)
}
function tH(n, t) {
  if (n.indexOf(t[1]) === -1) return -1;
  let e = 0;
  for (let i = 0; i < n.length; i++)
    if (n[i] === '\\')
      i++;
    else if (n[i] === t[0])
      e++;
    else if (n[i] === t[1] && (e--, e < 0))
      return i;
  return -1
}
function rI(n, t, e, i, r) {
  let o = t.href, s = t.title || null,
      a = n[1].replace(r.other.outputLinkReplace, '$1');
  if (n[0].charAt(0) !== '!') {
    i.state.inLink = !0;
    let l = {
      type: 'link',
      raw: e,
      href: o,
      title: s,
      text: a,
      tokens: i.inlineTokens(a)
    };
    return i.state.inLink = !1, l
  }
  return {
    type: 'image', raw: e, href: o, title: s, text: a
  }
}
function nH(n, t, e) {
  let i = n.match(e.other.indentCodeCompensation);
  if (i === null) return t;
  let r = i[1];
  return t
      .split(`
`)
      .map(o => {
        let s = o.match(e.other.beginningSpace);
        if (s === null) return o;
        let [a] = s;
        return a.length >= r.length ? o.slice(r.length) : o
      })
      .join(`
`)
}
var wa = class {
  options;
  rules;
  lexer;
  constructor(t) {
    this.options = t || Uo
  }
  space(t) {
    let e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0) return {
        type: 'space', raw: e[0]
      }
  }
  code(t) {
    let e = this.rules.block.code.exec(t);
    if (e) {
      let i = e[0].replace(this.rules.other.codeRemoveIndent, '');
      return {
        type: 'code', raw: e[0], codeBlockStyle: 'indented',
            text: this.options.pedantic ? i : uc(i, `
`)
      }
    }
  }
  fences(t) {
    let e = this.rules.block.fences.exec(t);
    if (e) {
      let i = e[0], r = nH(i, e[3] || '', this.rules);
      return {
        type: 'code', raw: i,
            lang: e[2] ?
            e[2].trim().replace(this.rules.inline.anyPunctuation, '$1') :
            e[2],
            text: r
      }
    }
  }
  heading(t) {
    let e = this.rules.block.heading.exec(t);
    if (e) {
      let i = e[2].trim();
      if (this.rules.other.endingHash.test(i)) {
        let r = uc(i, '#');
        (this.options.pedantic || !r ||
         this.rules.other.endingSpaceChar.test(r)) &&
            (i = r.trim())
      }
      return {
        type: 'heading', raw: e[0], depth: e[1].length, text: i,
            tokens: this.lexer.inline(i)
      }
    }
  }
  hr(t) {
    let e = this.rules.block.hr.exec(t);
    if (e) return {
        type: 'hr', raw: uc(e[0], `
`)
      }
  }
  blockquote(t) {
    let e = this.rules.block.blockquote.exec(t);
    if (e) {
      let i = uc(e[0], `
`).split(`
`),
          r = '', o = '', s = [];
      for (; i.length > 0;) {
        let a = !1, l = [], c;
        for (c = 0; c < i.length; c++)
          if (this.rules.other.blockquoteStart.test(i[c]))
            l.push(i[c]), a = !0;
          else if (!a)
            l.push(i[c]);
          else
            break;
        i = i.slice(c);
        let d = l.join(`
`),
            m = d.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, '');
        r = r ? `${r}
${d}` :
                d,
        o = o ? `${o}
${m}` :
                m;
        let p = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(m, s, !0),
            this.lexer.state.top = p, i.length === 0)
          break;
        let h = s.at(-1);
        if (h?.type === 'code') break;
        if (h?.type === 'blockquote') {
          let _ = h, v = _.raw + `
` + i.join(`
`),
              k = this.blockquote(v);
          s[s.length - 1] = k,
                       r = r.substring(0, r.length - _.raw.length) + k.raw,
                       o = o.substring(0, o.length - _.text.length) + k.text;
          break
        } else if (h?.type === 'list') {
          let _ = h, v = _.raw + `
` + i.join(`
`),
              k = this.list(v);
          s[s.length - 1] = k,
                       r = r.substring(0, r.length - h.raw.length) + k.raw,
                       o = o.substring(0, o.length - _.raw.length) + k.raw,
                       i = v.substring(s.at(-1).raw.length).split(`
`);
          continue
        }
      }
      return {
        type: 'blockquote', raw: r, tokens: s, text: o
      }
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let i = e[1].trim(), r = i.length > 1, o = {
        type: 'list',
        raw: '',
        ordered: r,
        start: r ? +i.slice(0, -1) : '',
        loose: !1,
        items: []
      };
      i = r ? `\\d{1,9}\\${i.slice(-1)}` : `\\${i}`,
      this.options.pedantic && (i = r ? i : '[*+-]');
      let s = this.rules.other.listItemRegex(i), a = !1;
      for (; t;) {
        let c = !1, d = '', m = '';
        if (!(e = s.exec(t)) || this.rules.block.hr.test(t)) break;
        d = e[0], t = t.substring(d.length);
        let p = e[2].split(
                        `
`,
                        1)[0]
                    .replace(
                        this.rules.other.listReplaceTabs,
                        se => ' '.repeat(3 * se.length)),
            h = t.split(
                `
`,
                1)[0],
            _ = !p.trim(), v = 0;
        if (this.options.pedantic ? (v = 2, m = p.trimStart()) :
                _                 ? v = e[1].length + 1 :
                    (v = e[2].search(this.rules.other.nonSpaceChar),
                     v = v > 4 ? 1 : v, m = p.slice(v), v += e[1].length),
            _ && this.rules.other.blankLine.test(h) &&
                (d += h + `
`,
                 t = t.substring(h.length + 1), c = !0),
            !c) {
          let se = this.rules.other.nextBulletRegex(v),
              Ce = this.rules.other.hrRegex(v),
              Ze = this.rules.other.fencesBeginRegex(v),
              kn = this.rules.other.headingBeginRegex(v),
              Ut = this.rules.other.htmlBeginRegex(v);
          for (; t;) {
            let ft = t.split(
                    `
`,
                    1)[0],
                ut;
            if (h = ft,
                this.options.pedantic ?
                    (h = h.replace(this.rules.other.listReplaceNesting, '  '),
                     ut = h) :
                    ut = h.replace(this.rules.other.tabCharGlobal, '    '),
                Ze.test(h) || kn.test(h) || Ut.test(h) || se.test(h) ||
                    Ce.test(h))
              break;
            if (ut.search(this.rules.other.nonSpaceChar) >= v || !h.trim())
              m += `
` + ut.slice(v);
            else {
              if (_ ||
                  p.replace(this.rules.other.tabCharGlobal, '    ')
                          .search(this.rules.other.nonSpaceChar) >= 4 ||
                  Ze.test(p) || kn.test(p) || Ce.test(p))
                break;
              m += `
` + h
            }
            !_ && !h.trim() && (_ = !0), d += ft + `
`,
                t = t.substring(ft.length + 1), p = ut.slice(v)
          }
        }
        o.loose ||
            (a ? o.loose = !0 :
                 this.rules.other.doubleBlankLine.test(d) && (a = !0));
        let k = null, F;
        this.options.gfm &&
            (k = this.rules.other.listIsTask.exec(m),
             k &&
                 (F = k[0] !== '[ ] ',
                  m = m.replace(this.rules.other.listReplaceTask, ''))),
            o.items.push({
              type: 'list_item',
              raw: d,
              task: !!k,
              checked: F,
              loose: !1,
              text: m,
              tokens: []
            }),
            o.raw += d
      }
      let l = o.items.at(-1);
      if (l)
        l.raw = l.raw.trimEnd(), l.text = l.text.trimEnd();
      else
        return;
      o.raw = o.raw.trimEnd();
      for (let c = 0; c < o.items.length; c++)
        if (this.lexer.state.top = !1,
            o.items[c].tokens = this.lexer.blockTokens(o.items[c].text, []),
            !o.loose) {
          let d = o.items[c].tokens.filter(p => p.type === 'space'),
              m = d.length > 0 &&
              d.some(p => this.rules.other.anyLine.test(p.raw));
          o.loose = m
        }
      if (o.loose)
        for (let c = 0; c < o.items.length; c++) o.items[c].loose = !0;
      return o
    }
  }
  html(t) {
    let e = this.rules.block.html.exec(t);
    if (e) return {
        type: 'html', block: !0, raw: e[0],
            pre: e[1] === 'pre' || e[1] === 'script' || e[1] === 'style',
            text: e[0]
      }
  }
  def(t) {
    let e = this.rules.block.def.exec(t);
    if (e) {
      let i = e[1].toLowerCase().replace(
              this.rules.other.multipleSpaceGlobal, ' '),
          r = e[2] ? e[2].replace(this.rules.other.hrefBrackets, '$1')
                         .replace(this.rules.inline.anyPunctuation, '$1') :
                     '',
          o = e[3] ? e[3].substring(1, e[3].length - 1)
                         .replace(this.rules.inline.anyPunctuation, '$1') :
                     e[3];
      return {
        type: 'def', tag: i, raw: e[0], href: r, title: o
      }
    }
  }
  table(t) {
    let e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let i = iI(e[1]),
        r = e[2].replace(this.rules.other.tableAlignChars, '').split('|'),
        o = e[3]?.trim() ?
        e[3].replace(this.rules.other.tableRowBlankLine, '').split(`
`) :
        [],
        s = {type: 'table', raw: e[0], header: [], align: [], rows: []};
    if (i.length === r.length) {
      for (let a of r)
        this.rules.other.tableAlignRight.test(a)      ? s.align.push('right') :
            this.rules.other.tableAlignCenter.test(a) ? s.align.push('center') :
            this.rules.other.tableAlignLeft.test(a)   ? s.align.push('left') :
                                                        s.align.push(null);
      for (let a = 0; a < i.length; a++)
        s.header.push({
          text: i[a],
          tokens: this.lexer.inline(i[a]),
          header: !0,
          align: s.align[a]
        });
      for (let a of o)
        s.rows.push(iI(a, s.header.length).map((l, c) => ({
                                                 text: l,
                                                 tokens: this.lexer.inline(l),
                                                 header: !1,
                                                 align: s.align[c]
                                               })));
      return s
    }
  }
  lheading(t) {
    let e = this.rules.block.lheading.exec(t);
    if (e) return {
        type: 'heading', raw: e[0], depth: e[2].charAt(0) === '=' ? 1 : 2,
            text: e[1], tokens: this.lexer.inline(e[1])
      }
  }
  paragraph(t) {
    let e = this.rules.block.paragraph.exec(t);
    if (e) {
      let i = e[1].charAt(e[1].length - 1) === `
` ?
          e[1].slice(0, -1) :
          e[1];
      return {
        type: 'paragraph', raw: e[0], text: i, tokens: this.lexer.inline(i)
      }
    }
  }
  text(t) {
    let e = this.rules.block.text.exec(t);
    if (e) return {
        type: 'text', raw: e[0], text: e[0], tokens: this.lexer.inline(e[0])
      }
  }
  escape(t) {
    let e = this.rules.inline.escape.exec(t);
    if (e) return {
        type: 'escape', raw: e[0], text: e[1]
      }
  }
  tag(t) {
    let e = this.rules.inline.tag.exec(t);
    if (e)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ?
                 this.lexer.state.inLink = !0 :
                 this.lexer.state.inLink &&
                     this.rules.other.endATag.test(e[0]) &&
                     (this.lexer.state.inLink = !1),
                 !this.lexer.state.inRawBlock &&
                     this.rules.other.startPreScriptTag.test(e[0]) ?
                 this.lexer.state.inRawBlock = !0 :
                 this.lexer.state.inRawBlock &&
                     this.rules.other.endPreScriptTag.test(e[0]) &&
                     (this.lexer.state.inRawBlock = !1),
      {
        type: 'html', raw: e[0], inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock, block: !1, text: e[0]
      }
  }
  link(t) {
    let e = this.rules.inline.link.exec(t);
    if (e) {
      let i = e[2].trim();
      if (!this.options.pedantic &&
          this.rules.other.startAngleBracket.test(i)) {
        if (!this.rules.other.endAngleBracket.test(i)) return;
        let s = uc(i.slice(0, -1), '\\');
        if ((i.length - s.length) % 2 === 0) return
      } else {
        let s = tH(e[2], '()');
        if (s > -1) {
          let l = (e[0].indexOf('!') === 0 ? 5 : 4) + e[1].length + s;
          e[2] = e[2].substring(0, s), e[0] = e[0].substring(0, l).trim(),
          e[3] = ''
        }
      }
      let r = e[2], o = '';
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], o = s[3])
      } else
        o = e[3] ? e[3].slice(1, -1) : '';
      return r = r.trim(),
             this.rules.other.startAngleBracket.test(r) &&
                 (this.options.pedantic &&
                          !this.rules.other.endAngleBracket.test(i) ?
                      r = r.slice(1) :
                      r = r.slice(1, -1)),
             rI(e, {
               href: r && r.replace(this.rules.inline.anyPunctuation, '$1'),
               title: o && o.replace(this.rules.inline.anyPunctuation, '$1')
             },
                e[0], this.lexer, this.rules)
    }
  }
  reflink(t, e) {
    let i;
    if ((i = this.rules.inline.reflink.exec(t)) ||
        (i = this.rules.inline.nolink.exec(t))) {
      let r = (i[2] || i[1]).replace(this.rules.other.multipleSpaceGlobal, ' '),
          o = e[r.toLowerCase()];
      if (!o) {
        let s = i[0].charAt(0);
        return {
          type: 'text', raw: s, text: s
        }
      }
      return rI(i, o, i[0], this.lexer, this.rules)
    }
  }
  emStrong(t, e, i = '') {
    let r = this.rules.inline.emStrongLDelim.exec(t);
    if (!r || r[3] && i.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || '') || !i || this.rules.inline.punctuation.exec(i)) {
      let s = [...r[0]].length - 1, a, l, c = s, d = 0,
          m = r[0][0] === '*' ? this.rules.inline.emStrongRDelimAst :
                                this.rules.inline.emStrongRDelimUnd;
      for (m.lastIndex = 0, e = e.slice(-1 * t.length + s);
           (r = m.exec(e)) != null;) {
        if (a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a) continue;
        if (l = [...a].length, r[3] || r[4]) {
          c += l;
          continue
        } else if ((r[5] || r[6]) && s % 3 && !((s + l) % 3)) {
          d += l;
          continue
        }
        if (c -= l, c > 0) continue;
        l = Math.min(l, l + c + d);
        let p = [...r[0]][0].length, h = t.slice(0, s + r.index + p + l);
        if (Math.min(s, l) % 2) {
          let v = h.slice(1, -1);
          return {
            type: 'em', raw: h, text: v, tokens: this.lexer.inlineTokens(v)
          }
        }
        let _ = h.slice(2, -2);
        return {
          type: 'strong', raw: h, text: _, tokens: this.lexer.inlineTokens(_)
        }
      }
    }
  }
  codespan(t) {
    let e = this.rules.inline.code.exec(t);
    if (e) {
      let i = e[2].replace(this.rules.other.newLineCharGlobal, ' '),
          r = this.rules.other.nonSpaceChar.test(i),
          o = this.rules.other.startingSpaceChar.test(i) &&
          this.rules.other.endingSpaceChar.test(i);
      return r && o && (i = i.substring(1, i.length - 1)), {
        type: 'codespan', raw: e[0], text: i
      }
    }
  }
  br(t) {
    let e = this.rules.inline.br.exec(t);
    if (e) return {
        type: 'br', raw: e[0]
      }
  }
  del(t) {
    let e = this.rules.inline.del.exec(t);
    if (e) return {
        type: 'del', raw: e[0], text: e[2],
            tokens: this.lexer.inlineTokens(e[2])
      }
  }
  autolink(t) {
    let e = this.rules.inline.autolink.exec(t);
    if (e) {
      let i, r;
      return e[2] === '@' ? (i = e[1], r = 'mailto:' + i) : (i = e[1], r = i), {
        type: 'link', raw: e[0], text: i, href: r,
            tokens: [{type: 'text', raw: i, text: i}]
      }
    }
  }
  url(t) {
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let i, r;
      if (e[2] === '@')
        i = e[0], r = 'mailto:' + i;
      else {
        let o;
        do o = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])?.[0] ?? '';
        while (o !== e[0]);
        i = e[0], e[1] === 'www.' ? r = 'http://' + e[0] : r = e[0]
      }
      return {
        type: 'link', raw: e[0], text: i, href: r,
            tokens: [{type: 'text', raw: i, text: i}]
      }
    }
  }
  inlineText(t) {
    let e = this.rules.inline.text.exec(t);
    if (e) {
      let i = this.lexer.state.inRawBlock;
      return {
        type: 'text', raw: e[0], text: e[0], escaped: i
      }
    }
  }
}
, qn = class n {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(t) {
    this.tokens = [], this.tokens.links = Object.create(null),
    this.options = t || Uo,
    this.options.tokenizer = this.options.tokenizer || new wa,
    this.tokenizer = this.options.tokenizer,
    this.tokenizer.options = this.options, this.tokenizer.lexer = this,
    this.inlineQueue = [], this.state = {inLink: !1, inRawBlock: !1, top: !0};
    let e = {other: Ht, block: bh.normal, inline: dc.normal};
    this.options.pedantic ? (e.block = bh.pedantic, e.inline = dc.pedantic) :
                            this.options.gfm &&
            (e.block = bh.gfm,
             this.options.breaks ? e.inline = dc.breaks : e.inline = dc.gfm),
        this.tokenizer.rules = e
  }
  static get rules() {
    return {
      block: bh, inline: dc
    }
  }
  static lex(t, e) {
    return new n(e).lex(t)
  }
  static lexInline(t, e) {
    return new n(e).inlineTokens(t)
  }
  lex(t) {
    t = t.replace(Ht.carriageReturn, `
`),
    this.blockTokens(t, this.tokens);
    for (let e = 0; e < this.inlineQueue.length; e++) {
      let i = this.inlineQueue[e];
      this.inlineTokens(i.src, i.tokens)
    }
    return this.inlineQueue = [], this.tokens
  }
  blockTokens(t, e = [], i = !1) {
    for (this.options.pedantic &&
             (t = t.replace(Ht.tabCharGlobal, '    ')
                      .replace(Ht.spaceLine, ''));
         t;) {
      let r;
      if (this.options.extensions?.block?.some(
              s => (r = s.call({lexer: this}, t, e)) ?
                  (t = t.substring(r.raw.length), e.push(r), !0) :
                  !1))
        continue;
      if (r = this.tokenizer.space(t)) {
        t = t.substring(r.raw.length);
        let s = e.at(-1);
        r.raw.length === 1 && s !== void 0 ? s.raw += `
` :
                                             e.push(r);
        continue
      }
      if (r = this.tokenizer.code(t)) {
        t = t.substring(r.raw.length);
        let s = e.at(-1);
        s?.type === 'paragraph' || s?.type === 'text' ?
            (s.raw += `
` + r.raw,
             s.text += `
` + r.text,
             this.inlineQueue.at(-1).src = s.text) :
            e.push(r);
        continue
      }
      if (r = this.tokenizer.fences(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.heading(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.hr(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.blockquote(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.list(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.html(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.def(t)) {
        t = t.substring(r.raw.length);
        let s = e.at(-1);
        s?.type === 'paragraph' || s?.type === 'text' ?
            (s.raw += `
` + r.raw,
             s.text += `
` + r.raw,
             this.inlineQueue.at(-1).src = s.text) :
            this.tokens.links[r.tag] ||
                (this.tokens.links[r.tag] = {href: r.href, title: r.title});
        continue
      }
      if (r = this.tokenizer.table(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      if (r = this.tokenizer.lheading(t)) {
        t = t.substring(r.raw.length), e.push(r);
        continue
      }
      let o = t;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, a = t.slice(1), l;
        this.options.extensions.startBlock.forEach(c => {
          l = c.call({lexer: this}, a),
          typeof l == 'number' && l >= 0 && (s = Math.min(s, l))
        }),
            s < 1 / 0 && s >= 0 && (o = t.substring(0, s + 1))
      }
      if (this.state.top && (r = this.tokenizer.paragraph(o))) {
        let s = e.at(-1);
        i && s?.type === 'paragraph' ?
            (s.raw += `
` + r.raw,
             s.text += `
` + r.text,
             this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) :
            e.push(r),
            i = o.length !== t.length, t = t.substring(r.raw.length);
        continue
      }
      if (r = this.tokenizer.text(t)) {
        t = t.substring(r.raw.length);
        let s = e.at(-1);
        s?.type === 'text' ?
            (s.raw += `
` + r.raw,
             s.text += `
` + r.text,
             this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) :
            e.push(r);
        continue
      }
      if (t) {
        let s = 'Infinite loop on byte: ' + t.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break
        } else
          throw new Error(s)
      }
    }
    return this.state.top = !0, e
  }
  inline(t, e = []) {
    return this.inlineQueue.push({src: t, tokens: e}), e
  }
  inlineTokens(t, e = []) {
    let i = t, r = null;
    if (this.tokens.links) {
      let a = Object.keys(this.tokens.links);
      if (a.length > 0)
        for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(i)) != null;)
          a.includes(r[0].slice(r[0].lastIndexOf('[') + 1, -1)) &&
              (i = i.slice(0, r.index) + '[' +
                   'a'.repeat(r[0].length - 2) + ']' +
                   i.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
    }
    for (; (r = this.tokenizer.rules.inline.blockSkip.exec(i)) != null;)
      i = i.slice(0, r.index) + '[' +
          'a'.repeat(r[0].length - 2) + ']' +
          i.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(i)) != null;)
      i = i.slice(0, r.index) + '++' +
          i.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let o = !1, s = '';
    for (; t;) {
      o || (s = ''), o = !1;
      let a;
      if (this.options.extensions?.inline?.some(
              c => (a = c.call({lexer: this}, t, e)) ?
                  (t = t.substring(a.raw.length), e.push(a), !0) :
                  !1))
        continue;
      if (a = this.tokenizer.escape(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.tag(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.link(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.reflink(t, this.tokens.links)) {
        t = t.substring(a.raw.length);
        let c = e.at(-1);
        a.type === 'text' && c?.type === 'text' ?
            (c.raw += a.raw, c.text += a.text) :
            e.push(a);
        continue
      }
      if (a = this.tokenizer.emStrong(t, i, s)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.codespan(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.br(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.del(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (a = this.tokenizer.autolink(t)) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      if (!this.state.inLink && (a = this.tokenizer.url(t))) {
        t = t.substring(a.raw.length), e.push(a);
        continue
      }
      let l = t;
      if (this.options.extensions?.startInline) {
        let c = 1 / 0, d = t.slice(1), m;
        this.options.extensions.startInline.forEach(p => {
          m = p.call({lexer: this}, d),
          typeof m == 'number' && m >= 0 && (c = Math.min(c, m))
        }),
            c < 1 / 0 && c >= 0 && (l = t.substring(0, c + 1))
      }
      if (a = this.tokenizer.inlineText(l)) {
        t = t.substring(a.raw.length),
        a.raw.slice(-1) !== '_' && (s = a.raw.slice(-1)), o = !0;
        let c = e.at(-1);
        c?.type === 'text' ? (c.raw += a.raw, c.text += a.text) : e.push(a);
        continue
      }
      if (t) {
        let c = 'Infinite loop on byte: ' + t.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break
        } else
          throw new Error(c)
      }
    }
    return e
  }
}
, ki = class {
  options;
  parser;
  constructor(t) {
    this.options = t || Uo
  }
  space(t) {
    return ''
  }
  code({text: t, lang: e, escaped: i}) {
    let r = (e || '').match(Ht.notSpaceStart)?.[0],
        o = t.replace(Ht.endingNewline, '') + `
`;
    return r ? '<pre><code class="language-' + Ei(r) + '">' +
            (i ? o : Ei(o, !0)) + `</code></pre>
` :
               '<pre><code>' + (i ? o : Ei(o, !0)) + `</code></pre>
`
  }
  blockquote({tokens: t}) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`
  }
  html({text: t}) {
    return t
  }
  heading({tokens: t, depth: e}) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`
  }
  hr(t) {
    return `<hr>
`
  }
  list(t) {
    let e = t.ordered, i = t.start, r = '';
    for (let a = 0; a < t.items.length; a++) {
      let l = t.items[a];
      r += this.listitem(l)
    }
    let o = e ? 'ol' : 'ul', s = e && i !== 1 ? ' start="' + i + '"' : '';
    return '<' + o + s + `>
` + r + '</' +
        o + `>
`
  }
  listitem(t) {
    let e = '';
    if (t.task) {
      let i = this.checkbox({checked: !!t.checked});
      t.loose ? t.tokens[0]?.type === 'paragraph' ?
                (t.tokens[0].text = i + ' ' + t.tokens[0].text,
                 t.tokens[0].tokens && t.tokens[0].tokens.length > 0 &&
                     t.tokens[0].tokens[0].type === 'text' &&
                     (t.tokens[0].tokens[0].text =
                          i + ' ' + Ei(t.tokens[0].tokens[0].text),
                      t.tokens[0].tokens[0].escaped = !0)) :
                t.tokens.unshift(
                    {type: 'text', raw: i + ' ', text: i + ' ', escaped: !0}) :
                e += i + ' '
    }
    return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`
  }
  checkbox({checked: t}) {
    return '<input ' + (t ? 'checked="" ' : '') + 'disabled="" type="checkbox">'
  }
  paragraph({tokens: t}) {
    return `<p>${this.parser.parseInline(t)}</p>
`
  }
  table(t) {
    let e = '', i = '';
    for (let o = 0; o < t.header.length; o++) i += this.tablecell(t.header[o]);
    e += this.tablerow({text: i});
    let r = '';
    for (let o = 0; o < t.rows.length; o++) {
      let s = t.rows[o];
      i = '';
      for (let a = 0; a < s.length; a++) i += this.tablecell(s[a]);
      r += this.tablerow({text: i})
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + r + `</table>
`
  }
  tablerow({text: t}) {
    return `<tr>
${t}</tr>
`
  }
  tablecell(t) {
    let e = this.parser.parseInline(t.tokens), i = t.header ? 'th' : 'td';
    return (t.align ? `<${i} align="${t.align}">` : `<${i}>`) + e + `</${i}>
`
  }
  strong({tokens: t}) {
    return `<strong>${this.parser.parseInline(t)}</strong>`
  }
  em({tokens: t}) {
    return `<em>${this.parser.parseInline(t)}</em>`
  }
  codespan({text: t}) {
    return `<code>${Ei(t, !0)}</code>`
  }
  br(t) {
    return '<br>'
  }
  del({tokens: t}) {
    return `<del>${this.parser.parseInline(t)}</del>`
  }
  link({href: t, title: e, tokens: i}) {
    let r = this.parser.parseInline(i), o = nI(t);
    if (o === null) return r;
    t = o;
    let s = '<a href="' + t + '"';
    return e && (s += ' title="' + Ei(e) + '"'), s += '>' + r + '</a>', s
  }
  image({href: t, title: e, text: i}) {
    let r = nI(t);
    if (r === null) return Ei(i);
    t = r;
    let o = `<img src="${t}" alt="${i}"`;
    return e && (o += ` title="${Ei(e)}"`), o += '>', o
  }
  text(t) {
    return 'tokens' in t && t.tokens ? this.parser.parseInline(t.tokens) :
        'escaped' in t && t.escaped  ? t.text :
                                       Ei(t.text)
  }
}
, hc = class {
  strong({text: t}) {
    return t
  }
  em({text: t}) {
    return t
  }
  codespan({text: t}) {
    return t
  }
  del({text: t}) {
    return t
  }
  html({text: t}) {
    return t
  }
  text({text: t}) {
    return t
  }
  link({text: t}) {
    return '' + t
  }
  image({text: t}) {
    return '' + t
  }
  br() {
    return ''
  }
}
, Gn = class n {
  options;
  renderer;
  textRenderer;
  constructor(t) {
    this.options = t || Uo,
    this.options.renderer = this.options.renderer || new ki,
    this.renderer = this.options.renderer, this.renderer.options = this.options,
    this.renderer.parser = this, this.textRenderer = new hc
  }
  static parse(t, e) {
    return new n(e).parse(t)
  }
  static parseInline(t, e) {
    return new n(e).parseInline(t)
  }
  parse(t, e = !0) {
    let i = '';
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a = o,
            l = this.options.extensions.renderers[a.type].call(
                {parser: this}, a);
        if (l !== !1 ||
            !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list',
              'html', 'paragraph', 'text']
                 .includes(a.type)) {
          i += l || '';
          continue
        }
      }
      let s = o;
      switch (s.type) {
        case 'space': {
          i += this.renderer.space(s);
          continue
        }
        case 'hr': {
          i += this.renderer.hr(s);
          continue
        }
        case 'heading': {
          i += this.renderer.heading(s);
          continue
        }
        case 'code': {
          i += this.renderer.code(s);
          continue
        }
        case 'table': {
          i += this.renderer.table(s);
          continue
        }
        case 'blockquote': {
          i += this.renderer.blockquote(s);
          continue
        }
        case 'list': {
          i += this.renderer.list(s);
          continue
        }
        case 'html': {
          i += this.renderer.html(s);
          continue
        }
        case 'paragraph': {
          i += this.renderer.paragraph(s);
          continue
        }
        case 'text': {
          let a = s, l = this.renderer.text(a);
          for (; r + 1 < t.length && t[r + 1].type === 'text';)
            a = t[++r], l += `
` + this.renderer.text(a);
          e ? i += this.renderer.paragraph({
            type: 'paragraph',
            raw: l,
            text: l,
            tokens: [{type: 'text', raw: l, text: l, escaped: !0}]
          }) :
              i += l;
          continue
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), '';
          throw new Error(a)
        }
      }
    }
    return i
  }
  parseInline(t, e = this.renderer) {
    let i = '';
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      if (this.options.extensions?.renderers?.[o.type]) {
        let a =
            this.options.extensions.renderers[o.type].call({parser: this}, o);
        if (a !== !1 ||
            !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan',
              'br', 'del', 'text']
                 .includes(o.type)) {
          i += a || '';
          continue
        }
      }
      let s = o;
      switch (s.type) {
        case 'escape': {
          i += e.text(s);
          break
        }
        case 'html': {
          i += e.html(s);
          break
        }
        case 'link': {
          i += e.link(s);
          break
        }
        case 'image': {
          i += e.image(s);
          break
        }
        case 'strong': {
          i += e.strong(s);
          break
        }
        case 'em': {
          i += e.em(s);
          break
        }
        case 'codespan': {
          i += e.codespan(s);
          break
        }
        case 'br': {
          i += e.br(s);
          break
        }
        case 'del': {
          i += e.del(s);
          break
        }
        case 'text': {
          i += e.text(s);
          break
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), '';
          throw new Error(a)
        }
      }
    }
    return i
  }
}
, ya = class {
  options;
  block;
  constructor(t) {
    this.options = t || Uo
  }
  static passThroughHooks =
      new Set(['preprocess', 'postprocess', 'processAllTokens']);
  preprocess(t) {
    return t
  }
  postprocess(t) {
    return t
  }
  processAllTokens(t) {
    return t
  }
  provideLexer() {
    return this.block ? qn.lex : qn.lexInline
  }
  provideParser() {
    return this.block ? Gn.parse : Gn.parseInline
  }
}
, cv = class {
  defaults = dv();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = Gn;
  Renderer = ki;
  TextRenderer = hc;
  Lexer = qn;
  Tokenizer = wa;
  Hooks = ya;
  constructor(...t) {
    this.use(...t)
  }
  walkTokens(t, e) {
    let i = [];
    for (let r of t) switch (i = i.concat(e.call(this, r)), r.type) {
        case 'table': {
          let o = r;
          for (let s of o.header) i = i.concat(this.walkTokens(s.tokens, e));
          for (let s of o.rows)
            for (let a of s) i = i.concat(this.walkTokens(a.tokens, e));
          break
        }
        case 'list': {
          let o = r;
          i = i.concat(this.walkTokens(o.items, e));
          break
        }
        default: {
          let o = r;
          this.defaults.extensions?.childTokens?.[o.type] ?
              this.defaults.extensions.childTokens[o.type].forEach(s => {
                let a = o[s].flat(1 / 0);
                i = i.concat(this.walkTokens(a, e))
              }) :
              o.tokens && (i = i.concat(this.walkTokens(o.tokens, e)))
        }
      }
    return i
  }
  use(...t) {
    let e = this.defaults.extensions || {renderers: {}, childTokens: {}};
    return t.forEach(i => {
      let r = y({}, i);
      if (r.async = this.defaults.async || r.async || !1,
          i.extensions &&
              (i.extensions.forEach(o => {
                if (!o.name) throw new Error('extension name required');
                if ('renderer' in o) {
                  let s = e.renderers[o.name];
                  s ? e.renderers[o.name] = function(...a) {
                    let l = o.renderer.apply(this, a);
                    return l === !1 && (l = s.apply(this, a)), l
                  } : e.renderers[o.name] = o.renderer
                }
                if ('tokenizer' in o) {
                  if (!o.level || o.level !== 'block' && o.level !== 'inline')
                    throw new Error(
                        'extension level must be \'block\' or \'inline\'');
                  let s = e[o.level];
                  s ? s.unshift(o.tokenizer) : e[o.level] = [o.tokenizer],
                                               o.start &&
                      (o.level === 'block' ? e.startBlock ?
                                             e.startBlock.push(o.start) :
                                             e.startBlock = [o.start] :
                                             o.level === 'inline' &&
                               (e.startInline ? e.startInline.push(o.start) :
                                                e.startInline = [o.start]))
                }
                'childTokens' in o && o.childTokens &&
                    (e.childTokens[o.name] = o.childTokens)
              }),
               r.extensions = e),
          i.renderer) {
        let o = this.defaults.renderer || new ki(this.defaults);
        for (let s in i.renderer) {
          if (!(s in o)) throw new Error(`renderer '${s}' does not exist`);
          if (['options', 'parser'].includes(s)) continue;
          let a = s, l = i.renderer[a], c = o[a];
          o[a] = (...d) => {
            let m = l.apply(o, d);
            return m === !1 && (m = c.apply(o, d)), m || ''
          }
        }
        r.renderer = o
      }
      if (i.tokenizer) {
        let o = this.defaults.tokenizer || new wa(this.defaults);
        for (let s in i.tokenizer) {
          if (!(s in o)) throw new Error(`tokenizer '${s}' does not exist`);
          if (['options', 'rules', 'lexer'].includes(s)) continue;
          let a = s, l = i.tokenizer[a], c = o[a];
          o[a] = (...d) => {
            let m = l.apply(o, d);
            return m === !1 && (m = c.apply(o, d)), m
          }
        }
        r.tokenizer = o
      }
      if (i.hooks) {
        let o = this.defaults.hooks || new ya;
        for (let s in i.hooks) {
          if (!(s in o)) throw new Error(`hook '${s}' does not exist`);
          if (['options', 'block'].includes(s)) continue;
          let a = s, l = i.hooks[a], c = o[a];
          ya.passThroughHooks.has(s) ? o[a] = d => {
            if (this.defaults.async)
              return Promise.resolve(l.call(o, d)).then(p => c.call(o, p));
            let m = l.call(o, d);
            return c.call(o, m)
          } : o[a] = (...d) => {
            let m = l.apply(o, d);
            return m === !1 && (m = c.apply(o, d)), m
          }
        }
        r.hooks = o
      }
      if (i.walkTokens) {
        let o = this.defaults.walkTokens, s = i.walkTokens;
        r.walkTokens = function(a) {
          let l = [];
          return l.push(s.call(this, a)), o && (l = l.concat(o.call(this, a))),
                 l
        }
      }
      this.defaults = y(y({}, this.defaults), r)
    }),
           this
  }
  setOptions(t) {
    return this.defaults = y(y({}, this.defaults), t), this
  }
  lexer(t, e) {
    return qn.lex(t, e ?? this.defaults)
  }
  parser(t, e) {
    return Gn.parse(t, e ?? this.defaults)
  }
  parseMarkdown(t) {
    return (i, r) => {
      let o = y({}, r), s = y(y({}, this.defaults), o),
          a = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === !0 && o.async === !1)
        return a(new Error(
            'marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
      if (typeof i > 'u' || i === null)
        return a(new Error('marked(): input parameter is undefined or null'));
      if (typeof i != 'string')
        return a(new Error(
            'marked(): input parameter is of type ' +
            Object.prototype.toString.call(i) + ', string expected'));
      s.hooks && (s.hooks.options = s, s.hooks.block = t);
      let l = s.hooks ? s.hooks.provideLexer() :
          t           ? qn.lex :
                        qn.lexInline,
          c = s.hooks ? s.hooks.provideParser() :
          t           ? Gn.parse :
                        Gn.parseInline;
      if (s.async)
        return Promise.resolve(s.hooks ? s.hooks.preprocess(i) : i)
            .then(d => l(d, s))
            .then(d => s.hooks ? s.hooks.processAllTokens(d) : d)
            .then(
                d => s.walkTokens ?
                    Promise.all(this.walkTokens(d, s.walkTokens))
                        .then(() => d) :
                    d)
            .then(d => c(d, s))
            .then(d => s.hooks ? s.hooks.postprocess(d) : d)
            .catch(a);
      try {
        s.hooks && (i = s.hooks.preprocess(i));
        let d = l(i, s);
        s.hooks && (d = s.hooks.processAllTokens(d)),
            s.walkTokens && this.walkTokens(d, s.walkTokens);
        let m = c(d, s);
        return s.hooks && (m = s.hooks.postprocess(m)), m
      } catch (d) {
        return a(d)
      }
    }
  }
  onError(t, e) {
    return i => {
      if (i.message += `
Please report this to https://github.com/markedjs/marked.`,
          t) {
        let r = '<p>An error occurred:</p><pre>' + Ei(i.message + '', !0) +
            '</pre>';
        return e ? Promise.resolve(r) : r
      }
      if (e) return Promise.reject(i);
      throw i
    }
  }
}
, Ho = new cv;
function Fe(n, t) {
  return Ho.parse(n, t)
}
Fe.options = Fe.setOptions = function(n) {
  return Ho.setOptions(n), Fe.defaults = Ho.defaults, oI(Fe.defaults), Fe
};
Fe.getDefaults = dv;
Fe.defaults = Uo;
Fe.use = function(...n) {
  return Ho.use(...n), Fe.defaults = Ho.defaults, oI(Fe.defaults), Fe
};
Fe.walkTokens = function(n, t) {
  return Ho.walkTokens(n, t)
};
Fe.parseInline = Ho.parseInline;
Fe.Parser = Gn;
Fe.parser = Gn.parse;
Fe.Renderer = ki;
Fe.TextRenderer = hc;
Fe.Lexer = qn;
Fe.lexer = qn.lex;
Fe.Tokenizer = wa;
Fe.Hooks = ya;
Fe.parse = Fe;
var qne = Fe.options, Gne = Fe.setOptions, Qne = Fe.use, Yne = Fe.walkTokens,
    Zne = Fe.parseInline;
var Kne = Gn.parse, Xne = qn.lex;
var iH = ['*'], rH = 'Copy', oH = 'Copied',
    sH = (() => {
      class n {
        constructor() {
          this._buttonClick$ = new I,
          this.copied$ = this._buttonClick$.pipe(
              $e(() => Ke(G(!0), io(3e3).pipe(as (!1)))), Rn(), Ni(1)),
          this.copiedText$ = this.copied$.pipe(Xe(!1), Q(e => e ? oH : rH))
        }
        onCopyToClipboardClick() {
          this._buttonClick$.next()
        }
        static {
          this.\u0275fac = function(i) {
            return new (i || n)
          }
        }
        static {
          this.\u0275cmp = O({
            type: n,
            selectors: [['markdown-clipboard']],
            decls: 4,
            vars: 7,
            consts: [[1, 'markdown-clipboard-button', 3, 'click']],
            template: function(i, r) {
              i&1 &&
                  (f(0, 'button', 0), Cr(1, 'async'),
                   M('click',
                     function() {
                       return r.onCopyToClipboardClick()
                     }),
                   E(2), Cr(3, 'async'), g()),
                  i&2 &&
                  (Y('copied', As(1, 3, r.copied$)), b(2),
                   Re(As(3, 5, r.copiedText$)))
            },
            dependencies: [Fu],
            encapsulation: 2,
            changeDetection: 0
          })
        }
      } return n
    })(),
    aH = new w('CLIPBOARD_OPTIONS');
var bv =
        function(n) {
  return n.CommandLine = 'command-line', n.LineHighlight = 'line-highlight',
         n.LineNumbers = 'line-numbers', n
}(bv || {}),
    gI = new w('MARKED_EXTENSIONS'), lH = new w('MARKED_OPTIONS'),
    cH = new w('MERMAID_OPTIONS'),
    dH =
        '[ngx-markdown] When using the `emoji` attribute you *have to* include Emoji-Toolkit files to `angular.json` or use imports. See README for more information',
    uH =
        '[ngx-markdown] When using the `katex` attribute you *have to* include KaTeX files to `angular.json` or use imports. See README for more information',
    mH =
        '[ngx-markdown] When using the `mermaid` attribute you *have to* include Mermaid files to `angular.json` or use imports. See README for more information',
    hH =
        '[ngx-markdown] When using the `clipboard` attribute you *have to* include Clipboard files to `angular.json` or use imports. See README for more information',
    fH =
        '[ngx-markdown] When using the `clipboard` attribute you *have to* provide the `viewContainerRef` parameter to `MarkdownService.render()` function',
    pH =
        '[ngx-markdown] When using the `src` attribute you *have to* pass the `HttpClient` as a parameter of the `forRoot` method. See README for more information',
    _I = new w('SECURITY_CONTEXT');
var bI = (() => {
  class n {
    get options() {
      return this._options
    }
    set options(e) {
      this._options = y(y({}, this.DEFAULT_MARKED_OPTIONS), e)
    }
    get renderer() {
      return this.options.renderer
    }
    set renderer(e) {
      this.options.renderer = e
    }
    constructor(e, i, r, o, s, a, l, c) {
      this.clipboardOptions = e, this.extensions = i, this.mermaidOptions = o,
      this.platform = s, this.securityContext = a, this.http = l,
      this.sanitizer = c, this.DEFAULT_MARKED_OPTIONS = {renderer: new ki},
      this.DEFAULT_KATEX_OPTIONS = {
        delimiters: [
          {left: '$$', right: '$$', display: !0},
          {left: '$', right: '$', display: !1},
          {left: '\\(', right: '\\)', display: !1},
          {left: '\\begin{equation}', right: '\\end{equation}', display: !0},
          {left: '\\begin{align}', right: '\\end{align}', display: !0},
          {left: '\\begin{alignat}', right: '\\end{alignat}', display: !0},
          {left: '\\begin{gather}', right: '\\end{gather}', display: !0},
          {left: '\\begin{CD}', right: '\\end{CD}', display: !0},
          {left: '\\[', right: '\\]', display: !0}
        ]
      },
      this.DEFAULT_MERMAID_OPTIONS = {startOnLoad: !1},
      this.DEFAULT_CLIPBOARD_OPTIONS = {buttonComponent: void 0},
      this.DEFAULT_PARSE_OPTIONS = {
        decodeHtml: !1,
        inline: !1,
        emoji: !1,
        mermaid: !1,
        markedOptions: void 0,
        disableSanitizer: !1
      },
      this.DEFAULT_RENDER_OPTIONS = {
        clipboard: !1,
        clipboardOptions: void 0,
        katex: !1,
        katexOptions: void 0,
        mermaid: !1,
        mermaidOptions: void 0
      },
      this._reload$ = new I, this.reload$ = this._reload$.asObservable(),
      this.options = r
    }
    parse(e, i = this.DEFAULT_PARSE_OPTIONS) {
      let {
        decodeHtml: r,
        inline: o,
        emoji: s,
        mermaid: a,
        disableSanitizer: l
      } = i,
     c = y(y({}, this.options), i.markedOptions),
     d = c.renderer || this.renderer || new ki;
      this.extensions && (this.renderer = this.extendsRendererForExtensions(d)),
          a && (this.renderer = this.extendsRendererForMermaid(d));
      let m = this.trimIndentation(e), p = r ? this.decodeHtml(m) : m,
          h = s ? this.parseEmoji(p) : p, _ = this.parseMarked(h, c, o);
      return (l ? _ : this.sanitizer.sanitize(this.securityContext, _)) || ''
    }
    render(e, i = this.DEFAULT_RENDER_OPTIONS, r) {
      let {
        clipboard: o,
        clipboardOptions: s,
        katex: a,
        katexOptions: l,
        mermaid: c,
        mermaidOptions: d
      } = i;
      a && this.renderKatex(e, y(y({}, this.DEFAULT_KATEX_OPTIONS), l)),
          c &&
          this.renderMermaid(
              e,
              y(y(y({}, this.DEFAULT_MERMAID_OPTIONS), this.mermaidOptions),
                d)),
          o &&
          this.renderClipboard(
              e, r,
              y(y(y({}, this.DEFAULT_CLIPBOARD_OPTIONS), this.clipboardOptions),
                s)),
          this.highlight(e)
    }
    reload() {
      this._reload$.next()
    }
    getSource(e) {
      if (!this.http) throw new Error(pH);
      return this.http.get(e, {responseType: 'text'})
          .pipe(Q(i => this.handleExtension(e, i)))
    }
    highlight(e) {
      if (!qi(this.platform) || typeof Prism > 'u' ||
          typeof Prism.highlightAllUnder > 'u')
        return;
      e || (e = document);
      let i = e.querySelectorAll('pre code:not([class*="language-"])');
      Array.prototype.forEach.call(i, r => r.classList.add('language-none')),
          Prism.highlightAllUnder(e)
    }
    decodeHtml(e) {
      if (!qi(this.platform)) return e;
      let i = document.createElement('textarea');
      return i.innerHTML = e, i.value
    }
    extendsRendererForExtensions(e) {
      let i = e;
      return i.\u0275NgxMarkdownRendererExtendedForExtensions === !0 ||
                 (this.extensions?.length > 0 && Fe.use(...this.extensions),
                  i.\u0275NgxMarkdownRendererExtendedForExtensions = !0),
             e
    }
    extendsRendererForMermaid(e) {
      let i = e;
      if (i.\u0275NgxMarkdownRendererExtendedForMermaid === !0) return e;
      let r = e.code;
      return e.code = o => o.lang === 'mermaid' ?
                 `<div class="mermaid">${o.text}</div>` :
                 r(o),
             i.\u0275NgxMarkdownRendererExtendedForMermaid = !0, e
    }
    handleExtension(e, i) {
      let r = e.lastIndexOf('://'), o = r > -1 ? e.substring(r + 4) : e,
          s = o.lastIndexOf('/'),
          a = s > -1 ? o.substring(s + 1).split('?')[0] : '',
          l = a.lastIndexOf('.'), c = l > -1 ? a.substring(l + 1) : '';
      return c && c !== 'md' ? '```' + c + `
` + i + '\n```' :
                               i
    }
    parseMarked(e, i, r = !1) {
      if (i.renderer) {
        let o = y({}, i.renderer);
        delete o.\u0275NgxMarkdownRendererExtendedForExtensions,
            delete o.\u0275NgxMarkdownRendererExtendedForMermaid,
            delete i.renderer, Fe.use({renderer: o})
      }
      return r ? Fe.parseInline(e, i) : Fe.parse(e, i)
    }
    parseEmoji(e) {
      if (!qi(this.platform)) return e;
      if (typeof joypixels > 'u' || typeof joypixels.shortnameToUnicode > 'u')
        throw new Error(dH);
      return joypixels.shortnameToUnicode(e)
    }
    renderKatex(e, i) {
      if (qi(this.platform)) {
        if (typeof katex > 'u' || typeof renderMathInElement > 'u')
          throw new Error(uH);
        renderMathInElement(e, i)
      }
    }
    renderClipboard(e, i, r) {
      if (!qi(this.platform)) return;
      if (typeof ClipboardJS > 'u') throw new Error(hH);
      if (!i) throw new Error(fH);
      let {buttonComponent: o, buttonTemplate: s} = r,
                                               a = e.querySelectorAll('pre');
      for (let l = 0; l < a.length; l++) {
        let c = a.item(l), d = document.createElement('div');
        d.style.position = 'relative', c.parentNode.insertBefore(d, c),
        d.appendChild(c);
        let m = document.createElement('div');
        m.classList.add('markdown-clipboard-toolbar'),
            m.style.position = 'absolute', m.style.top = '.5em',
            m.style.right = '.5em', m.style.zIndex = '1',
            d.insertAdjacentElement('beforeend', m),
            d.onmouseenter = () => m.classList.add('hover'),
            d.onmouseleave = () => m.classList.remove('hover');
        let p;
        if (o) {
          let _ = i.createComponent(o);
          p = _.hostView, _.changeDetectorRef.markForCheck()
        } else if (s)
          p = i.createEmbeddedView(s);
        else {
          let _ = i.createComponent(sH);
          p = _.hostView, _.changeDetectorRef.markForCheck()
        }
        let h;
        p.rootNodes.forEach(_ => {
          m.appendChild(_),
          h = new ClipboardJS(_, {text: () => c.innerText})
        }),
            p.onDestroy(() => h.destroy())
      }
    }
    renderMermaid(e, i = this.DEFAULT_MERMAID_OPTIONS) {
      if (!qi(this.platform)) return;
      if (typeof mermaid > 'u' || typeof mermaid.initialize > 'u')
        throw new Error(mH);
      let r = e.querySelectorAll('.mermaid');
      r.length !== 0 && (mermaid.initialize(i), mermaid.run({nodes: r}))
    }
    trimIndentation(e) {
      if (!e) return '';
      let i;
      return e
          .split(`
`)
          .map(r => {
            let o = i;
            return r.length > 0 &&
                       (o = isNaN(o) ? r.search(/\S|$/) :
                                       Math.min(r.search(/\S|$/), o)),
                   isNaN(i) && (i = o), o ? r.substring(o) : r
          })
          .join(`
`)
    }
    static {
      this.\u0275fac = function(i) {
        return new (i || n)(
            A(aH, 8), A(gI, 8), A(lH, 8), A(cH, 8), A(Fn), A(_I), A(zt, 8),
            A(bl))
      }
    }
    static {
      this.\u0275prov = C({token: n, factory: n.\u0275fac})
    }
  } return n
})(),
    vI = (() => {
      class n {
        get disableSanitizer() {
          return this._disableSanitizer
        }
        set disableSanitizer(e) {
          this._disableSanitizer = this.coerceBooleanProperty(e)
        }
        get inline() {
          return this._inline
        }
        set inline(e) {
          this._inline = this.coerceBooleanProperty(e)
        }
        get clipboard() {
          return this._clipboard
        }
        set clipboard(e) {
          this._clipboard = this.coerceBooleanProperty(e)
        }
        get emoji() {
          return this._emoji
        }
        set emoji(e) {
          this._emoji = this.coerceBooleanProperty(e)
        }
        get katex() {
          return this._katex
        }
        set katex(e) {
          this._katex = this.coerceBooleanProperty(e)
        }
        get mermaid() {
          return this._mermaid
        }
        set mermaid(e) {
          this._mermaid = this.coerceBooleanProperty(e)
        }
        get lineHighlight() {
          return this._lineHighlight
        }
        set lineHighlight(e) {
          this._lineHighlight = this.coerceBooleanProperty(e)
        }
        get lineNumbers() {
          return this._lineNumbers
        }
        set lineNumbers(e) {
          this._lineNumbers = this.coerceBooleanProperty(e)
        }
        get commandLine() {
          return this._commandLine
        }
        set commandLine(e) {
          this._commandLine = this.coerceBooleanProperty(e)
        }
        constructor(e, i, r) {
          this.element = e, this.markdownService = i, this.viewContainerRef = r,
          this.error = new H, this.load = new H, this.ready = new H,
          this._clipboard = !1, this._commandLine = !1,
          this._disableSanitizer = !1, this._emoji = !1, this._inline = !1,
          this._katex = !1, this._lineHighlight = !1, this._lineNumbers = !1,
          this._mermaid = !1, this.destroyed$ = new I
        }
        ngOnChanges() {
          this.loadContent()
        }
        loadContent() {
          if (this.data != null) {
            this.handleData();
            return
          }
          if (this.src != null) {
            this.handleSrc();
            return
          }
        }
        ngAfterViewInit() {
          !this.data && !this.src && this.handleTransclusion(),
              this.markdownService.reload$.pipe(re(this.destroyed$))
                  .subscribe(() => this.loadContent())
        }
        ngOnDestroy() {
          this.destroyed$.next(), this.destroyed$.complete()
        }
        render(e, i = !1) {
          return Tt(this, null, function*() {
            let r = {
              decodeHtml: i,
              inline: this.inline,
              emoji: this.emoji,
              mermaid: this.mermaid,
              disableSanitizer: this.disableSanitizer
            },
                o = {
                  clipboard: this.clipboard,
                  clipboardOptions: this.getClipboardOptions(),
                  katex: this.katex,
                  katexOptions: this.katexOptions,
                  mermaid: this.mermaid,
                  mermaidOptions: this.mermaidOptions
                },
                s = yield this.markdownService.parse(e, r);
            this.element.nativeElement.innerHTML = s, this.handlePlugins(),
            this.markdownService.render(
                this.element.nativeElement, o, this.viewContainerRef),
            this.ready.emit()
          })
        }
        coerceBooleanProperty(e) {
          return e != null && `${String(e)}` != 'false'
        }
        getClipboardOptions() {
          if (this.clipboardButtonComponent || this.clipboardButtonTemplate)
            return {
              buttonComponent: this.clipboardButtonComponent,
                  buttonTemplate: this.clipboardButtonTemplate
            }
        }
        handleData() {
          this.render(this.data)
        }
        handleSrc() {
          this.markdownService.getSource(this.src).subscribe({
            next: e => {this.render(e).then(() => {this.load.emit(e)})},
            error: e => this.error.emit(e)
          })
        }
        handleTransclusion() {
          this.render(this.element.nativeElement.innerHTML, !0)
        }
        handlePlugins() {
          this.commandLine &&
              (this.setPluginClass(this.element.nativeElement, bv.CommandLine),
               this.setPluginOptions(this.element.nativeElement, {
                 dataFilterOutput: this.filterOutput,
                 dataHost: this.host,
                 dataPrompt: this.prompt,
                 dataOutput: this.output,
                 dataUser: this.user
               })),
              this.lineHighlight &&
              this.setPluginOptions(
                  this.element.nativeElement,
                  {dataLine: this.line, dataLineOffset: this.lineOffset}),
              this.lineNumbers &&
              (this.setPluginClass(this.element.nativeElement, bv.LineNumbers),
               this.setPluginOptions(
                   this.element.nativeElement, {dataStart: this.start}))
        }
        setPluginClass(e, i) {
          let r = e.querySelectorAll('pre');
          for (let o = 0; o < r.length; o++) {
            let s = i instanceof Array ? i : [i];
            r.item(o).classList.add(...s)
          }
        }
        setPluginOptions(e, i) {
          let r = e.querySelectorAll('pre');
          for (let o = 0; o < r.length; o++)
            Object.keys(i).forEach(s => {
              let a = i[s];
              if (a) {
                let l = this.toLispCase(s);
                r.item(o).setAttribute(l, a.toString())
              }
            })
        }
        toLispCase(e) {
          let i = e.match(/([A-Z])/g);
          if (!i) return e;
          let r = e.toString();
          for (let o = 0, s = i.length; o < s; o++)
            r = r.replace(new RegExp(i[o]), '-' + i[o].toLowerCase());
          return r.slice(0, 1) === '-' && (r = r.slice(1)), r
        }
        static {
          this.\u0275fac = function(i) {
            return new (i || n)(z(L), z(bI), z(Ge))
          }
        }
        static {
          this.\u0275cmp = O({
            type: n,
            selectors: [['markdown'], ['', 'markdown', '']],
            inputs: {
              data: 'data',
              src: 'src',
              disableSanitizer: 'disableSanitizer',
              inline: 'inline',
              clipboard: 'clipboard',
              clipboardButtonComponent: 'clipboardButtonComponent',
              clipboardButtonTemplate: 'clipboardButtonTemplate',
              emoji: 'emoji',
              katex: 'katex',
              katexOptions: 'katexOptions',
              mermaid: 'mermaid',
              mermaidOptions: 'mermaidOptions',
              lineHighlight: 'lineHighlight',
              line: 'line',
              lineOffset: 'lineOffset',
              lineNumbers: 'lineNumbers',
              start: 'start',
              commandLine: 'commandLine',
              filterOutput: 'filterOutput',
              host: 'host',
              prompt: 'prompt',
              output: 'output',
              user: 'user'
            },
            outputs: {error: 'error', load: 'load', ready: 'ready'},
            features: [Pe],
            ngContentSelectors: iH,
            decls: 1,
            vars: 0,
            template: function(i, r) {
              i&1 && (Se(), Z(0))
            },
            encapsulation: 2
          })
        }
      } return n
    })();
function gH(n) {
  return [
    bI, n?.loader ?? [], n?.clipboardOptions ?? [], n?.markedOptions ?? [],
    n?.mermaidOptions ?? [], bH(n?.markedExtensions) ?? [],
    {provide: _I, useValue: n?.sanitize ?? Et.HTML}
  ]
}
function _H(n) {
  return n != null && n.provide != null
}
function bH(n) {
  if (n)
    return n.reduce((t, e) => {
      let i = _H(e) ? ae(y({}, e), {multi: !0}) :
                      {provide: gI, useValue: e, multi: !0};
      return [...t, i]
    }, [])
}
var yI = (() => {
  class n {
    static forRoot(e) {
      return {
        ngModule: n, providers: [gH(e)]
      }
    }
    static forChild() {
      return {
        ngModule: n
      }
    }
    static {
      this.\u0275fac = function(i) {
        return new (i || n)
      }
    }
    static {
      this.\u0275mod = j({type: n})
    }
    static {
      this.\u0275inj = V({imports: [Er]})
    }
  } return n
})();
var wH = ['switch'], xH = ['*'];
function CH(n, t) {
  n&1 &&
      (f(0, 'span', 10), Bt(), f(1, 'svg', 12), B(2, 'path', 13), g(),
       f(3, 'svg', 14), B(4, 'path', 15), g()())
}
var DH = new w('mat-slide-toggle-default-options', {
  providedIn: 'root',
  factory: () =>
      ({disableToggleValue: !1, hideIcon: !1, disabledInteractive: !1})
}),
    EH = {provide: Ro, useExisting: Zt(() => Ch), multi: !0}, xh = class {
  source;
  checked;
  constructor(t, e) {
    this.source = t, this.checked = e
  }
}
, Ch = (() => {
    class n {
      _elementRef = u(L);
      _focusMonitor = u(xn);
      _changeDetectorRef = u(Ae);
      defaults = u(DH);
      _onChange = e => {};
      _onTouched = () => {};
      _validatorOnChange = () => {};
      _uniqueId;
      _checked = !1;
      _createChangeEvent(e) {
        return new xh(this, e)
      }
      _labelId;
      get buttonId() {
        return `${this.id || this._uniqueId}-button`
      }
      _switchElement;
      focus() {
        this._switchElement.nativeElement.focus()
      }
      _noopAnimations;
      _focused;
      name = null;
      id;
      labelPosition = 'after';
      ariaLabel = null;
      ariaLabelledby = null;
      ariaDescribedby;
      required;
      color;
      disabled = !1;
      disableRipple = !1;
      tabIndex = 0;
      get checked() {
        return this._checked
      }
      set checked(e) {
        this._checked = e, this._changeDetectorRef.markForCheck()
      }
      hideIcon;
      disabledInteractive;
      change = new H;
      toggleChange = new H;
      get inputId() {
        return `${this.id || this._uniqueId}-input`
      }
      constructor() {
        u(lt).load($n);
        let e = u(new Qt('tabindex'), {optional: !0}), i = this.defaults,
            r = u(Ve, {optional: !0});
        this.tabIndex = e == null ? 0 : parseInt(e) || 0,
        this.color = i.color || 'accent',
        this._noopAnimations = r === 'NoopAnimations',
        this.id = this._uniqueId = u(et).getId('mat-mdc-slide-toggle-'),
        this.hideIcon = i.hideIcon ?? !1,
        this.disabledInteractive = i.disabledInteractive ?? !1,
        this._labelId = this._uniqueId + '-label'
      }
      ngAfterContentInit() {
        this._focusMonitor.monitor(this._elementRef, !0)
            .subscribe(
                e => {
                    e === 'keyboard' || e === 'program' ?
                        (this._focused = !0,
                         this._changeDetectorRef.markForCheck()) :
                        e || Promise.resolve().then(() => {
                          this._focused = !1,
                          this._onTouched(),
                          this._changeDetectorRef.markForCheck()
                        })})
      }
      ngOnChanges(e) {
        e.required && this._validatorOnChange()
      }
      ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef)
      }
      writeValue(e) {
        this.checked = !!e
      }
      registerOnChange(e) {
        this._onChange = e
      }
      registerOnTouched(e) {
        this._onTouched = e
      }
      validate(e) {
        return this.required && e.value !== !0 ? {required: !0} : null
      }
      registerOnValidatorChange(e) {
        this._validatorOnChange = e
      }
      setDisabledState(e) {
        this.disabled = e, this._changeDetectorRef.markForCheck()
      }
      toggle() {
        this.checked = !this.checked, this._onChange(this.checked)
      }
      _emitChangeEvent() {
        this._onChange(this.checked),
            this.change.emit(this._createChangeEvent(this.checked))
      }
      _handleClick() {
        this.disabled ||
            (this.toggleChange.emit(),
             this.defaults.disableToggleValue ||
                 (this.checked = !this.checked, this._onChange(this.checked),
                  this.change.emit(new xh(this, this.checked))))
      }
      _getAriaLabelledBy() {
        return this.ariaLabelledby ? this.ariaLabelledby :
            this.ariaLabel         ? null :
                                     this._labelId
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275cmp = O({
        type: n,
        selectors: [['mat-slide-toggle']],
        viewQuery: function(i, r) {
          if (i & 1 && oe(wH, 5), i & 2) {
            let o;
            $(o = W()) && (r._switchElement = o.first)
          }
        },
        hostAttrs: [1, 'mat-mdc-slide-toggle'],
        hostVars: 13,
        hostBindings: function(i, r) {
          i&2 &&
              (en('id', r.id),
               J('tabindex', null)('aria-label', null)('name', null)(
                   'aria-labelledby', null),
               kt(r.color ? 'mat-' + r.color : ''),
               Y('mat-mdc-slide-toggle-focused', r._focused)(
                   'mat-mdc-slide-toggle-checked', r.checked)(
                   '_mat-animation-noopable', r._noopAnimations))
        },
        inputs: {
          name: 'name',
          id: 'id',
          labelPosition: 'labelPosition',
          ariaLabel: [0, 'aria-label', 'ariaLabel'],
          ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby'],
          ariaDescribedby: [0, 'aria-describedby', 'ariaDescribedby'],
          required: [2, 'required', 'required', q],
          color: 'color',
          disabled: [2, 'disabled', 'disabled', q],
          disableRipple: [2, 'disableRipple', 'disableRipple', q],
          tabIndex: [2, 'tabIndex', 'tabIndex', e => e == null ? 0 : st(e)],
          checked: [2, 'checked', 'checked', q],
          hideIcon: [2, 'hideIcon', 'hideIcon', q],
          disabledInteractive:
              [2, 'disabledInteractive', 'disabledInteractive', q]
        },
        outputs: {change: 'change', toggleChange: 'toggleChange'},
        exportAs: ['matSlideToggle'],
        features: [ye([EH, {provide: Mr, useExisting: n, multi: !0}]), Pe],
        ngContentSelectors: xH,
        decls: 13,
        vars: 27,
        consts: [
          ['switch', ''], ['mat-internal-form-field', '', 3, 'labelPosition'],
          [
            'role', 'switch', 'type', 'button', 1, 'mdc-switch', 3, 'click',
            'tabIndex', 'disabled'
          ],
          [1, 'mdc-switch__track'], [1, 'mdc-switch__handle-track'],
          [1, 'mdc-switch__handle'], [1, 'mdc-switch__shadow'],
          [1, 'mdc-elevation-overlay'], [1, 'mdc-switch__ripple'],
          [
            'mat-ripple', '', 1, 'mat-mdc-slide-toggle-ripple',
            'mat-focus-indicator', 3, 'matRippleTrigger', 'matRippleDisabled',
            'matRippleCentered'
          ],
          [1, 'mdc-switch__icons'], [1, 'mdc-label', 3, 'click', 'for'],
          [
            'viewBox', '0 0 24 24', 'aria-hidden', 'true', 1,
            'mdc-switch__icon', 'mdc-switch__icon--on'
          ],
          [
            'd',
            'M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z'
          ],
          [
            'viewBox', '0 0 24 24', 'aria-hidden', 'true', 1,
            'mdc-switch__icon', 'mdc-switch__icon--off'
          ],
          ['d', 'M20 13H4v-2h16v2z']
        ],
        template: function(i, r) {
          if (i & 1) {
            let o = ee();
            Se(), f(0, 'div', 1)(1, 'button', 2, 0),
                M('click',
                  function() {
                    return N(o), P(r._handleClick())
                  }),
                B(3, 'span', 3), f(4, 'span', 4)(5, 'span', 5)(6, 'span', 6),
                B(7, 'span', 7), g(), f(8, 'span', 8), B(9, 'span', 9), g(),
                R(10, CH, 5, 0, 'span', 10), g()()(), f(11, 'label', 11),
                M('click', function(a) {
                  return N(o), P(a.stopPropagation())
                }), Z(12), g()()
          }
          if (i & 2) {
            let o = yt(2);
            x('labelPosition', r.labelPosition), b(),
                Y('mdc-switch--selected', r.checked)(
                    'mdc-switch--unselected', !r.checked)(
                    'mdc-switch--checked', r.checked)(
                    'mdc-switch--disabled', r.disabled)(
                    'mat-mdc-slide-toggle-disabled-interactive',
                    r.disabledInteractive),
                x('tabIndex',
                  r.disabled && !r.disabledInteractive ? -1 : r.tabIndex)(
                    'disabled', r.disabled && !r.disabledInteractive),
                J('id', r.buttonId)('name', r.name)('aria-label', r.ariaLabel)(
                    'aria-labelledby', r._getAriaLabelledBy())(
                    'aria-describedby', r.ariaDescribedby)(
                    'aria-required', r.required || null)(
                    'aria-checked', r.checked)(
                    'aria-disabled',
                    r.disabled && r.disabledInteractive ? 'true' : null),
                b(8),
                x('matRippleTrigger', o)(
                    'matRippleDisabled', r.disableRipple || r.disabled)(
                    'matRippleCentered', !0),
                b(), de(r.hideIcon ? -1 : 10), b(), x('for', r.buttonId),
                J('id', r._labelId)
          }
        },
        dependencies: [Fr, Qm],
        styles: [
          '.mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative;width:var(--mdc-switch-track-width, 52px)}.mdc-switch.mdc-switch--disabled{cursor:default;pointer-events:none}.mdc-switch.mat-mdc-slide-toggle-disabled-interactive{pointer-events:auto}.mdc-switch__track{overflow:hidden;position:relative;width:100%;height:var(--mdc-switch-track-height, 32px);border-radius:var(--mdc-switch-track-shape, var(--mat-sys-corner-full))}.mdc-switch--disabled.mdc-switch .mdc-switch__track{opacity:var(--mdc-switch-disabled-track-opacity, 0.12)}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;position:absolute;width:100%;border-width:var(--mat-switch-track-outline-width, 2px);border-color:var(--mat-switch-track-outline-color, var(--mat-sys-outline))}.mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track::after{border-width:var(--mat-switch-selected-track-outline-width, 2px);border-color:var(--mat-switch-selected-track-outline-color, transparent)}.mdc-switch--disabled .mdc-switch__track::before,.mdc-switch--disabled .mdc-switch__track::after{border-width:var(--mat-switch-disabled-unselected-track-outline-width, 2px);border-color:var(--mat-switch-disabled-unselected-track-outline-color, var(--mat-sys-on-surface))}@media(forced-colors: active){.mdc-switch__track{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0);background:var(--mdc-switch-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch--selected .mdc-switch__track::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::before{opacity:var(--mat-switch-hidden-track-opacity, 0);transition:var(--mat-switch-hidden-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::before{opacity:var(--mat-switch-visible-track-opacity, 1);transition:var(--mat-switch-visible-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-hover-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-focus-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mdc-switch-unselected-pressed-track-color, var(--mat-sys-surface-variant))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::before,.mdc-switch.mdc-switch--disabled .mdc-switch__track::before{background:var(--mdc-switch-disabled-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch__track::after{transform:translateX(-100%);background:var(--mdc-switch-selected-track-color, var(--mat-sys-primary))}[dir=rtl] .mdc-switch__track::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::after{transform:translateX(0)}.mdc-switch--selected .mdc-switch__track::after{opacity:var(--mat-switch-visible-track-opacity, 1);transition:var(--mat-switch-visible-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::after{opacity:var(--mat-switch-hidden-track-opacity, 0);transition:var(--mat-switch-hidden-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-hover-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-focus-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mdc-switch-selected-pressed-track-color, var(--mat-sys-primary))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::after,.mdc-switch.mdc-switch--disabled .mdc-switch__track::after{background:var(--mdc-switch-disabled-selected-track-color, var(--mat-sys-on-surface))}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0);width:calc(100% - var(--mdc-switch-handle-width))}[dir=rtl] .mdc-switch__handle-track{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto;transition:width 75ms cubic-bezier(0.4, 0, 0.2, 1),height 75ms cubic-bezier(0.4, 0, 0.2, 1),margin 75ms cubic-bezier(0.4, 0, 0.2, 1);width:var(--mdc-switch-handle-width);height:var(--mdc-switch-handle-height);border-radius:var(--mdc-switch-handle-shape, var(--mat-sys-corner-full))}[dir=rtl] .mdc-switch__handle{left:auto;right:0}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle{width:var(--mat-switch-unselected-handle-size, 16px);height:var(--mat-switch-unselected-handle-size, 16px);margin:var(--mat-switch-unselected-handle-horizontal-margin, 0 8px)}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-switch-unselected-with-icon-handle-horizontal-margin, 0 4px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle{width:var(--mat-switch-selected-handle-size, 24px);height:var(--mat-switch-selected-handle-size, 24px);margin:var(--mat-switch-selected-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-switch-selected-with-icon-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch__handle:has(.mdc-switch__icons){width:var(--mat-switch-with-icon-handle-size, 24px);height:var(--mat-switch-with-icon-handle-size, 24px)}.mat-mdc-slide-toggle .mdc-switch:active:not(.mdc-switch--disabled) .mdc-switch__handle{width:var(--mat-switch-pressed-handle-size, 28px);height:var(--mat-switch-pressed-handle-size, 28px)}.mat-mdc-slide-toggle .mdc-switch--selected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-switch-selected-pressed-handle-horizontal-margin, 0 22px)}.mat-mdc-slide-toggle .mdc-switch--unselected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-switch-unselected-pressed-handle-horizontal-margin, 0 2px)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__handle::after{opacity:var(--mat-switch-disabled-selected-handle-opacity, 1)}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__handle::after{opacity:var(--mat-switch-disabled-unselected-handle-opacity, 0.38)}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media(forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-selected-handle-color, var(--mat-sys-on-primary))}.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-hover-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-focus-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-selected-pressed-handle-color, var(--mat-sys-primary-container))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:hover:not(:focus):not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:focus:not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:active .mdc-switch__handle::after,.mdc-switch--selected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-selected-handle-color, var(--mat-sys-surface))}.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-unselected-handle-color, var(--mat-sys-outline))}.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-hover-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-focus-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-unselected-pressed-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-unselected-handle-color, var(--mat-sys-on-surface))}.mdc-switch__handle::before{background:var(--mdc-switch-handle-surface-color)}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation-shadow)}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__shadow,.mdc-switch.mdc-switch--disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation-shadow)}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1;width:var(--mdc-switch-state-layer-size, 40px);height:var(--mdc-switch-state-layer-size, 40px)}.mdc-switch__ripple::after{content:"";opacity:0}.mdc-switch--disabled .mdc-switch__ripple::after{display:none}.mat-mdc-slide-toggle-disabled-interactive .mdc-switch__ripple::after{display:block}.mdc-switch:hover .mdc-switch__ripple::after{opacity:.04;transition:75ms opacity cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mdc-switch .mdc-switch__ripple::after{opacity:.12}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:focus .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:active .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:hover:not(:focus) .mdc-switch__ripple::after,.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-pressed-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mdc-switch-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background:var(--mdc-switch-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background:var(--mdc-switch-selected-pressed-state-layer-color, var(--mat-sys-primary));opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch__icons{position:relative;height:100%;width:100%;z-index:1}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__icons{opacity:var(--mdc-switch-disabled-unselected-icon-opacity, 0.38)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__icons{opacity:var(--mdc-switch-disabled-selected-icon-opacity, 0.38)}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--unselected .mdc-switch__icon{width:var(--mdc-switch-unselected-icon-size, 16px);height:var(--mdc-switch-unselected-icon-size, 16px);fill:var(--mdc-switch-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__icon{width:var(--mdc-switch-selected-icon-size, 16px);height:var(--mdc-switch-selected-icon-size, 16px);fill:var(--mdc-switch-selected-icon-color, var(--mat-sys-on-primary-container))}.mdc-switch--selected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-selected-icon-color, var(--mat-sys-on-surface))}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle{-webkit-user-select:none;user-select:none;display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-focus-indicator::before{content:""}.mat-mdc-slide-toggle .mat-internal-form-field{color:var(--mat-switch-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-switch-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-switch-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-switch-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-switch-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-switch-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}.mat-mdc-slide-toggle .mdc-switch:enabled+.mdc-label{cursor:pointer}.mat-mdc-slide-toggle .mdc-switch--disabled+label{color:var(--mdc-switch-disabled-label-text-color)}'
        ],
        encapsulation: 2,
        changeDetection: 0
      })
    } return n
  })();
var wI = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [Ch, pe, pe]})
  } return n
})();
var SH = ['input'], IH = ['label'], MH = ['*'],
    TH = new w(
        'mat-checkbox-default-options', {providedIn: 'root', factory: CI});
function CI() {
  return {
    color: 'accent', clickAction: 'check-indeterminate', disabledInteractive: !1
  }
}
var Lt =
        function(n) {
  return n[n.Init = 0] = 'Init', n[n.Checked = 1] = 'Checked',
                    n[n.Unchecked = 2] = 'Unchecked',
                    n[n.Indeterminate = 3] = 'Indeterminate', n
}(Lt || {}),
    RH = {provide: Ro, useExisting: Zt(() => xa), multi: !0}, vv = class {
  source;
  checked
}
, xI = CI(),
  xa = (() => {
    class n {
      _elementRef = u(L);
      _changeDetectorRef = u(Ae);
      _ngZone = u(U);
      _animationMode = u(Ve, {optional: !0});
      _options = u(TH, {optional: !0});
      focus() {
        this._inputElement.nativeElement.focus()
      }
      _createChangeEvent(e) {
        let i = new vv;
        return i.source = this, i.checked = e, i
      }
      _getAnimationTargetElement() {
        return this._inputElement?.nativeElement
      }
      _animationClasses = {
        uncheckedToChecked: 'mdc-checkbox--anim-unchecked-checked',
        uncheckedToIndeterminate: 'mdc-checkbox--anim-unchecked-indeterminate',
        checkedToUnchecked: 'mdc-checkbox--anim-checked-unchecked',
        checkedToIndeterminate: 'mdc-checkbox--anim-checked-indeterminate',
        indeterminateToChecked: 'mdc-checkbox--anim-indeterminate-checked',
        indeterminateToUnchecked: 'mdc-checkbox--anim-indeterminate-unchecked'
      };
      ariaLabel = '';
      ariaLabelledby = null;
      ariaDescribedby;
      ariaExpanded;
      ariaControls;
      ariaOwns;
      _uniqueId;
      id;
      get inputId() {
        return `${this.id || this._uniqueId}-input`
      }
      required;
      labelPosition = 'after';
      name = null;
      change = new H;
      indeterminateChange = new H;
      value;
      disableRipple;
      _inputElement;
      _labelElement;
      tabIndex;
      color;
      disabledInteractive;
      _onTouched = () => {};
      _currentAnimationClass = '';
      _currentCheckState = Lt.Init;
      _controlValueAccessorChangeFn = () => {};
      _validatorChangeFn = () => {};
      constructor() {
        u(lt).load($n);
        let e = u(new Qt('tabindex'), {optional: !0});
        this._options = this._options || xI,
        this.color = this._options.color || xI.color,
        this.tabIndex = e == null ? 0 : parseInt(e) || 0,
        this.id = this._uniqueId = u(et).getId('mat-mdc-checkbox-'),
        this.disabledInteractive = this._options?.disabledInteractive ?? !1
      }
      ngOnChanges(e) {
        e.required && this._validatorChangeFn()
      }
      ngAfterViewInit() {
        this._syncIndeterminate(this._indeterminate)
      }
      get checked() {
        return this._checked
      }
      set checked(e) {
        e != this.checked &&
            (this._checked = e, this._changeDetectorRef.markForCheck())
      }
      _checked = !1;
      get disabled() {
        return this._disabled
      }
      set disabled(e) {
        e !== this.disabled &&
            (this._disabled = e, this._changeDetectorRef.markForCheck())
      }
      _disabled = !1;
      get indeterminate() {
        return this._indeterminate
      }
      set indeterminate(e) {
        let i = e != this._indeterminate;
        this._indeterminate = e,
        i &&
            (this._indeterminate ?
                 this._transitionCheckState(Lt.Indeterminate) :
                 this._transitionCheckState(
                     this.checked ? Lt.Checked : Lt.Unchecked),
             this.indeterminateChange.emit(this._indeterminate)),
        this._syncIndeterminate(this._indeterminate)
      }
      _indeterminate = !1;
      _isRippleDisabled() {
        return this.disableRipple || this.disabled
      }
      _onLabelTextChange() {
        this._changeDetectorRef.detectChanges()
      }
      writeValue(e) {
        this.checked = !!e
      }
      registerOnChange(e) {
        this._controlValueAccessorChangeFn = e
      }
      registerOnTouched(e) {
        this._onTouched = e
      }
      setDisabledState(e) {
        this.disabled = e
      }
      validate(e) {
        return this.required && e.value !== !0 ? {required: !0} : null
      }
      registerOnValidatorChange(e) {
        this._validatorChangeFn = e
      }
      _transitionCheckState(e) {
        let i = this._currentCheckState, r = this._getAnimationTargetElement();
        if (!(i === e || !r) &&
            (this._currentAnimationClass &&
                 r.classList.remove(this._currentAnimationClass),
             this._currentAnimationClass =
                 this._getAnimationClassForCheckStateTransition(i, e),
             this._currentCheckState = e,
             this._currentAnimationClass.length > 0)) {
          r.classList.add(this._currentAnimationClass);
          let o = this._currentAnimationClass;
          this._ngZone.runOutsideAngular(
              () => {setTimeout(() => {r.classList.remove(o)}, 1e3)})
        }
      }
      _emitChangeEvent() {
        this._controlValueAccessorChangeFn(this.checked),
            this.change.emit(this._createChangeEvent(this.checked)),
            this._inputElement &&
            (this._inputElement.nativeElement.checked = this.checked)
      }
      toggle() {
        this.checked = !this.checked,
        this._controlValueAccessorChangeFn(this.checked)
      }
      _handleInputClick() {
        let e = this._options?.clickAction;
        !this.disabled && e !== 'noop' ?
            (this.indeterminate && e !== 'check' &&
                 Promise.resolve().then(() => {
                   this._indeterminate = !1,
                   this.indeterminateChange.emit(this._indeterminate)
                 }),
             this._checked = !this._checked,
             this._transitionCheckState(
                 this._checked ? Lt.Checked : Lt.Unchecked),
             this._emitChangeEvent()) :
            (this.disabled && this.disabledInteractive ||
             !this.disabled && e === 'noop') &&
                (this._inputElement.nativeElement.checked = this.checked,
                 this._inputElement.nativeElement.indeterminate =
                     this.indeterminate)
      }
      _onInteractionEvent(e) {
        e.stopPropagation()
      }
      _onBlur() {
        Promise.resolve().then(
            () => {this._onTouched(), this._changeDetectorRef.markForCheck()})
      }
      _getAnimationClassForCheckStateTransition(e, i) {
        if (this._animationMode === 'NoopAnimations') return '';
        switch (e) {
          case Lt.Init:
            if (i === Lt.Checked)
              return this._animationClasses.uncheckedToChecked;
            if (i == Lt.Indeterminate)
              return this._checked ?
                  this._animationClasses.checkedToIndeterminate :
                  this._animationClasses.uncheckedToIndeterminate;
            break;
          case Lt.Unchecked:
            return i === Lt.Checked ?
                this._animationClasses.uncheckedToChecked :
                this._animationClasses.uncheckedToIndeterminate;
          case Lt.Checked:
            return i === Lt.Unchecked ?
                this._animationClasses.checkedToUnchecked :
                this._animationClasses.checkedToIndeterminate;
          case Lt.Indeterminate:
            return i === Lt.Checked ?
                this._animationClasses.indeterminateToChecked :
                this._animationClasses.indeterminateToUnchecked
        }
        return ''
      }
      _syncIndeterminate(e) {
        let i = this._inputElement;
        i && (i.nativeElement.indeterminate = e)
      }
      _onInputClick() {
        this._handleInputClick()
      }
      _onTouchTargetClick() {
        this._handleInputClick(),
            this.disabled || this._inputElement.nativeElement.focus()
      }
      _preventBubblingFromLabel(e) {
        e.target && this._labelElement.nativeElement.contains(e.target) &&
            e.stopPropagation()
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275cmp = O({
        type: n,
        selectors: [['mat-checkbox']],
        viewQuery: function(i, r) {
          if (i & 1 && (oe(SH, 5), oe(IH, 5)), i & 2) {
            let o;
            $(o = W()) && (r._inputElement = o.first),
                $(o = W()) && (r._labelElement = o.first)
          }
        },
        hostAttrs: [1, 'mat-mdc-checkbox'],
        hostVars: 16,
        hostBindings: function(i, r) {
          i&2 &&
              (en('id', r.id),
               J('tabindex', null)('aria-label', null)('aria-labelledby', null),
               kt(r.color ? 'mat-' + r.color : 'mat-accent'),
               Y('_mat-animation-noopable',
                 r._animationMode === 'NoopAnimations')(
                   'mdc-checkbox--disabled', r.disabled)(
                   'mat-mdc-checkbox-disabled', r.disabled)(
                   'mat-mdc-checkbox-checked', r.checked)(
                   'mat-mdc-checkbox-disabled-interactive',
                   r.disabledInteractive))
        },
        inputs: {
          ariaLabel: [0, 'aria-label', 'ariaLabel'],
          ariaLabelledby: [0, 'aria-labelledby', 'ariaLabelledby'],
          ariaDescribedby: [0, 'aria-describedby', 'ariaDescribedby'],
          ariaExpanded: [2, 'aria-expanded', 'ariaExpanded', q],
          ariaControls: [0, 'aria-controls', 'ariaControls'],
          ariaOwns: [0, 'aria-owns', 'ariaOwns'],
          id: 'id',
          required: [2, 'required', 'required', q],
          labelPosition: 'labelPosition',
          name: 'name',
          value: 'value',
          disableRipple: [2, 'disableRipple', 'disableRipple', q],
          tabIndex:
              [2, 'tabIndex', 'tabIndex', e => e == null ? void 0 : st(e)],
          color: 'color',
          disabledInteractive:
              [2, 'disabledInteractive', 'disabledInteractive', q],
          checked: [2, 'checked', 'checked', q],
          disabled: [2, 'disabled', 'disabled', q],
          indeterminate: [2, 'indeterminate', 'indeterminate', q]
        },
        outputs: {change: 'change', indeterminateChange: 'indeterminateChange'},
        exportAs: ['matCheckbox'],
        features: [ye([RH, {provide: Mr, useExisting: n, multi: !0}]), Pe],
        ngContentSelectors: MH,
        decls: 15,
        vars: 23,
        consts: [
          ['checkbox', ''], ['input', ''], ['label', ''],
          ['mat-internal-form-field', '', 3, 'click', 'labelPosition'],
          [1, 'mdc-checkbox'], [1, 'mat-mdc-checkbox-touch-target', 3, 'click'],
          [
            'type', 'checkbox', 1, 'mdc-checkbox__native-control', 3, 'blur',
            'click', 'change', 'checked', 'indeterminate', 'disabled', 'id',
            'required', 'tabIndex'
          ],
          [1, 'mdc-checkbox__ripple'], [1, 'mdc-checkbox__background'],
          [
            'focusable', 'false', 'viewBox', '0 0 24 24', 'aria-hidden', 'true',
            1, 'mdc-checkbox__checkmark'
          ],
          [
            'fill', 'none', 'd', 'M1.73,12.91 8.1,19.28 22.79,4.59', 1,
            'mdc-checkbox__checkmark-path'
          ],
          [1, 'mdc-checkbox__mixedmark'],
          [
            'mat-ripple', '', 1, 'mat-mdc-checkbox-ripple',
            'mat-focus-indicator', 3, 'matRippleTrigger', 'matRippleDisabled',
            'matRippleCentered'
          ],
          [1, 'mdc-label', 3, 'for']
        ],
        template: function(i, r) {
          if (i & 1) {
            let o = ee();
            Se(), f(0, 'div', 3),
                M('click',
                  function(a) {
                    return N(o), P(r._preventBubblingFromLabel(a))
                  }),
                f(1, 'div', 4, 0)(3, 'div', 5),
                M('click',
                  function() {
                    return N(o), P(r._onTouchTargetClick())
                  }),
                g(), f(4, 'input', 6, 1),
                M('blur',
                  function() {
                    return N(o), P(r._onBlur())
                  })(
                    'click',
                    function() {
                      return N(o), P(r._onInputClick())
                    })(
                    'change',
                    function(a) {
                      return N(o), P(r._onInteractionEvent(a))
                    }),
                g(), B(6, 'div', 7), f(7, 'div', 8), Bt(), f(8, 'svg', 9),
                B(9, 'path', 10), g(), wo(), B(10, 'div', 11), g(),
                B(11, 'div', 12), g(), f(12, 'label', 13, 2), Z(14), g()()
          }
          if (i & 2) {
            let o = yt(2);
            x('labelPosition', r.labelPosition), b(4),
                Y('mdc-checkbox--selected', r.checked),
                x('checked', r.checked)('indeterminate', r.indeterminate)(
                    'disabled', r.disabled && !r.disabledInteractive)(
                    'id', r.inputId)('required', r.required)(
                    'tabIndex',
                    r.disabled && !r.disabledInteractive ? -1 : r.tabIndex),
                J('aria-label', r.ariaLabel || null)(
                    'aria-labelledby', r.ariaLabelledby)(
                    'aria-describedby', r.ariaDescribedby)(
                    'aria-checked', r.indeterminate ? 'mixed' : null)(
                    'aria-controls', r.ariaControls)(
                    'aria-disabled',
                    r.disabled && r.disabledInteractive ? !0 : null)(
                    'aria-expanded', r.ariaExpanded)('aria-owns', r.ariaOwns)(
                    'name', r.name)('value', r.value),
                b(7),
                x('matRippleTrigger', o)(
                    'matRippleDisabled', r.disableRipple || r.disabled)(
                    'matRippleCentered', !0),
                b(), x('for', r.inputId)
          }
        },
        dependencies: [Fr, Qm],
        styles: [
          '.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}'
        ],
        encapsulation: 2,
        changeDetection: 0
      })
    } return n
  })();
var DI = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [xa, pe, pe]})
  } return n
})();
var NH = [[['caption']], [['colgroup'], ['col']], '*'],
    PH = ['caption', 'colgroup, col', '*'];
function FH(n, t) {
  n&1 && Z(0, 2)
}
function LH(n, t) {
  n&1 &&
      (f(0, 'thead', 0), vt(1, 1), g(), f(2, 'tbody', 0), vt(3, 2)(4, 3), g(),
       f(5, 'tfoot', 0), vt(6, 4), g())
}
function VH(n, t) {
  n&1 && vt(0, 1)(1, 2)(2, 3)(3, 4)
}
var Qn = new w('CDK_TABLE');
var Mh = (() => {
  class n {
    template = u(qe);
    constructor() {}
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({type: n, selectors: [['', 'cdkCellDef', '']]})
  } return n
})(),
    Th = (() => {
      class n {
        template = u(qe);
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['', 'cdkHeaderCellDef', '']]})
      } return n
    })(),
    SI = (() => {
      class n {
        template = u(qe);
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['', 'cdkFooterCellDef', '']]})
      } return n
    })(),
    Ca = (() => {
      class n {
        _table = u(Qn, {optional: !0});
        _hasStickyChanged = !1;
        get name() {
          return this._name
        }
        set name(e) {
          this._setNameInput(e)
        }
        _name;
        get sticky() {
          return this._sticky
        }
        set sticky(e) {
          e !== this._sticky && (this._sticky = e, this._hasStickyChanged = !0)
        }
        _sticky = !1;
        get stickyEnd() {
          return this._stickyEnd
        }
        set stickyEnd(e) {
          e !== this._stickyEnd &&
              (this._stickyEnd = e, this._hasStickyChanged = !0)
        }
        _stickyEnd = !1;
        cell;
        headerCell;
        footerCell;
        cssClassFriendlyName;
        _columnCssClassName;
        constructor() {}
        hasStickyChanged() {
          let e = this._hasStickyChanged;
          return this.resetStickyChanged(), e
        }
        resetStickyChanged() {
          this._hasStickyChanged = !1
        }
        _updateColumnCssClassName() {
          this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`]
        }
        _setNameInput(e) {
          e &&
              (this._name = e,
               this.cssClassFriendlyName = e.replace(/[^a-z0-9_-]/gi, '-'),
               this._updateColumnCssClassName())
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdkColumnDef', '']],
          contentQueries: function(i, r, o) {
            if (i & 1 && (Oe(o, Mh, 5), Oe(o, Th, 5), Oe(o, SI, 5)), i & 2) {
              let s;
              $(s = W()) && (r.cell = s.first),
                  $(s = W()) && (r.headerCell = s.first),
                  $(s = W()) && (r.footerCell = s.first)
            }
          },
          inputs: {
            name: [0, 'cdkColumnDef', 'name'],
            sticky: [2, 'sticky', 'sticky', q],
            stickyEnd: [2, 'stickyEnd', 'stickyEnd', q]
          },
          features:
              [ye([{provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: n}])]
        })
      } return n
    })(),
    Eh = class {
  constructor(t, e) {
    e.nativeElement.classList.add(...t._columnCssClassName)
  }
}
, II = (() => {
    class n extends Eh {
      constructor() {
        super(u(Ca), u(L))
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275dir = T({
        type: n,
        selectors: [['cdk-header-cell'], ['th', 'cdk-header-cell', '']],
        hostAttrs: ['role', 'columnheader', 1, 'cdk-header-cell'],
        features: [te]
      })
    } return n
  })();
var MI = (() => {
  class n extends Eh {
    constructor() {
      let e = u(Ca), i = u(L);
      super(e, i);
      let r = e._table?._getCellRole();
      r && i.nativeElement.setAttribute('role', r)
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({
      type: n,
      selectors: [['cdk-cell'], ['td', 'cdk-cell', '']],
      hostAttrs: [1, 'cdk-cell'],
      features: [te]
    })
  } return n
})(),
    kh = class {
  tasks = [];
  endTasks = []
}
, Sh = new w('_COALESCED_STYLE_SCHEDULER'),
  wv = (() => {
    class n {
      _currentSchedule = null;
      _ngZone = u(U);
      constructor() {}
      schedule(e) {
        this._createScheduleIfNeeded(), this._currentSchedule.tasks.push(e)
      }
      scheduleEnd(e) {
        this._createScheduleIfNeeded(), this._currentSchedule.endTasks.push(e)
      }
      _createScheduleIfNeeded() {
        this._currentSchedule ||
            (this._currentSchedule = new kh,
             this._ngZone.runOutsideAngular(
                 () => queueMicrotask(() => {
                   for (; this._currentSchedule.tasks.length ||
                        this._currentSchedule.endTasks.length;) {
                     let e = this._currentSchedule;
                     this._currentSchedule = new kh;
                     for (let i of e.tasks) i();
                     for (let i of e.endTasks) i()
                   }
                   this._currentSchedule = null
                 })))
      }
      static \u0275fac = function(i) {
        return new (i || n)
      };
      static \u0275prov = C({token: n, factory: n.\u0275fac})
    } return n
  })();
var xv = (() => {
  class n {
    template = u(qe);
    _differs = u(ui);
    columns;
    _columnsDiffer;
    constructor() {}
    ngOnChanges(e) {
      if (!this._columnsDiffer) {
        let i = e.columns && e.columns.currentValue || [];
        this._columnsDiffer = this._differs.find(i).create(),
        this._columnsDiffer.diff(i)
      }
    }
    getColumnsDiff() {
      return this._columnsDiffer.diff(this.columns)
    }
    extractCellTemplate(e) {
      return this instanceof pc ? e.headerCell.template :
          this instanceof Cv    ? e.footerCell.template :
                                  e.cell.template
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({type: n, features: [Pe]})
  } return n
})(),
    pc = (() => {
      class n extends xv {
        _table = u(Qn, {optional: !0});
        _hasStickyChanged = !1;
        get sticky() {
          return this._sticky
        }
        set sticky(e) {
          e !== this._sticky && (this._sticky = e, this._hasStickyChanged = !0)
        }
        _sticky = !1;
        constructor() {
          super(u(qe), u(ui))
        }
        ngOnChanges(e) {
          super.ngOnChanges(e)
        }
        hasStickyChanged() {
          let e = this._hasStickyChanged;
          return this.resetStickyChanged(), e
        }
        resetStickyChanged() {
          this._hasStickyChanged = !1
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdkHeaderRowDef', '']],
          inputs: {
            columns: [0, 'cdkHeaderRowDef', 'columns'],
            sticky: [2, 'cdkHeaderRowDefSticky', 'sticky', q]
          },
          features: [te, Pe]
        })
      } return n
    })(),
    Cv = (() => {
      class n extends xv {
        _table = u(Qn, {optional: !0});
        _hasStickyChanged = !1;
        get sticky() {
          return this._sticky
        }
        set sticky(e) {
          e !== this._sticky && (this._sticky = e, this._hasStickyChanged = !0)
        }
        _sticky = !1;
        constructor() {
          super(u(qe), u(ui))
        }
        ngOnChanges(e) {
          super.ngOnChanges(e)
        }
        hasStickyChanged() {
          let e = this._hasStickyChanged;
          return this.resetStickyChanged(), e
        }
        resetStickyChanged() {
          this._hasStickyChanged = !1
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdkFooterRowDef', '']],
          inputs: {
            columns: [0, 'cdkFooterRowDef', 'columns'],
            sticky: [2, 'cdkFooterRowDefSticky', 'sticky', q]
          },
          features: [te, Pe]
        })
      } return n
    })(),
    Rh = (() => {
      class n extends xv {
        _table = u(Qn, {optional: !0});
        when;
        constructor() {
          super(u(qe), u(ui))
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({
          type: n,
          selectors: [['', 'cdkRowDef', '']],
          inputs: {
            columns: [0, 'cdkRowDefColumns', 'columns'],
            when: [0, 'cdkRowDefWhen', 'when']
          },
          features: [te]
        })
      } return n
    })(),
    $o = (() => {
      class n {
        _viewContainer = u(Ge);
        cells;
        context;
        static mostRecentCellOutlet = null;
        constructor() {
          n.mostRecentCellOutlet = this
        }
        ngOnDestroy() {
          n.mostRecentCellOutlet === this && (n.mostRecentCellOutlet = null)
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir = T({type: n, selectors: [['', 'cdkCellOutlet', '']]})
      } return n
    })(),
    Dv = (() => {
      class n {
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275cmp = O({
          type: n,
          selectors: [['cdk-header-row'], ['tr', 'cdk-header-row', '']],
          hostAttrs: ['role', 'row', 1, 'cdk-header-row'],
          decls: 1,
          vars: 0,
          consts: [['cdkCellOutlet', '']],
          template: function(i, r) {
            i&1 && vt(0, 0)
          },
          dependencies: [$o],
          encapsulation: 2
        })
      } return n
    })();
var Ev = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['cdk-row'], ['tr', 'cdk-row', '']],
      hostAttrs: ['role', 'row', 1, 'cdk-row'],
      decls: 1,
      vars: 0,
      consts: [['cdkCellOutlet', '']],
      template: function(i, r) {
        i&1 && vt(0, 0)
      },
      dependencies: [$o],
      encapsulation: 2
    })
  } return n
})(),
    TI = (() => {
      class n {
        templateRef = u(qe);
        _contentClassName = 'cdk-no-data-row';
        constructor() {}
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['ng-template', 'cdkNoDataRow', '']]})
      } return n
    })(),
    EI = ['top', 'bottom', 'left', 'right'], yv = class {
  _isNativeHtmlTable;
  _stickCellCss;
  direction;
  _coalescedStyleScheduler;
  _isBrowser;
  _needsPositionStickyOnElement;
  _positionListener;
  _tableInjector;
  _elemSizeCache = new WeakMap;
  _resizeObserver = globalThis?.ResizeObserver ?
      new globalThis.ResizeObserver(t => this._updateCachedSizes(t)) :
      null;
  _updatedStickyColumnsParamsToReplay = [];
  _stickyColumnsReplayTimeout = null;
  _cachedCellWidths = [];
  _borderCellCss;
  _destroyed = !1;
  constructor(t, e, i, r, o = !0, s = !0, a, l) {
    this._isNativeHtmlTable = t, this._stickCellCss = e, this.direction = i,
    this._coalescedStyleScheduler = r, this._isBrowser = o,
    this._needsPositionStickyOnElement = s, this._positionListener = a,
    this._tableInjector = l, this._borderCellCss = {
      top: `${e}-border-elem-top`,
      bottom: `${e}-border-elem-bottom`,
      left: `${e}-border-elem-left`,
      right: `${e}-border-elem-right`
    }
  }
  clearStickyPositioning(t, e) {
    (e.includes('left') || e.includes('right')) &&
        this._removeFromStickyColumnReplayQueue(t);
    let i = [];
    for (let r of t)
      r.nodeType === r.ELEMENT_NODE && i.push(r, ...Array.from(r.children));
    this._afterNextRender({
      write: () => {
        for (let r of i) this._removeStickyStyle(r, e)
      }
    })
  }
  updateStickyColumns(t, e, i, r = !0, o = !0) {
    if (!t.length || !this._isBrowser || !(e.some(k => k) || i.some(k => k))) {
      this._positionListener?.stickyColumnsUpdated({sizes: []}),
          this._positionListener?.stickyEndColumnsUpdated({sizes: []});
      return
    }
    let s = t[0], a = s.children.length, l = this.direction === 'rtl',
        c = l ? 'right' : 'left', d = l ? 'left' : 'right',
        m = e.lastIndexOf(!0), p = i.indexOf(!0), h, _, v;
    o &&
        this._updateStickyColumnReplayQueue(
            {rows: [...t], stickyStartStates: [...e], stickyEndStates: [...i]}),
        this._afterNextRender({
          earlyRead: () => {
            h = this._getCellWidths(s, r),
            _ = this._getStickyStartColumnPositions(h, e),
            v = this._getStickyEndColumnPositions(h, i)
          },
          write: () => {
            for (let k of t)
              for (let F = 0; F < a; F++) {
                let se = k.children[F];
                e[F] && this._addStickyStyle(se, c, _[F], F === m),
                    i[F] && this._addStickyStyle(se, d, v[F], F === p)
              }
            this._positionListener && h.some(k => !!k) &&
                (this._positionListener.stickyColumnsUpdated({
                  sizes: m === -1 ?
                      [] :
                      h.slice(0, m + 1).map((k, F) => e[F] ? k : null)
                }),
                 this._positionListener.stickyEndColumnsUpdated({
                   sizes: p === -1 ?
                       [] :
                       h.slice(p).map((k, F) => i[F + p] ? k : null).reverse()
                 }))
          }
        })
  }
  stickRows(t, e, i) {
    if (!this._isBrowser) return;
    let r = i === 'bottom' ? t.slice().reverse() : t,
        o = i === 'bottom' ? e.slice().reverse() : e, s = [], a = [], l = [];
    this._afterNextRender({
      earlyRead: () => {
        for (let c = 0, d = 0; c < r.length; c++) {
          if (!o[c]) continue;
          s[c] = d;
          let m = r[c];
          l[c] = this._isNativeHtmlTable ? Array.from(m.children) : [m];
          let p = this._retrieveElementSize(m).height;
          d += p, a[c] = p
        }
      },
      write: () => {
        let c = o.lastIndexOf(!0);
        for (let d = 0; d < r.length; d++) {
          if (!o[d]) continue;
          let m = s[d], p = d === c;
          for (let h of l[d]) this._addStickyStyle(h, i, m, p)
        }
        i === 'top' ? this._positionListener?.stickyHeaderRowsUpdated(
                          {sizes: a, offsets: s, elements: l}) :
                      this._positionListener?.stickyFooterRowsUpdated(
                          {sizes: a, offsets: s, elements: l})
      }
    })
  }
  updateStickyFooterContainer(t, e) {
    this._isNativeHtmlTable && this._afterNextRender({
      write: () => {
        let i = t.querySelector('tfoot');
        i &&
            (e.some(r => !r) ? this._removeStickyStyle(i, ['bottom']) :
                               this._addStickyStyle(i, 'bottom', 0, !1))
      }
    })
  }
  destroy() {
    this._stickyColumnsReplayTimeout &&
        clearTimeout(this._stickyColumnsReplayTimeout),
        this._resizeObserver?.disconnect(), this._destroyed = !0
  }
  _removeStickyStyle(t, e) {
    for (let r of e)
      t.style[r] = '', t.classList.remove(this._borderCellCss[r]);
    EI.some(r => e.indexOf(r) === -1 && t.style[r]) ?
        t.style.zIndex = this._getCalculatedZIndex(t) :
        (t.style.zIndex = '',
         this._needsPositionStickyOnElement && (t.style.position = ''),
         t.classList.remove(this._stickCellCss))
  }
  _addStickyStyle(t, e, i, r) {
    t.classList.add(this._stickCellCss),
        r && t.classList.add(this._borderCellCss[e]),
        t.style[e] = `${i}px`, t.style.zIndex = this._getCalculatedZIndex(t),
        this._needsPositionStickyOnElement &&
        (t.style.cssText += 'position: -webkit-sticky; position: sticky; ')
  }
  _getCalculatedZIndex(t) {
    let e = {top: 100, bottom: 10, left: 1, right: 1}, i = 0;
    for (let r of EI) t.style[r] && (i += e[r]);
    return i ? `${i}` : ''
  }
  _getCellWidths(t, e = !0) {
    if (!e && this._cachedCellWidths.length) return this._cachedCellWidths;
    let i = [], r = t.children;
    for (let o = 0; o < r.length; o++) {
      let s = r[o];
      i.push(this._retrieveElementSize(s).width)
    }
    return this._cachedCellWidths = i, i
  }
  _getStickyStartColumnPositions(t, e) {
    let i = [], r = 0;
    for (let o = 0; o < t.length; o++) e[o] && (i[o] = r, r += t[o]);
    return i
  }
  _getStickyEndColumnPositions(t, e) {
    let i = [], r = 0;
    for (let o = t.length; o > 0; o--) e[o] && (i[o] = r, r += t[o]);
    return i
  }
  _retrieveElementSize(t) {
    let e = this._elemSizeCache.get(t);
    if (e) return e;
    let i = t.getBoundingClientRect(), r = {width: i.width, height: i.height};
    return this._resizeObserver &&
               (this._elemSizeCache.set(t, r),
                this._resizeObserver.observe(t, {box: 'border-box'})),
           r
  }
  _updateStickyColumnReplayQueue(t) {
    this._removeFromStickyColumnReplayQueue(t.rows),
        this._stickyColumnsReplayTimeout ||
        this._updatedStickyColumnsParamsToReplay.push(t)
  }
  _removeFromStickyColumnReplayQueue(t) {
    let e = new Set(t);
    for (let i of this._updatedStickyColumnsParamsToReplay)
      i.rows = i.rows.filter(r => !e.has(r));
    this._updatedStickyColumnsParamsToReplay =
        this._updatedStickyColumnsParamsToReplay.filter(i => !!i.rows.length)
  }
  _updateCachedSizes(t) {
    let e = !1;
    for (let i of t) {
      let r = i.borderBoxSize?.length ?
          {
            width: i.borderBoxSize[0].inlineSize,
            height: i.borderBoxSize[0].blockSize
          } :
          {width: i.contentRect.width, height: i.contentRect.height};
      r.width !== this._elemSizeCache.get(i.target)?.width && jH(i.target) &&
          (e = !0),
          this._elemSizeCache.set(i.target, r)
    }
    e && this._updatedStickyColumnsParamsToReplay.length &&
        (this._stickyColumnsReplayTimeout &&
             clearTimeout(this._stickyColumnsReplayTimeout),
         this._stickyColumnsReplayTimeout = setTimeout(() => {
           if (!this._destroyed) {
             for (let i of this._updatedStickyColumnsParamsToReplay)
               this.updateStickyColumns(
                   i.rows, i.stickyStartStates, i.stickyEndStates, !0, !1);
             this._updatedStickyColumnsParamsToReplay = [],
             this._stickyColumnsReplayTimeout = null
           }
         }, 0))
  }
  _afterNextRender(t) {
    this._tableInjector ? ht(t, {injector: this._tableInjector}) :
                          this._coalescedStyleScheduler.schedule(
                              () => {t.earlyRead?.(), t.write()})
  }
};
function jH(n) {
  return ['cdk-cell', 'cdk-header-cell', 'cdk-footer-cell'].some(
      t => n.classList.contains(t))
}
var Ih = new w('CDK_SPL');
var kv = (() => {
  class n {
    viewContainer = u(Ge);
    elementRef = u(L);
    constructor() {
      let e = u(Qn);
      e._rowOutlet = this, e._outletAssigned()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275dir = T({type: n, selectors: [['', 'rowOutlet', '']]})
  } return n
})(),
    Sv = (() => {
      class n {
        viewContainer = u(Ge);
        elementRef = u(L);
        constructor() {
          let e = u(Qn);
          e._headerRowOutlet = this, e._outletAssigned()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['', 'headerRowOutlet', '']]})
      } return n
    })(),
    Iv = (() => {
      class n {
        viewContainer = u(Ge);
        elementRef = u(L);
        constructor() {
          let e = u(Qn);
          e._footerRowOutlet = this, e._outletAssigned()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['', 'footerRowOutlet', '']]})
      } return n
    })(),
    Mv = (() => {
      class n {
        viewContainer = u(Ge);
        elementRef = u(L);
        constructor() {
          let e = u(Qn);
          e._noDataRowOutlet = this, e._outletAssigned()
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275dir =
            T({type: n, selectors: [['', 'noDataRowOutlet', '']]})
      } return n
    })();
var Tv = (() => {
  class n {
    _differs = u(ui);
    _changeDetectorRef = u(Ae);
    _elementRef = u(L);
    _dir = u(dt, {optional: !0});
    _platform = u(Ie);
    _viewRepeater = u(Xl);
    _coalescedStyleScheduler = u(Sh);
    _viewportRuler = u(Dn);
    _stickyPositioningListener = u(Ih, {optional: !0, skipSelf: !0});
    _document = u(ce);
    _data;
    _onDestroy = new I;
    _renderRows;
    _renderChangeSubscription;
    _columnDefsByName = new Map;
    _rowDefs;
    _headerRowDefs;
    _footerRowDefs;
    _dataDiffer;
    _defaultRowDef;
    _customColumnDefs = new Set;
    _customRowDefs = new Set;
    _customHeaderRowDefs = new Set;
    _customFooterRowDefs = new Set;
    _customNoDataRow;
    _headerRowDefChanged = !0;
    _footerRowDefChanged = !0;
    _stickyColumnStylesNeedReset = !0;
    _forceRecalculateCellWidths = !0;
    _cachedRenderRowsMap = new Map;
    _isNativeHtmlTable;
    _stickyStyler;
    stickyCssClass = 'cdk-table-sticky';
    needsPositionStickyOnElement = !0;
    _isServer;
    _isShowingNoDataRow = !1;
    _hasAllOutlets = !1;
    _hasInitialized = !1;
    _getCellRole() {
      if (this._cellRoleInternal === void 0) {
        let e = this._elementRef.nativeElement.getAttribute('role');
        return e === 'grid' || e === 'treegrid' ? 'gridcell' : 'cell'
      }
      return this._cellRoleInternal
    }
    _cellRoleInternal = void 0;
    get trackBy() {
      return this._trackByFn
    }
    set trackBy(e) {
      this._trackByFn = e
    }
    _trackByFn;
    get dataSource() {
      return this._dataSource
    }
    set dataSource(e) {
      this._dataSource !== e && this._switchDataSource(e)
    }
    _dataSource;
    get multiTemplateDataRows() {
      return this._multiTemplateDataRows
    }
    set multiTemplateDataRows(e) {
      this._multiTemplateDataRows = e,
      this._rowOutlet && this._rowOutlet.viewContainer.length &&
          (this._forceRenderDataRows(), this.updateStickyColumnStyles())
    }
    _multiTemplateDataRows = !1;
    get fixedLayout() {
      return this._fixedLayout
    }
    set fixedLayout(e) {
      this._fixedLayout = e, this._forceRecalculateCellWidths = !0,
      this._stickyColumnStylesNeedReset = !0
    }
    _fixedLayout = !1;
    contentChanged = new H;
    viewChange = new Le({start: 0, end: Number.MAX_VALUE});
    _rowOutlet;
    _headerRowOutlet;
    _footerRowOutlet;
    _noDataRowOutlet;
    _contentColumnDefs;
    _contentRowDefs;
    _contentHeaderRowDefs;
    _contentFooterRowDefs;
    _noDataRow;
    _injector = u(he);
    constructor() {
      u(new Qt('role'), {optional: !0}) ||
          this._elementRef.nativeElement.setAttribute('role', 'table'),
          this._isServer = !this._platform.isBrowser,
          this._isNativeHtmlTable =
              this._elementRef.nativeElement.nodeName === 'TABLE'
    }
    ngOnInit() {
      this._setupStickyStyler(),
          this._dataDiffer = this._differs.find([]).create(
              (e, i) => this.trackBy ? this.trackBy(i.dataIndex, i.data) : i),
          this._viewportRuler.change()
              .pipe(re(this._onDestroy))
              .subscribe(() => {this._forceRecalculateCellWidths = !0})
    }
    ngAfterContentInit() {
      this._hasInitialized = !0
    }
    ngAfterContentChecked() {
      this._canRender() && this._render()
    }
    ngOnDestroy() {
      this._stickyStyler?.destroy(),
          [
            this._rowOutlet?.viewContainer,
            this._headerRowOutlet?.viewContainer,
            this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap,
            this._customColumnDefs, this._customRowDefs,
            this._customHeaderRowDefs, this._customFooterRowDefs,
            this._columnDefsByName
          ].forEach(e => {e?.clear()}),
          this._headerRowDefs = [], this._footerRowDefs = [],
          this._defaultRowDef = null, this._onDestroy.next(),
          this._onDestroy.complete(),
          Jm(this.dataSource) && this.dataSource.disconnect(this)
    }
    renderRows() {
      this._renderRows = this._getAllRenderRows();
      let e = this._dataDiffer.diff(this._renderRows);
      if (!e) {
        this._updateNoDataRow(), this.contentChanged.next();
        return
      }
      let i = this._rowOutlet.viewContainer;
      this._viewRepeater.applyChanges(
          e, i, (r, o, s) => this._getEmbeddedViewArgs(r.item, s),
          r => r.item.data,
          r => {
              r.operation === aa.INSERTED && r.context &&
              this._renderCellTemplateForItem(
                  r.record.item.rowDef, r.context)}),
          this._updateRowIndexContext(), e.forEachIdentityChange(r => {
            let o = i.get(r.currentIndex);
            o.context.$implicit = r.item.data
          }),
          this._updateNoDataRow(), this.contentChanged.next(),
          this.updateStickyColumnStyles()
    }
    addColumnDef(e) {
      this._customColumnDefs.add(e)
    }
    removeColumnDef(e) {
      this._customColumnDefs.delete(e)
    }
    addRowDef(e) {
      this._customRowDefs.add(e)
    }
    removeRowDef(e) {
      this._customRowDefs.delete(e)
    }
    addHeaderRowDef(e) {
      this._customHeaderRowDefs.add(e), this._headerRowDefChanged = !0
    }
    removeHeaderRowDef(e) {
      this._customHeaderRowDefs.delete(e), this._headerRowDefChanged = !0
    }
    addFooterRowDef(e) {
      this._customFooterRowDefs.add(e), this._footerRowDefChanged = !0
    }
    removeFooterRowDef(e) {
      this._customFooterRowDefs.delete(e), this._footerRowDefChanged = !0
    }
    setNoDataRow(e) {
      this._customNoDataRow = e
    }
    updateStickyHeaderRowStyles() {
      let e = this._getRenderedRows(this._headerRowOutlet);
      if (this._isNativeHtmlTable) {
        let r = kI(this._headerRowOutlet, 'thead');
        r && (r.style.display = e.length ? '' : 'none')
      }
      let i = this._headerRowDefs.map(r => r.sticky);
      this._stickyStyler.clearStickyPositioning(e, ['top']),
          this._stickyStyler.stickRows(e, i, 'top'),
          this._headerRowDefs.forEach(r => r.resetStickyChanged())
    }
    updateStickyFooterRowStyles() {
      let e = this._getRenderedRows(this._footerRowOutlet);
      if (this._isNativeHtmlTable) {
        let r = kI(this._footerRowOutlet, 'tfoot');
        r && (r.style.display = e.length ? '' : 'none')
      }
      let i = this._footerRowDefs.map(r => r.sticky);
      this._stickyStyler.clearStickyPositioning(e, ['bottom']),
          this._stickyStyler.stickRows(e, i, 'bottom'),
          this._stickyStyler.updateStickyFooterContainer(
              this._elementRef.nativeElement, i),
          this._footerRowDefs.forEach(r => r.resetStickyChanged())
    }
    updateStickyColumnStyles() {
      let e = this._getRenderedRows(this._headerRowOutlet),
          i = this._getRenderedRows(this._rowOutlet),
          r = this._getRenderedRows(this._footerRowOutlet);
      (this._isNativeHtmlTable && !this._fixedLayout ||
       this._stickyColumnStylesNeedReset) &&
          (this._stickyStyler.clearStickyPositioning(
               [...e, ...i, ...r], ['left', 'right']),
           this._stickyColumnStylesNeedReset = !1),
          e.forEach(
              (o, s) => {
                  this._addStickyColumnStyles([o], this._headerRowDefs[s])}),
          this._rowDefs.forEach(o => {
            let s = [];
            for (let a = 0; a < i.length; a++)
              this._renderRows[a].rowDef === o && s.push(i[a]);
            this._addStickyColumnStyles(s, o)
          }),
          r.forEach(
              (o, s) => {
                  this._addStickyColumnStyles([o], this._footerRowDefs[s])}),
          Array.from(this._columnDefsByName.values())
              .forEach(o => o.resetStickyChanged())
    }
    _outletAssigned() {
      !this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet &&
          this._footerRowOutlet && this._noDataRowOutlet &&
          (this._hasAllOutlets = !0, this._canRender() && this._render())
    }
    _canRender() {
      return this._hasAllOutlets && this._hasInitialized
    }
    _render() {
      this._cacheRowDefs(), this._cacheColumnDefs(),
          !this._headerRowDefs.length && !this._footerRowDefs.length &&
          this._rowDefs.length;
      let i = this._renderUpdatedColumns() || this._headerRowDefChanged ||
          this._footerRowDefChanged;
      this._stickyColumnStylesNeedReset =
          this._stickyColumnStylesNeedReset || i,
      this._forceRecalculateCellWidths = i,
      this._headerRowDefChanged &&
          (this._forceRenderHeaderRows(), this._headerRowDefChanged = !1),
      this._footerRowDefChanged &&
          (this._forceRenderFooterRows(), this._footerRowDefChanged = !1),
      this.dataSource && this._rowDefs.length > 0 &&
              !this._renderChangeSubscription ?
          this._observeRenderChanges() :
          this._stickyColumnStylesNeedReset && this.updateStickyColumnStyles(),
      this._checkStickyStates()
    }
    _getAllRenderRows() {
      let e = [], i = this._cachedRenderRowsMap;
      this._cachedRenderRowsMap = new Map;
      for (let r = 0; r < this._data.length; r++) {
        let o = this._data[r], s = this._getRenderRowsForData(o, r, i.get(o));
        this._cachedRenderRowsMap.has(o) ||
            this._cachedRenderRowsMap.set(o, new WeakMap);
        for (let a = 0; a < s.length; a++) {
          let l = s[a], c = this._cachedRenderRowsMap.get(l.data);
          c.has(l.rowDef) ? c.get(l.rowDef).push(l) : c.set(l.rowDef, [l]),
              e.push(l)
        }
      }
      return e
    }
    _getRenderRowsForData(e, i, r) {
      return this._getRowDefs(e, i).map(s => {
        let a = r && r.has(s) ? r.get(s) : [];
        if (a.length) {
          let l = a.shift();
          return l.dataIndex = i, l
        } else
          return {
            data: e, rowDef: s, dataIndex: i
          }
      })
    }
    _cacheColumnDefs() {
      this._columnDefsByName.clear(),
          Dh(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs)
              .forEach(i => {
                this._columnDefsByName.has(i.name),
                this._columnDefsByName.set(i.name, i)
              })
    }
    _cacheRowDefs() {
      this._headerRowDefs =
          Dh(this._getOwnDefs(this._contentHeaderRowDefs),
             this._customHeaderRowDefs),
      this._footerRowDefs =
          Dh(this._getOwnDefs(this._contentFooterRowDefs),
             this._customFooterRowDefs),
      this._rowDefs =
          Dh(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
      let e = this._rowDefs.filter(i => !i.when);
      !this.multiTemplateDataRows && e.length > 1, this._defaultRowDef = e[0]
    }
    _renderUpdatedColumns() {
      let e = (s, a) => {
        let l = !!a.getColumnsDiff();
        return s || l
      }, i = this._rowDefs.reduce(e, !1);
      i && this._forceRenderDataRows();
      let r = this._headerRowDefs.reduce(e, !1);
      r && this._forceRenderHeaderRows();
      let o = this._footerRowDefs.reduce(e, !1);
      return o && this._forceRenderFooterRows(), i || r || o
    }
    _switchDataSource(e) {
      this._data = [], Jm(this.dataSource) && this.dataSource.disconnect(this),
      this._renderChangeSubscription &&
          (this._renderChangeSubscription.unsubscribe(),
           this._renderChangeSubscription = null),
      e ||
          (this._dataDiffer && this._dataDiffer.diff([]),
           this._rowOutlet && this._rowOutlet.viewContainer.clear()),
      this._dataSource = e
    }
    _observeRenderChanges() {
      if (!this.dataSource) return;
      let e;
      Jm(this.dataSource) ?
          e = this.dataSource.connect(this) :
          lr(this.dataSource) ?
          e = this.dataSource :
          Array.isArray(this.dataSource) && (e = G(this.dataSource)),
          this._renderChangeSubscription =
              e.pipe(re(this._onDestroy))
                  .subscribe(i => {this._data = i || [], this.renderRows()})
    }
    _forceRenderHeaderRows() {
      this._headerRowOutlet.viewContainer.length > 0 &&
          this._headerRowOutlet.viewContainer.clear(),
          this._headerRowDefs.forEach(
              (e, i) => this._renderRow(this._headerRowOutlet, e, i)),
          this.updateStickyHeaderRowStyles()
    }
    _forceRenderFooterRows() {
      this._footerRowOutlet.viewContainer.length > 0 &&
          this._footerRowOutlet.viewContainer.clear(),
          this._footerRowDefs.forEach(
              (e, i) => this._renderRow(this._footerRowOutlet, e, i)),
          this.updateStickyFooterRowStyles()
    }
    _addStickyColumnStyles(e, i) {
      let r = Array.from(i?.columns || []).map(a => {
        let l = this._columnDefsByName.get(a);
        return l
      }),
          o = r.map(a => a.sticky), s = r.map(a => a.stickyEnd);
      this._stickyStyler.updateStickyColumns(
          e, o, s, !this._fixedLayout || this._forceRecalculateCellWidths)
    }
    _getRenderedRows(e) {
      let i = [];
      for (let r = 0; r < e.viewContainer.length; r++) {
        let o = e.viewContainer.get(r);
        i.push(o.rootNodes[0])
      }
      return i
    }
    _getRowDefs(e, i) {
      if (this._rowDefs.length == 1) return [this._rowDefs[0]];
      let r = [];
      if (this.multiTemplateDataRows)
        r = this._rowDefs.filter(o => !o.when || o.when(i, e));
      else {
        let o = this._rowDefs.find(s => s.when && s.when(i, e)) ||
            this._defaultRowDef;
        o && r.push(o)
      }
      return r.length, r
    }
    _getEmbeddedViewArgs(e, i) {
      let r = e.rowDef, o = {$implicit: e.data};
      return {
        templateRef: r.template, context: o, index: i
      }
    }
    _renderRow(e, i, r, o = {}) {
      let s = e.viewContainer.createEmbeddedView(i.template, o, r);
      return this._renderCellTemplateForItem(i, o), s
    }
    _renderCellTemplateForItem(e, i) {
      for (let r of this._getCellTemplates(e))
        $o.mostRecentCellOutlet &&
            $o.mostRecentCellOutlet._viewContainer.createEmbeddedView(r, i);
      this._changeDetectorRef.markForCheck()
    }
    _updateRowIndexContext() {
      let e = this._rowOutlet.viewContainer;
      for (let i = 0, r = e.length; i < r; i++) {
        let s = e.get(i).context;
        s.count = r, s.first = i === 0, s.last = i === r - 1,
        s.even = i % 2 === 0, s.odd = !s.even,
        this.multiTemplateDataRows ?
            (s.dataIndex = this._renderRows[i].dataIndex, s.renderIndex = i) :
            s.index = this._renderRows[i].dataIndex
      }
    }
    _getCellTemplates(e) {
      return !e || !e.columns ? [] : Array.from(e.columns, i => {
        let r = this._columnDefsByName.get(i);
        return e.extractCellTemplate(r)
      })
    }
    _forceRenderDataRows() {
      this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear(),
          this.renderRows()
    }
    _checkStickyStates() {
      let e = (i, r) => i || r.hasStickyChanged();
      this._headerRowDefs.reduce(e, !1) && this.updateStickyHeaderRowStyles(),
          this._footerRowDefs.reduce(e, !1) &&
          this.updateStickyFooterRowStyles(),
          Array.from(this._columnDefsByName.values()).reduce(e, !1) &&
          (this._stickyColumnStylesNeedReset = !0,
           this.updateStickyColumnStyles())
    }
    _setupStickyStyler() {
      let e = this._dir ? this._dir.value : 'ltr';
      this._stickyStyler = new yv(
          this._isNativeHtmlTable, this.stickyCssClass, e,
          this._coalescedStyleScheduler, this._platform.isBrowser,
          this.needsPositionStickyOnElement, this._stickyPositioningListener,
          this._injector),
      (this._dir ? this._dir.change : G())
          .pipe(re(this._onDestroy))
          .subscribe(i => {
            this._stickyStyler.direction = i,
            this.updateStickyColumnStyles()
          })
    }
    _getOwnDefs(e) {
      return e.filter(i => !i._table || i._table === this)
    }
    _updateNoDataRow() {
      let e = this._customNoDataRow || this._noDataRow;
      if (!e) return;
      let i = this._rowOutlet.viewContainer.length === 0;
      if (i === this._isShowingNoDataRow) return;
      let r = this._noDataRowOutlet.viewContainer;
      if (i) {
        let o = r.createEmbeddedView(e.templateRef), s = o.rootNodes[0];
        o.rootNodes.length === 1 &&
            s?.nodeType === this._document.ELEMENT_NODE &&
            (s.setAttribute('role', 'row'),
             s.classList.add(e._contentClassName))
      } else
        r.clear();
      this._isShowingNoDataRow = i, this._changeDetectorRef.markForCheck()
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275cmp = O({
      type: n,
      selectors: [['cdk-table'], ['table', 'cdk-table', '']],
      contentQueries: function(i, r, o) {
        if (i & 1 &&
                (Oe(o, TI, 5), Oe(o, Ca, 5), Oe(o, Rh, 5), Oe(o, pc, 5),
                 Oe(o, Cv, 5)),
            i & 2) {
          let s;
          $(s = W()) && (r._noDataRow = s.first),
              $(s = W()) && (r._contentColumnDefs = s),
              $(s = W()) && (r._contentRowDefs = s),
              $(s = W()) && (r._contentHeaderRowDefs = s),
              $(s = W()) && (r._contentFooterRowDefs = s)
        }
      },
      hostAttrs: [1, 'cdk-table'],
      hostVars: 2,
      hostBindings: function(i, r) {
        i&2 && Y('cdk-table-fixed-layout', r.fixedLayout)
      },
      inputs: {
        trackBy: 'trackBy',
        dataSource: 'dataSource',
        multiTemplateDataRows:
            [2, 'multiTemplateDataRows', 'multiTemplateDataRows', q],
        fixedLayout: [2, 'fixedLayout', 'fixedLayout', q]
      },
      outputs: {contentChanged: 'contentChanged'},
      exportAs: ['cdkTable'],
      features: [ye([
        {provide: Qn, useExisting: n}, {provide: Xl, useClass: la},
        {provide: Sh, useClass: wv}, {provide: Ih, useValue: null}
      ])],
      ngContentSelectors: PH,
      decls: 5,
      vars: 2,
      consts: [
        ['role', 'rowgroup'], ['headerRowOutlet', ''], ['rowOutlet', ''],
        ['noDataRowOutlet', ''], ['footerRowOutlet', '']
      ],
      template: function(i, r) {
        i&1 &&
            (Se(NH), Z(0), Z(1, 1), R(2, FH, 1, 0)(3, LH, 7, 0)(4, VH, 4, 0)),
            i&2 &&
            (b(2), de(r._isServer ? 2 : -1), b(),
             de(r._isNativeHtmlTable ? 3 : 4))
      },
      dependencies: [Sv, kv, Mv, Iv],
      styles: ['.cdk-table-fixed-layout{table-layout:fixed}'],
      encapsulation: 2
    })
  } return n
})();
function Dh(n, t) {
  return n.concat(Array.from(t))
}
function kI(n, t) {
  let e = t.toUpperCase(), i = n.viewContainer.element.nativeElement;
  for (; i;) {
    let r = i.nodeType === 1 ? i.nodeName : null;
    if (r === e) return i;
    if (r === 'TABLE') break;
    i = i.parentNode
  }
  return null
}
var RI = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [Jl]})
  } return n
})();
var BH = [[['caption']], [['colgroup'], ['col']], '*'],
    zH = ['caption', 'colgroup, col', '*'];
function HH(n, t) {
  n&1 && Z(0, 2)
}
function UH(n, t) {
  n&1 &&
      (f(0, 'thead', 0), vt(1, 1), g(), f(2, 'tbody', 2), vt(3, 3)(4, 4), g(),
       f(5, 'tfoot', 0), vt(6, 5), g())
}
function $H(n, t) {
  n&1 && vt(0, 1)(1, 3)(2, 4)(3, 5)
}
var AI = (() => {
  class n extends Tv {
    stickyCssClass = 'mat-mdc-table-sticky';
    needsPositionStickyOnElement = !1;
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275cmp = O({
      type: n,
      selectors: [['mat-table'], ['table', 'mat-table', '']],
      hostAttrs: [1, 'mat-mdc-table', 'mdc-data-table__table'],
      hostVars: 2,
      hostBindings: function(i, r) {
        i&2 && Y('mdc-table-fixed-layout', r.fixedLayout)
      },
      exportAs: ['matTable'],
      features: [
        ye([
          {provide: Tv, useExisting: n}, {provide: Qn, useExisting: n},
          {provide: Sh, useClass: wv}, {provide: Xl, useClass: la},
          {provide: Ih, useValue: null}
        ]),
        te
      ],
      ngContentSelectors: zH,
      decls: 5,
      vars: 2,
      consts: [
        ['role', 'rowgroup'], ['headerRowOutlet', ''],
        ['role', 'rowgroup', 1, 'mdc-data-table__content'], ['rowOutlet', ''],
        ['noDataRowOutlet', ''], ['footerRowOutlet', '']
      ],
      template: function(i, r) {
        i&1 &&
            (Se(BH), Z(0), Z(1, 1), R(2, HH, 1, 0)(3, UH, 7, 0)(4, $H, 4, 0)),
            i&2 &&
            (b(2), de(r._isServer ? 2 : -1), b(),
             de(r._isNativeHtmlTable ? 3 : 4))
      },
      dependencies: [Sv, kv, Mv, Iv],
      styles: [
        '.mat-mdc-table-sticky{position:sticky !important}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{min-width:100%;border:0;border-spacing:0;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color, var(--mat-sys-surface))}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell{text-align:right}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-header-headline-font, var(--mat-sys-title-small-font, Roboto, sans-serif));line-height:var(--mat-table-header-headline-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-table-header-headline-size, var(--mat-sys-title-small-size, 14px));font-weight:var(--mat-table-header-headline-weight, var(--mat-sys-title-small-weight, 500))}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-row-item-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-row-item-label-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-row-item-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-footer-supporting-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-footer-supporting-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-footer-supporting-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-footer-supporting-text-weight, var(--mat-sys-body-medium-weight));letter-spacing:var(--mat-table-footer-supporting-text-tracking, var(--mat-sys-body-medium-tracking))}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking, var(--mat-sys-title-small-tracking));font-weight:inherit;line-height:inherit;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mat-mdc-header-cell{text-align:right}.mdc-data-table__row:last-child>.mat-mdc-header-cell{border-bottom:none}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking));line-height:inherit}.mdc-data-table__row:last-child>.mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking))}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}'
      ],
      encapsulation: 2
    })
  } return n
})(),
    OI = (() => {
      class n extends Mh {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matCellDef', '']],
          features: [ye([{provide: Mh, useExisting: n}]), te]
        })
      } return n
    })(),
    NI = (() => {
      class n extends Th {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['', 'matHeaderCellDef', '']],
          features: [ye([{provide: Th, useExisting: n}]), te]
        })
      } return n
    })();
var PI = (() => {
  class n extends Ca {
    get name() {
      return this._name
    }
    set name(e) {
      this._setNameInput(e)
    }
    _updateColumnCssClassName() {
      super._updateColumnCssClassName(),
          this._columnCssClassName.push(
              `mat-column-${this.cssClassFriendlyName}`)
    }
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275dir = T({
      type: n,
      selectors: [['', 'matColumnDef', '']],
      inputs: {name: [0, 'matColumnDef', 'name']},
      features: [
        ye([
          {provide: Ca, useExisting: n},
          {provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: n}
        ]),
        te
      ]
    })
  } return n
})(),
    FI = (() => {
      class n extends II {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275dir = T({
          type: n,
          selectors: [['mat-header-cell'], ['th', 'mat-header-cell', '']],
          hostAttrs: [
            'role', 'columnheader', 1, 'mat-mdc-header-cell',
            'mdc-data-table__header-cell'
          ],
          features: [te]
        })
      } return n
    })();
var LI = (() => {
  class n extends MI {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275dir = T({
      type: n,
      selectors: [['mat-cell'], ['td', 'mat-cell', '']],
      hostAttrs: [1, 'mat-mdc-cell', 'mdc-data-table__cell'],
      features: [te]
    })
  } return n
})();
var VI = (() => {
  class n extends pc {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275dir = T({
      type: n,
      selectors: [['', 'matHeaderRowDef', '']],
      inputs: {
        columns: [0, 'matHeaderRowDef', 'columns'],
        sticky: [2, 'matHeaderRowDefSticky', 'sticky', q]
      },
      features: [ye([{provide: pc, useExisting: n}]), te]
    })
  } return n
})();
var jI = (() => {
  class n extends Rh {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275dir = T({
      type: n,
      selectors: [['', 'matRowDef', '']],
      inputs: {
        columns: [0, 'matRowDefColumns', 'columns'],
        when: [0, 'matRowDefWhen', 'when']
      },
      features: [ye([{provide: Rh, useExisting: n}]), te]
    })
  } return n
})(),
    BI = (() => {
      class n extends Dv {
        static \u0275fac = (() => {
          let e;
          return function(r) {
            return (e || (e = Te(n)))(r || n)
          }
        })();
        static \u0275cmp = O({
          type: n,
          selectors: [['mat-header-row'], ['tr', 'mat-header-row', '']],
          hostAttrs: [
            'role', 'row', 1, 'mat-mdc-header-row', 'mdc-data-table__header-row'
          ],
          exportAs: ['matHeaderRow'],
          features: [ye([{provide: Dv, useExisting: n}]), te],
          decls: 1,
          vars: 0,
          consts: [['cdkCellOutlet', '']],
          template: function(i, r) {
            i&1 && vt(0, 0)
          },
          dependencies: [$o],
          encapsulation: 2
        })
      } return n
    })();
var zI = (() => {
  class n extends Ev {
    static \u0275fac = (() => {
      let e;
      return function(r) {
        return (e || (e = Te(n)))(r || n)
      }
    })();
    static \u0275cmp = O({
      type: n,
      selectors: [['mat-row'], ['tr', 'mat-row', '']],
      hostAttrs: ['role', 'row', 1, 'mat-mdc-row', 'mdc-data-table__row'],
      exportAs: ['matRow'],
      features: [ye([{provide: Ev, useExisting: n}]), te],
      decls: 1,
      vars: 0,
      consts: [['cdkCellOutlet', '']],
      template: function(i, r) {
        i&1 && vt(0, 0)
      },
      dependencies: [$o],
      encapsulation: 2
    })
  } return n
})();
var HI = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe, RI, pe]})
  } return n
})(),
    WH = 9007199254740991, gc = class extends Xm {
  _data;
  _renderData = new Le([]);
  _filter = new Le('');
  _internalPageChanges = new I;
  _renderChangesSubscription = null;
  filteredData;
  get data() {
    return this._data.value
  }
  set data(t) {
    t = Array.isArray(t) ? t : [], this._data.next(t),
    this._renderChangesSubscription || this._filterData(t)
  }
  get filter() {
    return this._filter.value
  }
  set filter(t) {
    this._filter.next(t),
        this._renderChangesSubscription || this._filterData(this.data)
  }
  get sort() {
    return this._sort
  }
  set sort(t) {
    this._sort = t, this._updateChangeSubscription()
  }
  _sort;
  get paginator() {
    return this._paginator
  }
  set paginator(t) {
    this._paginator = t, this._updateChangeSubscription()
  }
  _paginator;
  sortingDataAccessor = (t, e) => {
    let i = t[e];
    if (lb(i)) {
      let r = Number(i);
      return r < WH ? r : i
    }
    return i
  };
  sortData = (t, e) => {
    let i = e.active, r = e.direction;
    return !i || r == '' ? t : t.sort((o, s) => {
      let a = this.sortingDataAccessor(o, i),
          l = this.sortingDataAccessor(s, i), c = typeof a, d = typeof l;
      c !== d && (c === 'number' && (a += ''), d === 'number' && (l += ''));
      let m = 0;
      return a != null && l != null ? a > l ? m = 1 : a < l && (m = -1) :
                 a != null          ? m = 1 :
                                      l != null && (m = -1),
                                              m * (r == 'asc' ? 1 : -1)
    })
  };
  filterPredicate = (t, e) => {
    let i = e.trim().toLowerCase();
    return Object.values(t).some(r => `${r}`.toLowerCase().includes(i))
  };
  constructor(t = []) {
    super(), this._data = new Le(t), this._updateChangeSubscription()
  }
  _updateChangeSubscription() {
    let t = this._sort ? Ke(this._sort.sortChange, this._sort.initialized) :
                         G(null),
        e = this._paginator ?
        Ke(this._paginator.page, this._internalPageChanges,
           this._paginator.initialized) :
        G(null),
        i = this._data,
        r = Mn([i, this._filter]).pipe(Q(([a]) => this._filterData(a))),
        o = Mn([r, t]).pipe(Q(([a]) => this._orderData(a))),
        s = Mn([o, e]).pipe(Q(([a]) => this._pageData(a)));
    this._renderChangesSubscription?.unsubscribe(),
        this._renderChangesSubscription =
            s.subscribe(a => this._renderData.next(a))
  }
  _filterData(t) {
    return this.filteredData = this.filter == null || this.filter === '' ?
               t :
               t.filter(e => this.filterPredicate(e, this.filter)),
           this.paginator && this._updatePaginator(this.filteredData.length),
           this.filteredData
  }
  _orderData(t) {
    return this.sort ? this.sortData(t.slice(), this.sort) : t
  }
  _pageData(t) {
    if (!this.paginator) return t;
    let e = this.paginator.pageIndex * this.paginator.pageSize;
    return t.slice(e, e + this.paginator.pageSize)
  }
  _updatePaginator(t) {
    Promise.resolve().then(() => {
      let e = this.paginator;
      if (e && (e.length = t, e.pageIndex > 0)) {
        let i = Math.ceil(e.length / e.pageSize) - 1 || 0,
            r = Math.min(e.pageIndex, i);
        r !== e.pageIndex && (e.pageIndex = r, this._internalPageChanges.next())
      }
    })
  }
  connect() {
    return this._renderChangesSubscription || this._updateChangeSubscription(),
           this._renderData
  }
  disconnect() {
    this._renderChangesSubscription?.unsubscribe(),
        this._renderChangesSubscription = null
  }
};
var It = [];
for (let n = 0; n < 256; ++n) It.push((n + 256).toString(16).slice(1));
function UI(n, t = 0) {
  return (It[n[t + 0]] + It[n[t + 1]] + It[n[t + 2]] + It[n[t + 3]] + '-' +
          It[n[t + 4]] + It[n[t + 5]] + '-' + It[n[t + 6]] + It[n[t + 7]] +
          '-' + It[n[t + 8]] + It[n[t + 9]] + '-' + It[n[t + 10]] +
          It[n[t + 11]] + It[n[t + 12]] + It[n[t + 13]] + It[n[t + 14]] +
          It[n[t + 15]])
      .toLowerCase()
}
var Rv, GH = new Uint8Array(16);
function Av() {
  if (!Rv) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
          'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    Rv = crypto.getRandomValues.bind(crypto)
  }
  return Rv(GH)
}
var QH =
    typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
    Ov = {randomUUID: QH};
function YH(n, t, e) {
  if (Ov.randomUUID && !t && !n) return Ov.randomUUID();
  n = n || {};
  let i = n.random ?? n.rng?.() ?? Av();
  if (i.length < 16) throw new Error('Random bytes length must be >= 16');
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, t) {
    if (e = e || 0, e < 0 || e + 16 > t.length)
      throw new RangeError(
          `UUID byte range ${e}:${e + 15} is out of buffer bounds`);
    for (let r = 0; r < 16; ++r) t[e + r] = i[r];
    return t
  }
  return UI(i)
}
var _c = YH;
var Si = class n {
  constructor(t) {
    this.http = t
  }
  apiServerDomain = rn.getApiServerBaseUrl();
  getEvalSets(t) {
    let e = this.apiServerDomain + `/apps/${t}/eval_sets`;
    return this.http.get(e)
  }
  createNewEvalSet(t, e) {
    let i = this.apiServerDomain + `/apps/${t}/eval_sets/${e}`;
    return this.http.post(i, {})
  }
  listEvalCases(t, e) {
    let i = this.apiServerDomain + `/apps/${t}/eval_sets/${e}/evals`;
    return this.http.get(i, {})
  }
  addCurrentSession(t, e, i, r, o) {
    let s = this.apiServerDomain + `/apps/${t}/eval_sets/${e}/add_session`;
    return this.http.post(s, {eval_id: i, session_id: r, user_id: o})
  }
  runEval(t, e, i, r) {
    let o = this.apiServerDomain + `/apps/${t}/eval_sets/${e}/run_eval`;
    return this.http.post(o, {eval_ids: i, eval_metrics: r})
  }
  static \u0275fac = function(e) {
    return new (e || n)(A(zt))
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
var bc = class n {
  constructor(t, e, i) {
    this.evalService = t;
    this.data = e;
    this.dialogRef = i
  }
  newCaseId = 'case' + _c().slice(0, 6);
  createNewEvalCase() {
    !this.newCaseId || this.newCaseId == '' ?
        alert('Cannot create eval set with empty id!') :
        this.evalService
            .addCurrentSession(
                this.data.appName, this.data.evalSetId, this.newCaseId,
                this.data.sessionId, this.data.userId)
            .subscribe(t => {console.log(t), this.dialogRef.close(!0)})
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Si), z(nr), z(hn))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-add-eval-session-dialog']],
    standalone: !1,
    decls: 11,
    vars: 1,
    consts:
        [
          ['mat-dialog-title', ''],
          [2, 'padding-left', '20px', 'padding-right', '24px'],
          ['matInput', '', 3, 'ngModelChange', 'ngModel'], ['align', 'end'],
          ['mat-button', '', 'mat-dialog-close', ''],
          ['mat-button', '', 'cdkFocusInitial', '', 3, 'click']
        ],
    template:
        function(e, i) {
          e&1 &&
              (f(0, 'h2', 0), E(1, 'Add Current Session To Eval Set'), g(),
               f(2, 'mat-dialog-content'),
               E(3, ` Please enter the eval case name
`),
               g(), f(4, 'mat-form-field', 1)(5, 'input', 2),
               $i('ngModelChange',
                  function(o) {
                    return xr(i.newCaseId, o) || (i.newCaseId = o), o
                  }),
               g()(), f(6, 'mat-dialog-actions', 3)(7, 'button', 4),
               E(8, 'Cancel'), g(), f(9, 'button', 5),
               M('click',
                 function() {
                   return i.createNewEvalCase()
                 }),
               E(10, 'Create'), g()()),
              e&2 && (b(5), Ui('ngModel', i.newCaseId))
        },
    dependencies: [pi, Tr, Gi, xi, Yr, bi, qr, Gr, Qr, fa],
    encapsulation: 2
  })
};
var vc = class n {
  constructor(t, e, i) {
    this.evalService = t;
    this.data = e;
    this.dialogRef = i
  }
  newSetId = 'evalset' + _c().slice(0, 6);
  createNewEvalSet() {
    !this.newSetId || this.newSetId == '' ?
        alert('Cannot create eval set with empty id!') :
        this.evalService.createNewEvalSet(this.data.appName, this.newSetId)
            .subscribe(t => {this.dialogRef.close(!0)})
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Si), z(nr), z(hn))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-new-eval-set-dialog-component']],
    standalone: !1,
    decls: 11,
    vars: 1,
    consts:
        [
          ['mat-dialog-title', ''],
          [2, 'padding-left', '20px', 'padding-right', '24px'],
          ['matInput', '', 3, 'ngModelChange', 'ngModel'], ['align', 'end'],
          ['mat-button', '', 'mat-dialog-close', ''],
          ['mat-button', '', 'cdkFocusInitial', '', 3, 'click']
        ],
    template:
        function(e, i) {
          e&1 &&
              (f(0, 'h2', 0), E(1, 'Create New Eval Set'), g(),
               f(2, 'mat-dialog-content'), E(3, ` Please enter the eval set name
`),
               g(), f(4, 'mat-form-field', 1)(5, 'input', 2),
               $i('ngModelChange',
                  function(o) {
                    return xr(i.newSetId, o) || (i.newSetId = o), o
                  }),
               g()(), f(6, 'mat-dialog-actions', 3)(7, 'button', 4),
               E(8, 'Cancel'), g(), f(9, 'button', 5),
               M('click',
                 function() {
                   return i.createNewEvalSet()
                 }),
               E(10, 'Create'), g()()),
              e&2 && (b(5), Ui('ngModel', i.newSetId))
        },
    dependencies: [pi, Tr, Gi, xi, Yr, bi, qr, Gr, Qr, fa],
    encapsulation: 2
  })
};
var ZH = ['determinateSpinner'];
function KH(n, t) {
  if (n & 1 && (Bt(), f(0, 'svg', 11), B(1, 'circle', 12), g()), n & 2) {
    let e = D();
    J('viewBox', e._viewBox()), b(),
        Pt('stroke-dasharray', e._strokeCircumference(), 'px')(
            'stroke-dashoffset', e._strokeCircumference() / 2, 'px')(
            'stroke-width', e._circleStrokeWidth(), '%'),
        J('r', e._circleRadius())
  }
}
var XH = new w(
    'mat-progress-spinner-default-options', {providedIn: 'root', factory: JH});
function JH() {
  return {
    diameter: $I
  }
}
var $I = 100, eU = 10, WI = (() => {
                         class n {
                           _elementRef = u(L);
                           _noopAnimations;
                           get color() {
                             return this._color || this._defaultColor
                           }
                           set color(e) {
                             this._color = e
                           }
                           _color;
                           _defaultColor = 'primary';
                           _determinateCircle;
                           constructor() {
                             let e = u(Ve, {optional: !0}), i = u(XH);
                             this._noopAnimations = e === 'NoopAnimations' &&
                                 !!i && !i._forceAnimations,
                             this.mode = this._elementRef.nativeElement.nodeName
                                             .toLowerCase() === 'mat-spinner' ?
                                 'indeterminate' :
                                 'determinate',
                             i &&
                                 (i.color &&
                                      (this.color = this._defaultColor =
                                           i.color),
                                  i.diameter && (this.diameter = i.diameter),
                                  i.strokeWidth &&
                                      (this.strokeWidth = i.strokeWidth))
                           }
                           mode;
                           get value() {
                             return this.mode === 'determinate' ? this._value :
                                                                  0
                           }
                           set value(e) {
                             this._value = Math.max(0, Math.min(100, e || 0))
                           }
                           _value = 0;
                           get diameter() {
                             return this._diameter
                           }
                           set diameter(e) {
                             this._diameter = e || 0
                           }
                           _diameter = $I;
                           get strokeWidth() {
                             return this._strokeWidth ?? this.diameter / 10
                           }
                           set strokeWidth(e) {
                             this._strokeWidth = e || 0
                           }
                           _strokeWidth;
                           _circleRadius() {
                             return (this.diameter - eU) / 2
                           }
                           _viewBox() {
                             let e =
                                 this._circleRadius() * 2 + this.strokeWidth;
                             return `0 0 ${e} ${e}`
                           }
                           _strokeCircumference() {
                             return 2 * Math.PI * this._circleRadius()
                           }
                           _strokeDashOffset() {
                             return this.mode === 'determinate' ?
                                 this._strokeCircumference() *
                                     (100 - this._value) / 100 :
                                 null
                           }
                           _circleStrokeWidth() {
                             return this.strokeWidth / this.diameter * 100
                           }
                           static \u0275fac = function(i) {
                             return new (i || n)
                           };
                           static \u0275cmp =
                               O(
                                   {
                                     type: n,
                                     selectors: [
                                       ['mat-progress-spinner'], ['mat-spinner']
                                     ],
                                     viewQuery: function(i, r) {
                                       if (i & 1 && oe(ZH, 5), i & 2) {
                                         let o;
                                         $(o = W()) &&
                                             (r._determinateCircle = o.first)
                                       }
                                     },
                                     hostAttrs: [
                                       'role', 'progressbar', 'tabindex', '-1',
                                       1, 'mat-mdc-progress-spinner',
                                       'mdc-circular-progress'
                                     ],
                                     hostVars: 18,
                                     hostBindings: function(i, r) {
                                       i&2 &&
                                           (J('aria-valuemin', 0)(
                                                'aria-valuemax', 100)(
                                                'aria-valuenow',
                                                r.mode === 'determinate' ?
                                                    r.value :
                                                    null)('mode', r.mode),
                                            kt('mat-' + r.color),
                                            Pt('width', r.diameter, 'px')(
                                                'height', r.diameter, 'px')(
                                                '--mdc-circular-progress-size',
                                                r.diameter + 'px')(
                                                '--mdc-circular-progress-active-indicator-width',
                                                r.diameter + 'px'),
                                            Y('_mat-animation-noopable',
                                              r._noopAnimations)(
                                                'mdc-circular-progress--indeterminate',
                                                r.mode === 'indeterminate'))
                                     },
                                     inputs: {
                                       color: 'color',
                                       mode: 'mode',
                                       value: [2, 'value', 'value', st],
                                       diameter:
                                           [2, 'diameter', 'diameter', st],
                                       strokeWidth:
                                           [2, 'strokeWidth', 'strokeWidth', st]
                                     },
                                     exportAs: ['matProgressSpinner'],
                                     decls: 14,
                                     vars: 11,
                                     consts: [
                                       ['circle', ''],
                                       ['determinateSpinner', ''],
                                       [
                                         'aria-hidden', 'true', 1,
                                         'mdc-circular-progress__determinate-container'
                                       ],
                                       [
                                         'xmlns', 'http://www.w3.org/2000/svg',
                                         'focusable', 'false', 1,
                                         'mdc-circular-progress__determinate-circle-graphic'
                                       ],
                                       [
                                         'cx', '50%', 'cy', '50%', 1,
                                         'mdc-circular-progress__determinate-circle'
                                       ],
                                       [
                                         'aria-hidden', 'true', 1,
                                         'mdc-circular-progress__indeterminate-container'
                                       ],
                                       [
                                         1,
                                         'mdc-circular-progress__spinner-layer'
                                       ],
                                       [
                                         1,
                                         'mdc-circular-progress__circle-clipper',
                                         'mdc-circular-progress__circle-left'
                                       ],
                                       [3, 'ngTemplateOutlet'],
                                       [1, 'mdc-circular-progress__gap-patch'],
                                       [
                                         1,
                                         'mdc-circular-progress__circle-clipper',
                                         'mdc-circular-progress__circle-right'
                                       ],
                                       [
                                         'xmlns', 'http://www.w3.org/2000/svg',
                                         'focusable', 'false', 1,
                                         'mdc-circular-progress__indeterminate-circle-graphic'
                                       ],
                                       ['cx', '50%', 'cy', '50%']
                                     ],
                                     template: function(i, r) {
                                       if (i & 1 &&
                                               (R(0, KH, 2, 8, 'ng-template',
                                                  null, 0, dl),
                                                f(2, 'div', 2, 1), Bt(),
                                                f(4, 'svg', 3),
                                                B(5, 'circle', 4), g()(), wo(),
                                                f(6, 'div', 5)(7, 'div', 6)(
                                                    8, 'div', 7),
                                                vt(9, 8), g(), f(10, 'div', 9),
                                                vt(11, 8), g(),
                                                f(12, 'div', 10), vt(13, 8),
                                                g()()()),
                                           i & 2) {
                                         let o = yt(1);
                                         b(4), J('viewBox', r._viewBox()), b(),
                                             Pt('stroke-dasharray',
                                                r._strokeCircumference(), 'px')(
                                                 'stroke-dashoffset',
                                                 r._strokeDashOffset(), 'px')(
                                                 'stroke-width',
                                                 r._circleStrokeWidth(), '%'),
                                             J('r', r._circleRadius()), b(4),
                                             x('ngTemplateOutlet', o), b(2),
                                             x('ngTemplateOutlet', o), b(2),
                                             x('ngTemplateOutlet', o)
                                       }
                                     },
                                     dependencies: [Pu],
                                     styles: [
                                       '.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0;position:relative;direction:ltr;transition:opacity 250ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width, 4px)}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1;animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, var(--mat-sys-primary))}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}'
                                     ],
                                     encapsulation: 2,
                                     changeDetection: 0
                                   })
                         } return n
                       })();
var qI = (() => {
  class n {
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275mod = j({type: n});
    static \u0275inj = V({imports: [pe]})
  } return n
})();
function nU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 3)(1, 'div'), E(2, 'All eval sets'), g(), f(3, 'mat-icon', 4),
        M('click', function() {
          N(e);
          let r = D();
          return P(r.openNewEvalSetDialog())
        }), E(4, 'add'), g()()
  }
}
function iU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div')(1, 'div', 5)(2, 'div', 6), E(3, ' Create New Evaluation Set '),
        g(), f(4, 'div', 7),
        E(5,
          ' An evaluation set is a curated collection of evaluation cases, where each case includes input-output examples for assessing agent performance. '),
        g(), f(6, 'div', 8), M('click', function() {
          N(e);
          let r = D();
          return P(r.openNewEvalSetDialog())
        }), E(7, ' Create Evaluation Set '), g()()()
  }
}
function rU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 10),
        M('click',
          function() {
            let r = N(e).$implicit, o = D(2);
            return P(o.selectEvalSet(r))
          }),
        f(1, 'div', 11)(2, 'span', 12), E(3, 'folder'), g(), f(4, 'div', 13),
        E(5), g()(), f(6, 'div')(7, 'mat-icon', 14), E(8, 'chevron_right'),
        g()()()
  }
  if (n & 2) {
    let e = t.$implicit;
    b(5), Re(e)
  }
}
function oU(n, t) {
  if (n & 1 && (f(0, 'div'), R(1, rU, 9, 1, 'div', 9), g()), n & 2) {
    let e = D();
    b(), x('ngForOf', e.evalsets)
  }
}
function sU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'th', 29)(1, 'mat-checkbox', 30), M('change', function(r) {
      N(e);
      let o = D(3);
      return P(r ? o.toggleAllRows() : null)
    }), g()()
  }
  if (n & 2) {
    let e = D(3);
    b(),
        x('checked', e.selection.hasValue() && e.isAllSelected())(
            'indeterminate', e.selection.hasValue() && !e.isAllSelected())
  }
}
function aU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'td', 31)(1, 'mat-checkbox', 32), M('click', function(r) {
      return N(e), P(r.stopPropagation())
    })('change', function(r) {
      let o = N(e).$implicit, s = D(3);
      return P(r ? s.selection.toggle(o) : null)
    }), g()()
  }
  if (n & 2) {
    let e = t.$implicit, i = D(3);
    b(), x('checked', i.selection.isSelected(e))
  }
}
function lU(n, t) {
  n&1 && (f(0, 'th', 29), E(1, ' Case ID '), g())
}
function cU(n, t) {
  if (n & 1 && (f(0, 'td', 31), E(1), g()), n & 2) {
    let e = t.$implicit;
    b(), at(' ', e, ' ')
  }
}
function dU(n, t) {
  n&1 && (f(0, 'th', 29), E(1, ' Result '), g())
}
function uU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 35), M('click', function() {
      N(e);
      let r = D().$implicit, o = D(3);
      return P(o.getSession(r))
    }), f(1, 'span', 36), E(2), g(), f(3, 'div', 37), E(4), g()()
  }
  if (n & 2) {
    let e = D().$implicit, i = D(3);
    x('ngClass',
      i.getEvalResultForCase(e) == 1 ? 'result-btn pass' : 'result-btn fail'),
        b(2), at(' ', i.getEvalResultForCase(e) == 1 ? 'check' : 'close', ' '),
        b(2), at('', i.getEvalResultForCase(e) == 1 ? 'PASS' : 'FAIL', ' ')
  }
}
function mU(n, t) {
  if (n & 1 && (f(0, 'td', 33), R(1, uU, 5, 3, 'button', 34), g()), n & 2) {
    let e = t.$implicit, i = D(3);
    b(), x('ngIf', i.getEvalResultForCase(e))
  }
}
function hU(n, t) {
  n&1 && B(0, 'tr', 38)
}
function fU(n, t) {
  n&1 && B(0, 'tr', 39)
}
function pU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div')(1, 'button', 18),
        M('click',
          function() {
            N(e);
            let r = D(2);
            return P(r.runEval())
          }),
        E(2, 'Run Evaluation'), g(), f(3, 'div', 19)(4, 'table', 20), Vn(5, 21),
        R(6, sU, 2, 2, 'th', 22)(7, aU, 2, 1, 'td', 23), jn(), Vn(8, 24),
        R(9, lU, 2, 0, 'th', 22)(10, cU, 2, 1, 'td', 23), jn(), Vn(11, 25),
        R(12, dU, 2, 0, 'th', 22)(13, mU, 2, 1, 'td', 26), jn(),
        R(14, hU, 1, 0, 'tr', 27)(15, fU, 1, 0, 'tr', 28), g()()()
  }
  if (n & 2) {
    let e = D(2);
    b(4), x('dataSource', e.dataSource), b(10),
        x('matHeaderRowDef', e.displayedColumns), b(),
        x('matRowDefColumns', e.displayedColumns)
  }
}
function gU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 40),
        M('click',
          function() {
            N(e);
            let r = D(2);
            return P(r.openNewEvalCaseDialog())
          }),
        f(1, 'div', 41)(2, 'mat-icon'), E(3, 'add'), g(), f(4, 'div', 42), E(5),
        g()()()
  }
  if (n & 2) {
    let e = D(2);
    b(5), at(' Add current session to ', e.selectedEvalSet, ' ')
  }
}
function _U(n, t) {
  n&1 && (f(0, 'div'), B(1, 'mat-spinner'), g())
}
function bU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div')(1, 'div', 11)(2, 'mat-icon', 15),
        M('click',
          function() {
            N(e);
            let r = D();
            return P(r.clearSelectedEvalSet())
          }),
        E(3, 'chevron_left'), g(), f(4, 'div', 16),
        M('click',
          function() {
            N(e);
            let r = D();
            return P(r.clearSelectedEvalSet())
          }),
        E(5), g()(),
        R(6, pU, 16, 3, 'div', 2)(7, gU, 6, 1, 'button', 17)(
            8, _U, 2, 0, 'div', 2),
        g()
  }
  if (n & 2) {
    let e = D();
    b(5), at(' ', e.selectedEvalSet, ' '), b(),
        x('ngIf', e.evalCases.length > 0 && !e.evalRunning), b(),
        x('ngIf', !e.evalRunning), b(), x('ngIf', e.evalRunning)
  }
}
var yc = class n {
  constructor(t, e) {
    this.evalService = t;
    this.sessionService = e
  }
  checkboxes;
  appName = '';
  userId = '';
  sessionId = '';
  sessionSelected = new H;
  displayedColumns = ['select', 'eval_id', 'final_eval_status'];
  evalsets = [];
  selectedEvalSet = '';
  evalCases = [];
  dataSource = new gc(this.evalCases);
  selection = new ca(!0, []);
  evalRunning = !1;
  evalMetrics = [{metric_name: 'tool_trajectory_avg_score', threshold: 1}];
  evalResult = [];
  dialog = u(Wr);
  ngOnInit() {
    this.getEvalSet()
  }
  getEvalSet() {
    this.appName != '' &&
        this.evalService.getEvalSets(this.appName)
            .subscribe(t => {this.evalsets = t})
  }
  openNewEvalSetDialog() {
    this.dialog.open(vc, {width: '600px', data: {appName: this.appName}})
        .afterClosed()
        .subscribe(e => {e && this.getEvalSet()})
  }
  openNewEvalCaseDialog() {
    this.dialog
        .open(bc, {
          width: '600px',
          data: {
            appName: this.appName,
            userId: this.userId,
            sessionId: this.sessionId,
            evalSetId: this.selectedEvalSet
          }
        })
        .afterClosed()
        .subscribe(e => {e && this.listEvalCases()})
  }
  listEvalCases() {
    this.evalCases = [],
    this.evalService.listEvalCases(this.appName, this.selectedEvalSet)
        .subscribe(
            t => {this.evalCases = t, this.dataSource = new gc(this.evalCases)})
  }
  runEval() {
    if (this.evalRunning = !0, this.selection.selected.length == 0) {
      alert('No case selected!'), this.evalRunning = !1;
      return
    }
    this.evalService
        .runEval(
            this.appName, this.selectedEvalSet, this.selection.selected,
            this.evalMetrics)
        .subscribe(t => {this.evalRunning = !1, this.evalResult = t})
  }
  selectEvalSet(t) {
    this.selectedEvalSet = t, this.listEvalCases()
  }
  clearSelectedEvalSet() {
    this.selectedEvalSet = ''
  }
  isAllSelected() {
    let t = this.selection.selected.length, e = this.dataSource.data.length;
    return t === e
  }
  toggleAllRows() {
    if (this.isAllSelected()) {
      this.selection.clear();
      return
    }
    this.selection.select(...this.dataSource.data)
  }
  getEvalResultForCase(t) {
    let e = this.evalResult.filter(i => i.eval_id == t);
    if (e.length != 0) return e[0].final_eval_status
  }
  fromApiResultToSession(t) {
    return {
      id: t?.id ?? '', app_name: t?.app_name ?? '', user_id: t?.user_id ?? '',
          state: t?.state ?? [], events: t?.events ?? []
    }
  }
  getSession(t) {
    let e = this.evalResult.filter(i => i.eval_id == t)[0].session_id;
    this.sessionService.getSession(this.userId, this.appName, e)
        .subscribe(i => {
          let r = this.fromApiResultToSession(i);
          this.sessionSelected.emit(r)
        })
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Si), z(Wn))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-eval-tab']],
    viewQuery:
        function(e, i) {
          if (e & 1 && oe(xa, 5), e & 2) {
            let r;
            $(r = W()) && (i.checkboxes = r)
          }
        },
    inputs: {appName: 'appName', userId: 'userId', sessionId: 'sessionId'},
    outputs: {sessionSelected: 'sessionSelected'},
    standalone: !1,
    decls: 5,
    vars: 4,
    consts:
        [
          [1, 'eval-container'],
          ['class', 'eval-set-actions', 4, 'ngIf'],
          [4, 'ngIf'],
          [1, 'eval-set-actions'],
          [2, 'cursor', 'pointer', 3, 'click'],
          [1, 'empty-eval-info'],
          [1, 'info-title'],
          [1, 'info-detail'],
          [1, 'info-create', 3, 'click'],
          ['class', 'eval-set-row', 3, 'click', 4, 'ngFor', 'ngForOf'],
          [1, 'eval-set-row', 3, 'click'],
          [2, 'display', 'flex'],
          [
            1, 'material-symbols-outlined', 2, 'margin-right', '10px',
            'padding-top', '16px'
          ],
          [
            2, 'font-family', 'Roboto', 'font-size', '14px', 'padding', '16px',
            'padding-top', '20px'
          ],
          [2, 'padding-top', '20px', 'color', '#9AA0A6'],
          [2, 'color', 'white', 'cursor', 'pointer', 3, 'click'],
          [
            2, 'color', '#9AA0A6', 'padding-top', '2px', 'cursor', 'pointer', 3,
            'click'
          ],
          ['class', 'save-session-btn', 3, 'click', 4, 'ngIf'],
          [1, 'run-eval-btn', 3, 'click'],
          [1, 'mat-table-container', 2, 'margin-top', '16px'],
          ['mat-table', '', 3, 'dataSource'],
          ['matColumnDef', 'select'],
          ['mat-header-cell', '', 4, 'matHeaderCellDef'],
          ['mat-cell', '', 4, 'matCellDef'],
          ['matColumnDef', 'eval_id'],
          ['matColumnDef', 'final_eval_status'],
          [
            'mat-cell', '', 'style', 'display: flex; color:white;', 4,
            'matCellDef'
          ],
          ['mat-header-row', '', 4, 'matHeaderRowDef'],
          ['mat-row', '', 4, 'matRowDef', 'matRowDefColumns'],
          ['mat-header-cell', ''],
          [3, 'change', 'checked', 'indeterminate'],
          ['mat-cell', ''],
          [3, 'click', 'change', 'checked'],
          ['mat-cell', '', 2, 'display', 'flex', 'color', 'white'],
          [3, 'ngClass', 'click', 4, 'ngIf'],
          [3, 'click', 'ngClass'],
          [1, 'material-symbols-outlined'],
          [2, 'padding-top', '4px'],
          ['mat-header-row', ''],
          ['mat-row', ''],
          [1, 'save-session-btn', 3, 'click'],
          [1, 'save-session-btn-detail'],
          [1, 'save-session-btn-text']
        ],
    template:
        function(e, i) {
          e&1 &&
              (f(0, 'div', 0),
               R(1, nU, 5, 0, 'div', 1)(2, iU, 8, 0, 'div', 2)(
                   3, oU, 2, 1, 'div', 2)(4, bU, 9, 4, 'div', 2),
               g()),
              e&2 &&
              (b(), x('ngIf', i.selectedEvalSet == ''), b(),
               x('ngIf', i.evalsets.length == 0), b(),
               x('ngIf', i.evalsets.length > 0 && i.selectedEvalSet == ''), b(),
               x('ngIf', i.selectedEvalSet != ''))
        },
    dependencies:
        [vn, yn, fi, va, xa, AI, NI, VI, PI, OI, jI, FI, LI, BI, zI, WI],
    styles:
        [
          '.eval-container[_ngcontent-%COMP%]{margin-top:20px;padding-left:25px;padding-right:25px}.eval-set-actions[_ngcontent-%COMP%]{display:flex;justify-content:space-between;color:#9aa0a6;font-style:normal;font-weight:700;font-size:14px}.empty-eval-info[_ngcontent-%COMP%]{margin-top:12px;background-color:#202124;border-radius:8px;box-shadow:0 2px 6px 2px #00000026,0 1px 2px #0000004d}.info-title[_ngcontent-%COMP%]{color:#e8eaed;font-family:Roboto;font-size:14px;font-weight:500;padding-top:13px;padding-right:16px;padding-left:16px}.info-detail[_ngcontent-%COMP%]{color:#e8eaed;font-family:Roboto;font-size:14px;font-weight:400;padding-top:13px;padding-right:16px;padding-left:16px;letter-spacing:.2px}.info-create[_ngcontent-%COMP%]{color:var(--Blue-300, #8AB4F8);font-size:14px;font-style:normal;font-weight:500;padding-right:16px;padding-left:16px;margin-top:19px;padding-bottom:16px;cursor:pointer}.eval-set-row[_ngcontent-%COMP%]{display:flex;justify-content:space-between;cursor:pointer}.save-session-btn[_ngcontent-%COMP%]{width:100%;background:linear-gradient(0deg,#8ab4f83d 0% 100%),#202124;border:none;border-radius:4px;margin-top:12px;cursor:pointer}.save-session-btn-detail[_ngcontent-%COMP%]{display:flex;padding:8px 16px 8px 12px;justify-content:center}.save-session-btn-text[_ngcontent-%COMP%]{padding-top:2px;color:var(--Blue-100, #D2E3FC);font-family:Google Sans;font-size:14px;font-style:normal;font-weight:500;line-height:20px;letter-spacing:.25px}.run-eval-btn[_ngcontent-%COMP%]{border-radius:4px;border:1px solid var(--Grey-700, #5F6368);background-color:transparent;padding:8px 24px;margin-top:16px;color:#8ab4f8;cursor:pointer}.run-eval-btn[_ngcontent-%COMP%]:hover{background-color:#202124}.result-btn[_ngcontent-%COMP%]{display:flex;background-color:transparent;border-radius:4px;border:1px solid var(--Grey-700, #5F6368);margin-top:13px;cursor:pointer}.result-btn[_ngcontent-%COMP%]:hover{background-color:#202124}.result-btn.pass[_ngcontent-%COMP%]{color:#44c265}.result-btn.fail[_ngcontent-%COMP%]{color:#ff8983}'
        ]
  })
};
var Da = class n {
  downloadBase64Image(t, e, i = 'image.png') {
    try {
      let r = document.createElement('a');
      r.href = t, r.download = i, document.body.appendChild(r), r.click(),
      document.body.removeChild(r)
    } catch (r) {
      throw console.error('Error downloading base64 image:', r), r
    }
  }
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275prov = C({token: n, factory: n.\u0275fac, providedIn: 'root'})
};
function wU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 2), B(1, 'img', 3), f(2, 'div', 4), M('click', function() {
      let r = N(e).$implicit, o = D();
      return P(o.downloadArtifact(r))
    }), f(3, 'mat-icon'), E(4, 'file_download'), g()()()
  }
  if (n & 2) {
    let e, i = t.$implicit;
    b(), x('src', (e = i.data) !== null && e !== void 0 ? e : '', yr)
  }
}
var wc = class n {
  constructor(t) {
    this.downloadService = t
  }
  artifacts = [];
  downloadArtifact(t) {
    this.downloadService.downloadBase64Image(t.data, t.mimeType)
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Da))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-artifact-tab']],
    inputs: {artifacts: 'artifacts'},
    standalone: !1,
    decls: 2,
    vars: 1,
    consts:
        [
          [1, 'image-container'], ['class', 'image-box', 4, 'ngFor', 'ngForOf'],
          [1, 'image-box'],
          ['alt', 'artifact.id', 1, 'generated-image', 3, 'src'],
          [1, 'download-overlay', 3, 'click']
        ],
    template:
        function(e, i) {
          e&1 && (f(0, 'div', 0), R(1, wU, 5, 1, 'div', 1), g()),
              e&2 && (b(), x('ngForOf', i.artifacts))
        },
    dependencies: [yn, va],
    styles:
        [
          '.image-container[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap}.image-box[_ngcontent-%COMP%]{padding:10px;margin-bottom:10px;max-width:45%;margin-right:4px;position:relative;display:inline-block}.download-button[_ngcontent-%COMP%]{position:absolute;top:10px;right:10px;background-color:#fffc;border:1px solid rgba(0,0,0,.2);padding:6px;border-radius:50%;cursor:pointer;opacity:0;transition:opacity .3s ease-in-out;display:flex;align-items:center;justify-content:center}.download-button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#333;font-size:18px}.generated-image[_ngcontent-%COMP%]{max-width:100%}.download-overlay[_ngcontent-%COMP%]{position:absolute;top:10px;right:10px;background-color:#00000080;color:#fff;padding:8px;border-radius:4px;cursor:pointer;opacity:0;transition:opacity .3s ease-in-out}.image-box[_ngcontent-%COMP%]:hover > .download-overlay[_ngcontent-%COMP%]{opacity:1}.download-icon[_ngcontent-%COMP%]{width:20px;height:20px}'
        ]
  })
};
var xc = class n {
  sessionState = {};
  constructor() {}
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-state-tab']],
    inputs: {sessionState: 'sessionState'},
    standalone: !1,
    decls: 3,
    vars: 1,
    consts: [[1, 'state-wrapper'], [3, 'json']],
    template:
        function(e, i) {
          e&1 && (f(0, 'div', 0)(1, 'div'), B(2, 'ngx-json-viewer', 1), g()()),
              e&2 && (b(2), x('json', i.sessionState))
        },
    dependencies: [_h],
    styles:
        [
          '.state-wrapper[_ngcontent-%COMP%]{padding-left:25px;padding-right:25px;margin-top:16px}'
        ]
  })
};
var DU = ['videoContainer'], EU = ['sidenav'], kU = () => [],
    SU = (n, t) => ({'user-message': n, 'bot-message': t}),
    GI = n => ({'background-color': n});
function IU(n, t) {
  if (n & 1 && (f(0, 'mat-option', 19), E(1), g()), n & 2) {
    let e = t.$implicit;
    x('value', e), b(), Re(e)
  }
}
function MU(n, t) {
  n&1 && Do(0, IU, 2, 2, 'mat-option', 19, Co), n&2 && Eo(t)
}
function TU(n, t) {
  if (n & 1 && (f(0, 'mat-option', 19), E(1), g()), n & 2) {
    let e = D(2);
    x('value', e.selectedAppControl.value), b(), Re(e.selectedAppControl.value)
  }
}
function RU(n, t) {
  if (n & 1 &&
          (f(0, 'div', 9)(1, 'mat-select', 18), R(2, MU, 2, 0), Cr(3, 'async'),
           R(4, TU, 2, 2, 'mat-option', 19), g()()),
      n & 2) {
    let e, i = D();
    b(),
        x('placeholder', i.isLoadingApps() ? 'Loading...' : 'Select an agent')(
            'formControl', i.selectedAppControl),
        b(), de((e = As(3, 4, i.apps$)) ? 2 : -1, e), b(2),
        de(i.selectedAppControl.value && i.isLoadingApps() ? 4 : -1)
  }
}
function AU(n, t) {
  n&1 && (f(0, 'span'), E(1, ' No apps Avaiable in current directory'), g())
}
function OU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 20)(1, 'mat-tab-group')(2, 'mat-tab', 21)(
        3, 'app-event-tab', 22),
        M('selectedEvent',
          function(r) {
            N(e);
            let o = D();
            return P(o.selectEvent(r))
          }),
        g()(), f(4, 'mat-tab', 23), B(5, 'app-state-tab', 24), g(),
        f(6, 'mat-tab', 25), B(7, 'app-artifact-tab', 26), g(),
        f(8, 'mat-tab', 27)(9, 'app-session-tab', 28),
        M('sessionSelected',
          function(r) {
            N(e);
            let o = D();
            return P(o.updateWithSelectedSession(r))
          }),
        g()(), f(10, 'mat-tab', 29)(11, 'app-eval-tab', 30),
        M('sessionSelected', function(r) {
          N(e);
          let o = D();
          return P(o.updateWithSelectedSession(r))
        }), g()()()()
  }
  if (n & 2) {
    let e = D();
    b(3), x('eventsMap', e.eventData), b(2),
        x('sessionState', e.currentSessionState), b(2),
        x('artifacts', e.artifacts), b(2),
        x('userId', e.userId)('appName', e.appName)('sessionId', e.sessionId),
        b(2),
        x('appName', e.appName)('userId', e.userId)('sessionId', e.sessionId)
  }
}
function NU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 31)(1, 'div', 32)(2, 'div', 33)(3, 'mat-paginator', 34),
        M('page',
          function(r) {
            N(e);
            let o = D();
            return P(o.handlePageEvent(r))
          }),
        g(), f(4, 'button', 35)(5, 'mat-icon', 8),
        M('click',
          function() {
            N(e);
            let r = D();
            return P(r.closeSelectedEvent())
          }),
        E(6, 'close'), g()()()(),
        f(7, 'div')(8, 'mat-tab-group')(9, 'mat-tab', 36)(10, 'div', 37),
        B(11, 'img', 38), g(), B(12, 'ngx-json-viewer', 39), g(),
        f(13, 'mat-tab', 40), B(14, 'ngx-json-viewer', 39), g(),
        f(15, 'mat-tab', 41), B(16, 'ngx-json-viewer', 39), g()()()()
  }
  if (n & 2) {
    let e = D();
    b(3),
        x('length', e.eventData.size)('pageSize', 1)(
            'pageIndex', e.selectedEventIndex),
        b(8), x('src', e.eventGraph, yr), b(), x('json', e.selectedEvent), b(2),
        x('json', e.llmRequest), b(2), x('json', e.llmResponse)
  }
}
function PU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 42)(1, 'div', 43)(2, 'div', 44), E(3, 'Session ID'), g(),
        f(4, 'div', 45), E(5), g()(),
        f(6, 'div', 46)(7, 'div', 47)(8, 'mat-slide-toggle', 48),
        M('change',
          function() {
            N(e);
            let r = D();
            return P(r.toggleSse())
          }),
        E(9, ' Token Streaming '), g()(), B(10, 'mat-divider', 49),
        f(11, 'div', 50)(12, 'div', 51),
        M('click',
          function() {
            N(e);
            let r = D();
            return P(r.onNewSessionClick())
          }),
        f(13, 'mat-icon'), E(14, 'add'), g(), E(15, ' New Session '), g(),
        f(16, 'span', 52), M('click', function() {
          N(e);
          let r = D();
          return P(r.deleteSession(r.sessionId))
        }), E(17, ' delete '), g()()()()
  }
  if (n & 2) {
    let e = D();
    b(5), Re(e.sessionId), b(3), x('checked', e.enableSseIndicator()), b(2),
        x('vertical', !0)
  }
}
function FU(n, t) {
  n&1 &&
      (f(0, 'div', 53)(1, 'span'), E(2, 'Loading agents, please wait...'),
       g()())
}
function LU(n, t) {
  n&1 &&
      (f(0, 'span'), E(1, 'Welcome to ADK!'), B(2, 'br'),
       E(3, ' Select an agent on the left to begin with.'), g())
}
function VU(n, t) {
  if (n & 1 &&
          (E(0, ' Error message: '), B(1, 'br'), f(2, 'pre', 55), E(3), g()),
      n & 2) {
    let e = D(4);
    b(3), Re(e.loadingError())
  }
}
function jU(n, t) {
  n&1 &&
      (f(0, 'pre', 54), E(1, 'Warning: No agents found in current folder.'),
       g())
}
function BU(n, t) {
  if (n & 1 &&
          (f(0, 'div'), E(1, ' Failed to load agents. To get started, run '),
           f(2, 'pre'), E(3, 'adk web'), g(),
           E(4, ' in the folder that contains the agents.'), B(5, 'br'),
           R(6, VU, 4, 1)(7, jU, 2, 0, 'pre', 54), g()),
      n & 2) {
    let e = D(3);
    b(6), de(e.loadingError() ? 6 : 7)
  }
}
function zU(n, t) {
  if (n & 1 &&
          (f(0, 'div', 53), R(1, LU, 4, 0, 'span'), Cr(2, 'async'),
           R(3, BU, 8, 1, 'div'), g()),
      n & 2) {
    let e = D(2);
    b(), de((As(2, 1, e.apps$) || HC(3, kU)).length > 0 ? 1 : 3)
  }
}
function HU(n, t) {
  if (n & 1 && R(0, FU, 3, 0, 'div', 53)(1, zU, 4, 4, 'div', 53), n & 2) {
    let e = D();
    de(e.isLoadingApps() ? 0 : 1)
  }
}
function UU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 56), M('click', function() {
      N(e);
      let r = D();
      return P(r.openDialog())
    }), f(1, 'mat-icon'), E(2, 'priority_high'), g()()
  }
}
function $U(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 67), M('click', function() {
      N(e);
      let r = D().index, o = D(2);
      return P(o.clickEvent(r))
    }), f(1, 'mat-icon', 68), E(2, 'robot_2'), g()()
  }
}
function WU(n, t) {
  if (n & 1 && (Vn(0), B(1, 'img', 72), jn()), n & 2) {
    let e = D().$implicit;
    b(), x('src', e.url, yr)
  }
}
function qU(n, t) {
  if (n & 1 &&
          (Vn(0), f(1, 'mat-icon'), E(2, 'insert_drive_file'), g(),
           f(3, 'a', 73), E(4), g(), jn()),
      n & 2) {
    let e = D().$implicit;
    b(3), x('href', e.url, yr), b(), Re(e.file.name)
  }
}
function GU(n, t) {
  if (n & 1 &&
          (f(0, 'div', 71),
           R(1, WU, 2, 1, 'ng-container', 64)(2, qU, 5, 2, 'ng-container', 64),
           g()),
      n & 2) {
    let e = t.$implicit;
    b(), x('ngIf', e.file.type.startsWith('image/')), b(),
        x('ngIf', !e.file.type.startsWith('image/'))
  }
}
function QU(n, t) {
  if (n & 1 && (f(0, 'div', 69), R(1, GU, 3, 2, 'div', 70), g()), n & 2) {
    let e = D().$implicit;
    b(), x('ngForOf', e.attachments)
  }
}
function YU(n, t) {
  if (n & 1 && B(0, 'markdown', 74), n & 2) {
    let e = D().$implicit;
    x('data', e.text)
  }
}
function ZU(n, t) {
  if (n & 1 && (f(0, 'div'), B(1, 'img', 75), g()), n & 2) {
    let e = D().$implicit;
    b(), x('src', e.inline_data.data, yr)
  }
}
function KU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 76), M('click', function() {
      N(e);
      let r = D().index, o = D(2);
      return P(o.clickEvent(r))
    }), f(1, 'mat-icon'), E(2, 'bolt'), g(), E(3), g()
  }
  if (n & 2) {
    let e = D().$implicit;
    b(3), at(' ', e.functionCall.name, ' ')
  }
}
function XU(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'button', 76), M('click', function() {
      N(e);
      let r = D().index, o = D(2);
      return P(o.clickEvent(r))
    }), f(1, 'mat-icon'), E(2, 'check'), g(), E(3), g()
  }
  if (n & 2) {
    let e = D().$implicit;
    b(3), at(' ', e.functionResponse.name, ' ')
  }
}
function JU(n, t) {
  n&1 && (f(0, 'button', 35)(1, 'mat-icon'), E(2, 'person'), g()())
}
function e$(n, t) {
  if (n & 1 &&
          (f(0, 'div', 59), R(1, $U, 3, 0, 'button', 60), f(2, 'mat-card', 61),
           R(3, QU, 2, 1, 'div', 62)(4, YU, 1, 1, 'markdown', 63)(
               5, ZU, 2, 1, 'div', 64)(6, KU, 4, 1, 'button', 65)(
               7, XU, 4, 1, 'button', 65),
           g(), R(8, JU, 3, 0, 'button', 66), g()),
      n & 2) {
    let e = t.$implicit;
    x('ngClass', Rs(8, SU, e.role === 'user', e.role === 'bot')), b(),
        x('ngIf', e.role === 'bot'), b(2), x('ngIf', e.attachments), b(),
        x('ngIf', e.text), b(), x('ngIf', e.inline_data && e.role === 'bot'),
        b(), x('ngIf', e.functionCall), b(), x('ngIf', e.functionResponse), b(),
        x('ngIf', e.role === 'user')
  }
}
function t$(n, t) {
  if (n & 1 &&
          (f(0, 'div', 57), B(1, 'div', null, 1), R(3, e$, 9, 11, 'div', 58),
           g()),
      n & 2) {
    let e = D();
    b(3), x('ngForOf', e.messages)
  }
}
function n$(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 90), B(1, 'img', 91), f(2, 'button', 92),
        M('click', function() {
          N(e);
          let r = D().index, o = D(3);
          return P(o.removeFile(r))
        }), f(3, 'mat-icon', 93), E(4, 'close'), g()()()
  }
  if (n & 2) {
    let e = D().$implicit;
    b(), x('src', e.url, yr)
  }
}
function i$(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 94)(1, 'button', 92),
        M('click',
          function() {
            N(e);
            let r = D().index, o = D(3);
            return P(o.removeFile(r))
          }),
        f(2, 'mat-icon', 93), E(3, 'close'), g()(),
        f(4, 'div', 95)(5, 'mat-icon'), E(6, 'insert_drive_file'), g(),
        f(7, 'span'), E(8), g()()()
  }
  if (n & 2) {
    let e = D().$implicit;
    b(8), Re(e.file.name)
  }
}
function r$(n, t) {
  if (n & 1 &&
          (f(0, 'div'), R(1, n$, 5, 1, 'div', 88)(2, i$, 9, 1, 'div', 89), g()),
      n & 2) {
    let e = t.$implicit;
    b(), x('ngIf', e.file.type.startsWith('image/')), b(),
        x('ngIf', !e.file.type.startsWith('image/'))
  }
}
function o$(n, t) {
  if (n & 1 && (f(0, 'div', 86), R(1, r$, 3, 2, 'div', 87), g()), n & 2) {
    let e = D(2);
    b(), x('ngForOf', e.selectedFiles)
  }
}
function s$(n, t) {
  if (n & 1) {
    let e = ee();
    f(0, 'div', 77)(1, 'input', 78, 2),
        M('change',
          function(r) {
            N(e);
            let o = D();
            return P(o.onFileSelect(r))
          }),
        g(), f(3, 'mat-form-field', 79), R(4, o$, 2, 1, 'div', 80),
        f(5, 'input', 81),
        $i('ngModelChange',
           function(r) {
             N(e);
             let o = D();
             return xr(o.userInput, r) || (o.userInput = r), P(r)
           }),
        M('keydown.enter',
          function(r) {
            N(e);
            let o = D();
            return P(o.sendMessage(r))
          }),
        g(), f(6, 'div', 82)(7, 'button', 83),
        M('click',
          function() {
            N(e);
            let r = yt(2);
            return P(r.click())
          }),
        f(8, 'mat-icon'), E(9, 'attach_file'), g()(),
        f(10, 'div')(11, 'button', 84),
        M('click',
          function() {
            N(e);
            let r = D();
            return P(r.toggleAudioRecording())
          }),
        B(12, 'mat-icon', 85), g(), f(13, 'button', 84), M('click', function() {
          N(e);
          let r = D();
          return P(r.toggleVideoRecording())
        }), B(14, 'mat-icon', 85), g()()()()()
  }
  if (n & 2) {
    let e = D();
    b(4), x('ngIf', e.selectedFiles.length && e.appName != ''), b(),
        Ui('ngModel', e.userInput), b(6),
        x('ngStyle',
          ko(6, GI,
             e.isAudioRecording ? 'rgb(234, 67, 53)' : 'rgb(51, 53, 55)')),
        b(), x('innerText', e.isAudioRecording ? 'stop' : 'mic'), b(),
        x('ngStyle',
          ko(8, GI,
             e.isVideoRecording ? 'rgb(234, 67, 53)' : 'rgb(51, 53, 55)')),
        b(), x('innerText', e.isVideoRecording ? 'stop' : 'videocam')
  }
}
function a$(n) {
  for (n = n.replace(/-/g, '+').replace(/_/g, '/'); n.length % 4 !== 0;)
    n += '=';
  return n
}
var Pv = class extends jo {
  nextPageLabel = 'Next Event';
  previousPageLabel = 'Previous Event';
  firstPageLabel = 'First Event';
  lastPageLabel = 'Last Event';
  getRangeLabel = (t, e, i) => i === 0 ?
      `Event 0 of ${i}` :
      (i = Math.max(i, 0), `Event ${t * e + 1} of ${i}`)
}
, Cc = class n {
  constructor(t, e, i, r, o, s, a, l) {
    this.sesisonService = t;
    this.artifactService = e;
    this.audioService = i;
    this.webSocketService = r;
    this.videoService = o;
    this.dialog = s;
    this.eventService = a;
    this.sessionService = l
  }
  videoContainer;
  sidenav;
  eventTabComponent;
  sessionTab;
  enableSseIndicator = Jt(!1);
  videoElement;
  currentMessage = '';
  messages = [];
  lastTextChunk = '';
  streamingTextMessage = null;
  artifacts = [];
  userInput = '';
  userId = 'user';
  appName = '';
  sessionId = '';
  isAudioRecording = !1;
  isVideoRecording = !1;
  longRunningEvents = [];
  functionCallEventId = '';
  redirectUri = rn.getBaseUrlWithoutPath();
  showSidePanel = !0;
  useSse = !1;
  currentSessionState = {};
  eventData = new Map;
  eventMessageIndexArray = [];
  eventGraph = '';
  selectedEvent = void 0;
  selectedEventIndex = void 0;
  llmRequest = void 0;
  llmResponse = void 0;
  llmRequestKey = 'gcp.vertex.agent.llm_request';
  llmResponseKey = 'gcp.vertex.agent.llm_response';
  selectedFiles = [];
  router = u(Or);
  activatedRoute = u(Ar);
  selectedAppControl = new sm('', {nonNullable: !0});
  agentService = u(Hr);
  isLoadingApps = Jt(!1);
  loadingError = Jt('');
  apps$ = G([]).pipe(
      He(() => {this.isLoadingApps.set(!0), this.selectedAppControl.disable()}),
      $e(() => this.agentService.listApps().pipe(
             sn(t => (this.loadingError.set(t.message), G(void 0))))),
      Ye(1),
      He(() => {this.isLoadingApps.set(!1), this.selectedAppControl.enable()}),
      Ni());
  ngOnInit() {
    if (this.syncSelectedAppFromUrl(), this.updateSelectedAppUrl(),
        new URL(window.location.href).searchParams.has('code')) {
      let i = window.location.href;
      window.opener?.postMessage({authResponseUrl: i}, window.origin),
          window.close()
    }
    this.agentService.getApp().subscribe(i => {this.appName = i})
  }
  ngAfterViewInit() {
    this.showSidePanel = !0, this.sidenav.open()
  }
  selectApp(t) {
    this.agentService.setApp(t), this.createSession()
  }
  createSession() {
    this.sesisonService.createSession(this.userId, this.appName)
        .subscribe(
            t => {this.currentSessionState = t.state, this.sessionId = t.id})
  }
  sendMessage(t) {
    return Tt(this, null, function*() {
      if (t.preventDefault(), !this.userInput.trim()) return;
      if (this.selectedFiles.length > 0) {
        let r = this.selectedFiles.map(o => ({file: o.file, url: o.url}));
        this.messages.push({role: 'user', attachments: r})
      }
      this.messages.push({role: 'user', text: this.userInput});
      let e = {
        app_name: this.appName,
        user_id: this.userId,
        session_id: this.sessionId,
        new_message: {role: 'user', parts: yield this.getUserMessageParts()},
        streaming: this.useSse
      };
      this.selectedFiles = [];
      let i = this.eventMessageIndexArray.length - 1;
      this.streamingTextMessage = null, this.agentService.run_sse(e).subscribe({
        next: r =>
            Tt(this, null,
               function*() {
                 let o = JSON.parse(r);
                 if (o.content.parts[0].text) {
                   let s = o.content.parts[0].text;
                   if (this.streamingTextMessage) {
                     if (s == this.streamingTextMessage.text) {
                       i += 1, this.storeEvents(o, i),
                           this.eventMessageIndexArray[i] = s,
                           this.streamingTextMessage = null;
                       return
                     }
                     this.streamingTextMessage.text += s
                   } else if (
                       this.streamingTextMessage = {role: 'bot', text: s},
                       this.messages.push(this.streamingTextMessage),
                       !this.useSse) {
                     i += 1, this.storeEvents(o, i),
                         this.eventMessageIndexArray[i] = s,
                         this.streamingTextMessage = null;
                     return
                   }
                 } else
                   i += 1, this.storeEvents(o, i), this.storeMessage(o, i)
               }),
        error: r => console.error('SSE error:', r),
        complete: () => {
          this.streamingTextMessage = null
        }
      }),
      this.userInput = ''
    })
  }
  getUserMessageParts() {
    return Tt(this, null, function*() {
      let t = [{text: `${this.userInput}`}];
      if (this.selectedFiles.length > 0)
        for (let e of this.selectedFiles)
          t.push({
            inline_data: {
              data: yield this.readFileAsBytes(e.file),
              mime_type: e.file.type
            }
          });
      return t
    })
  }
  readFileAsBytes(t) {
    return new Promise((e, i) => {
      let r = new FileReader;
      r.onload = o => {
        let s = o.target.result.split(',')[1];
        e(s)
      }, r.onerror = i, r.readAsDataURL(t)
    })
  }
  updateRedirectUri(t, e) {
    try {
      let i = new URL(t);
      return i.searchParams.set('redirect_uri', e), i.toString()
    } catch (i) {
      return console.warn('Failed to update redirect URI: ', i), t
    }
  }
  storeMessage(t, e) {
    if (t.long_running_tool_ids && t.long_running_tool_ids.length > 0) {
      this.getAsyncFunctionsFromParts(t.long_running_tool_ids, t.content.parts);
      let i = this.longRunningEvents[0];
      if (i.args.auth_config && i.args.auth_config.exchanged_auth_credential &&
          i.args.auth_config.exchanged_auth_credential.oauth2) {
        let r = i.args.auth_config.exchanged_auth_credential.oauth2.auth_uri,
            o = this.updateRedirectUri(r, this.redirectUri);
        this.openOAuthPopup(o)
            .then(s => {
              this.functionCallEventId = t.id,
              this.sendOAuthResponse(i, s, this.redirectUri)
            })
            .catch(s => {console.error('OAuth Error:', s)})
      } else
        this.functionCallEventId = t.id
    }
    if (t.content.parts[0].text)
      this.messages.push({
        role: t.author === 'user' ? 'user' : 'bot',
        text: t.content.parts[0].text
      }),
          this.eventMessageIndexArray[e] = t.content.parts[0].text;
    else if (t.content.parts[0].functionCall)
      this.messages.push({
        role: t.author === 'user' ? 'user' : 'bot',
        functionCall: t.content.parts[0].functionCall
      }),
          this.eventMessageIndexArray[e] = t.content.parts[0].functionCall;
    else if (t.content.parts[0].functionResponse) {
      if (this.messages.push({
            role: t.author === 'user' ? 'user' : 'bot',
            functionResponse: t.content.parts[0].functionResponse
          }),
          t.actions && t.actions.artifact_delta)
        for (let i in t.actions.artifact_delta)
          t.actions.artifact_delta.hasOwnProperty(i) &&
              this.renderArtifact(i, t.actions.artifact_delta[i]);
      this.eventMessageIndexArray[e] = t.content.parts[0].functionResponse
    }
  }
  renderArtifact(t, e) {
    this.messages.push(
        {role: 'bot', inline_data: {data: '', mime_type: 'image/png'}});
    let i = this.messages.length - 1;
    this.artifactService
        .getArtifactVersion(this.userId, this.appName, this.sessionId, t, e)
        .subscribe(r => {
          let o = r.inlineData.mimeType, s = a$(r.inlineData.data),
              a = `data:${o};base64,${s}`;
          this.messages[i] = {
            role: 'bot',
            inline_data: {data: a, mime_type: o}
          },
          this.artifacts.push({id: t, data: a, mimeType: o})
        })
  }
  storeEvents(t, e) {
    let i = t.content.parts[0], r = t.content.role + ':';
    i.text             ? r += e + i.text :
        i.functionCall ? r += 'functionCall:' + e + ':' + i.functionCall.name :
                         i.functionResponse &&
            (r += 'functionResponse:' + e + ':' + i.functionResponse.name),
        this.eventData.set(r, t), this.eventData = new Map(this.eventData)
  }
  sendOAuthResponse(t, e, i) {
    this.longRunningEvents.pop();
    let r = {
      app_name: this.appName,
      user_id: this.userId,
      session_id: this.sessionId,
      new_message: {role: 'user', parts: []}
    };
    var o = t.args.auth_config;
    o.exchanged_auth_credential.oauth2.auth_response_uri = e,
    o.exchanged_auth_credential.oauth2.redirect_uri = i,
    r.function_call_event_id = this.functionCallEventId,
    r.new_message.parts.push(
        {function_response: {id: t.id, name: t.name, response: o}}),
    this.agentService.run(r).subscribe(s => {
      for (let a of s)
        a.content.parts[0].text &&
            this.messages.push({role: 'bot', text: a.content.parts[0].text})
    })
  }
  openDialog() {
    this.dialog
        .open(sc, {
          width: '600px',
          data: {
            event: this.longRunningEvents[0],
            app_name: this.appName,
            user_id: this.userId,
            session_id: this.sessionId,
            function_call_event_id: this.functionCallEventId
          }
        })
        .afterClosed()
        .subscribe(
            e => {
                e &&
                (this.longRunningEvents = e.events,
                 this.messages.push({role: 'bot', text: e.text}))})
  }
  clickEvent(t) {
    let e = Array.from(
            this.eventData.entries())[t - this.userMessagesLength(t)],
        [i, r] = e;
    this.sidenav.open(),
        this.showSidePanel = !0, this.selectedEvent = r,
        this.selectedEventIndex = this.getIndexOfKeyInMap(i),
        this.eventService.getEventTrace(this.selectedEvent.id).subscribe(o => {
          this.llmRequest = JSON.parse(o[this.llmRequestKey]),
          this.llmResponse = JSON.parse(o[this.llmResponseKey])
        }),
        this.eventService
            .getEvent(
                this.userId, this.appName, this.sessionId,
                this.selectedEvent.id)
            .subscribe(o => {this.eventGraph = URL.createObjectURL(o)})
  }
  userMessagesLength(t) {
    return this.messages.slice(0, t).filter(e => e.role == 'user').length
  }
  ngOnDestroy() {
    this.webSocketService.closeConnection()
  }
  toggleAudioRecording() {
    this.isAudioRecording ? this.stopAudioRecording() :
                            this.startAudioRecording(),
        this.isAudioRecording = !this.isAudioRecording
  }
  startAudioRecording() {
    this.webSocketService.connect(`ws://localhost:8000/run_live?app_name=${
        this.appName}&user_id=${this.userId}&session_id=${this.sessionId}`),
        this.audioService.startRecording(),
        this.messages.push({role: 'user', text: 'Speaking...'}),
        this.messages.push({role: 'bot', text: 'Speaking...'})
  }
  stopAudioRecording() {
    this.audioService.stopRecording(), this.webSocketService.closeConnection()
  }
  toggleVideoRecording() {
    this.isVideoRecording ? this.stopVideoRecording() :
                            this.startVideoRecording(),
        this.isVideoRecording = !this.isVideoRecording
  }
  startVideoRecording() {
    this.webSocketService.connect(`ws://localhost:8000/run_live?app_name=${
        this.appName}&user_id=${this.userId}&session_id=${this.sessionId}`),
        this.videoService.startRecording(this.videoContainer),
        this.audioService.startRecording(),
        this.messages.push({role: 'user', text: 'Speaking...'})
  }
  stopVideoRecording() {
    this.audioService.stopRecording(),
        this.videoService.stopRecording(this.videoContainer),
        this.webSocketService.closeConnection()
  }
  getAsyncFunctionsFromParts(t, e) {
    for (let i of e)
      i.functionCall && t.includes(i.functionCall.id) &&
          this.longRunningEvents.push(i.functionCall)
  }
  openOAuthPopup(t) {
    return new Promise((e, i) => {
      if (!window.open(t, 'oauthPopup', 'width=600,height=700')) {
        i('Popup blocked!');
        return
      }
      window.addEventListener('message', o => {
        if (o.origin !== window.location.origin) return;
        let {authResponseUrl: s} = o.data;
        s ? e(s) : i('OAuth failed')
      }, {once: !0})
    })
  }
  toggleSidePanel() {
    this.showSidePanel = !this.showSidePanel
  }
  updateWithSelectedSession(t) {
    if (!t || !t.id || !t.events || !t.state) {
      console.log('Session is not valid');
      return
    }
    this.sessionId = t.id, this.currentSessionState = t.state,
    this.eventData.clear(), this.eventMessageIndexArray = [],
    this.messages = [], this.artifacts = [];
    let e = 0;
    t.events.forEach(i => {
      this.storeMessage(i, e),
      e += 1,
      i.author && i.author !== 'user' && this.storeEvents(i, e)
    })
  }
  onNewSessionClick() {
    this.createSession(), this.eventData.clear(),
        this.eventMessageIndexArray = [], this.messages = [],
        this.artifacts = [], this.sessionTab.refreshSession()
  }
  onFileSelect(t) {
    let e = t.target;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        let r = e.files[i], o = URL.createObjectURL(r);
        this.selectedFiles.push({file: r, url: o})
      }
    e.value = ''
  }
  removeFile(t) {
    URL.revokeObjectURL(this.selectedFiles[t].url),
        this.selectedFiles.splice(t, 1)
  }
  toggleSse() {
    this.useSse = !this.useSse
  }
  selectEvent(t) {
    this.selectedEvent = this.eventData.get(t),
    this.selectedEventIndex = this.getIndexOfKeyInMap(t),
    this.eventService.getEventTrace(this.selectedEvent.id).subscribe(e => {
      this.llmRequest = JSON.parse(e[this.llmRequestKey]),
      this.llmResponse = JSON.parse(e[this.llmResponseKey])
    }),
    this.eventService
        .getEvent(
            this.userId, this.appName, this.sessionId, this.selectedEvent.id)
        .subscribe(e => {this.eventGraph = URL.createObjectURL(e)})
  }
  deleteSession(t) {
    let e = {
      title: 'Confirm delete',
      message:
          `Are you sure you want to delete this session ${this.sessionId}?`,
      confirmButtonText: 'Delete',
      cancelButtonText: 'Cancel'
    };
    this.dialog.open(ac, {width: '600px', data: e})
        .afterClosed()
        .subscribe(
            r => {
                r &&
                this.sessionService.deleteSession(this.userId, this.appName, t)
                    .subscribe(o => {this.sessionTab.refreshSession()})})
  }
  syncSelectedAppFromUrl() {
    this.router.events
        .pipe(
            me(t => t instanceof Hn),
            Q(() => this.activatedRoute.snapshot.queryParams))
        .subscribe(t => {
          let e = t.app;
          e && this.selectedAppControl.setValue(e)
        })
  }
  updateSelectedAppUrl() {
    this.selectedAppControl.valueChanges.pipe(Rn(), me(Boolean))
        .subscribe(t => {
          this.selectApp(t);
          let e = this.activatedRoute.snapshot.queryParams.app;
          t !== e &&
              this.router.navigate(
                  [], {queryParams: {app: t}, queryParamsHandling: 'merge'})
        })
  }
  handlePageEvent(t) {
    if (t.pageIndex >= 0) {
      let e = this.getKeyAtIndexInMap(t.pageIndex);
      e && this.selectEvent(e)
    }
  }
  closeSelectedEvent() {
    this.selectedEvent = void 0, this.selectedEventIndex = void 0
  }
  getIndexOfKeyInMap(t) {
    let e = 0, i = (o, s) => 0, r = Array.from(this.eventData.keys()).sort(i);
    for (let o of r) {
      if (o === t) return e;
      e++
    }
  }
  getKeyAtIndexInMap(t) {
    let e = (r, o) => 0, i = Array.from(this.eventData.keys()).sort(e);
    if (t >= 0 && t < i.length) return i[t]
  }
  static \u0275fac = function(e) {
    return new (e || n)(z(Wn), z(ga), z(_a), z(Di), z(ba), z(Wr), z(Ur), z(Wn))
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-chat']],
    viewQuery:
        function(e, i) {
          if (e & 1 && (oe(DU, 5, L), oe(EU, 5), oe(Bo, 5), oe(zo, 5)), e & 2) {
            let r;
            $(r = W()) && (i.videoContainer = r.first),
                $(r = W()) && (i.sidenav = r.first),
                $(r = W()) && (i.eventTabComponent = r.first),
                $(r = W()) && (i.sessionTab = r.first)
          }
        },
    standalone: !1,
    features: [ye([{provide: jo, useClass: Pv}])],
    decls: 19,
    vars: 11,
    consts:
        [
          ['sidenav', ''],
          ['videoContainer', ''],
          ['fileInput', ''],
          ['autosize', '', 1, 'drawer-container'],
          ['mode', 'side', 1, 'sidenav', 2, 'color', 'white', 3, 'opened'],
          [2, 'margin-top', '20px', 'margin-left', '20px', 'display', 'flex'],
          [2, 'width', '100%'],
          [1, 'drawer-header'],
          [3, 'click'],
          [1, 'app-select-container'],
          ['class', 'tabs-container', 4, 'ngIf'],
          ['class', 'details-panel-container', 4, 'ngIf'],
          [1, 'chat-container'],
          ['class', 'chat-toolbar', 4, 'ngIf'],
          [1, 'chat-card'],
          [
            'mat-fab', '', 'color', 'primary', 'class', 'fab-button', 3,
            'click', 4, 'ngIf'
          ],
          ['class', 'chat-messages', 4, 'ngIf'],
          ['class', 'chat-input', 4, 'ngIf'],
          [1, 'app-select', 3, 'placeholder', 'formControl'],
          [3, 'value'],
          [1, 'tabs-container'],
          ['label', 'Events'],
          [3, 'selectedEvent', 'eventsMap'],
          ['label', 'State'],
          [3, 'sessionState'],
          ['label', 'Artifacts'],
          [3, 'artifacts'],
          ['label', 'Sessions'],
          [3, 'sessionSelected', 'userId', 'appName', 'sessionId'],
          ['label', 'Eval'],
          [3, 'sessionSelected', 'appName', 'userId', 'sessionId'],
          [1, 'details-panel-container'],
          [1, 'details-content'],
          [
            2, 'display', 'flex', 'justify-content', 'flex-end', 'margin-top',
            '10px'
          ],
          [
            'aria-label', 'Select event', 1, 'event-paginator', 3, 'page',
            'length', 'pageSize', 'pageIndex'
          ],
          ['mat-mini-fab', ''],
          ['label', 'Event'],
          [
            2, 'margin-top', '16px', 'margin-bottom', '16px', 'diaply', 'flex',
            'justify-content', 'center'
          ],
          [3, 'src'],
          [3, 'json'],
          ['label', 'Request'],
          ['label', 'Reponse'],
          [1, 'chat-toolbar'],
          [2, 'display', 'flex'],
          [1, 'toolbar-session-text'],
          [1, 'toolbar-session-id'],
          [1, 'toolbar-actions'],
          [1, 'toolbar-sse-toggle'],
          [1, 'example-margin', 3, 'change', 'checked'],
          [
            2, 'margin-left', '8px', 'margin-right', '8px', 'height', '22px', 3,
            'vertical'
          ],
          [2, 'display', 'flex', 'align-items', 'center'],
          [1, 'toolbar-new-sesison', 3, 'click'],
          [
            1, 'material-symbols-outlined', 2, 'width', '24px', 'height',
            '24px', 'color', '#C4C7C5', 'cursor', 'pointer', 'margin-right',
            '16px', 3, 'click'
          ],
          [1, 'empty-state-container'],
          [1, 'warning'],
          [1, 'error'],
          ['mat-fab', '', 'color', 'primary', 1, 'fab-button', 3, 'click'],
          [1, 'chat-messages'],
          [3, 'ngClass', 4, 'ngFor', 'ngForOf'],
          [3, 'ngClass'],
          ['mat-mini-fab', '', 3, 'click', 4, 'ngIf'],
          [1, 'message-card'],
          ['class', 'attachments', 4, 'ngIf'],
          [3, 'data', 4, 'ngIf'],
          [4, 'ngIf'],
          [
            'mat-stroked-button', '', 'class', 'function-event-button', 3,
            'click', 4, 'ngIf'
          ],
          ['mat-mini-fab', '', 4, 'ngIf'],
          ['mat-mini-fab', '', 3, 'click'],
          ['fontSet', 'material-symbols-outlined'],
          [1, 'attachments'],
          ['class', 'attachment', 4, 'ngFor', 'ngForOf'],
          [1, 'attachment'],
          ['alt', 'attachment', 1, 'image-preview-chat', 3, 'src'],
          ['download', '', 3, 'href'],
          [3, 'data'],
          ['alt', 'image', 1, 'generated-image', 3, 'src'],
          ['mat-stroked-button', '', 1, 'function-event-button', 3, 'click'],
          [1, 'chat-input'],
          ['type', 'file', 'multiple', '', 'hidden', '', 3, 'change'],
          ['appearance', 'outline', 1, 'input-field'],
          ['class', 'file-preview', 4, 'ngIf'],
          [
            'matInput', '', 'placeholder', 'Type a Message...', 1,
            'chat-input-box', 2, 'caret-color', 'white', 3, 'ngModelChange',
            'keydown.enter', 'ngModel'
          ],
          [1, 'chat-input-actions'],
          [
            'mat-icon-button', '', 1, 'function-event-button', 2,
            'margin-right', '10px', 3, 'click'
          ],
          ['mat-icon-button', '', 'matSuffix', '', 3, 'click', 'ngStyle'],
          [3, 'innerText'],
          [1, 'file-preview'],
          [4, 'ngFor', 'ngForOf'],
          ['class', 'image-container', 4, 'ngIf'],
          ['class', 'file-container', 4, 'ngIf'],
          [1, 'image-container'],
          ['alt', 'preview', 1, 'image-preview', 3, 'src'],
          ['mat-icon-button', '', 1, 'delete-button', 3, 'click'],
          ['color', 'warn'],
          [1, 'file-container'],
          [1, 'file-info']
        ],
    template:
        function(e, i) {
          if (e & 1) {
            let r = ee();
            f(0, 'mat-drawer-container', 3)(1, 'mat-drawer', 4, 0)(3, 'div', 5)(
                4, 'div', 6)(5, 'div', 7)(6, 'mat-icon', 8),
                M('click',
                  function() {
                    return N(r), P(i.toggleSidePanel())
                  }),
                E(7, 'menu'), g(),
                R(8, RU, 5, 6, 'div', 9)(9, AU, 2, 0, 'span'), g()()(),
                R(10, OU, 12, 9, 'div', 10)(11, NU, 17, 7, 'div', 11), g(),
                f(12, 'div', 12), R(13, PU, 18, 3, 'div', 13),
                f(14, 'mat-card', 14),
                R(15, HU, 2, 1)(16, UU, 3, 0, 'button', 15)(
                    17, t$, 4, 1, 'div', 16)(18, s$, 15, 10, 'div', 17),
                g()()()
          }
          e&2 &&
              (b(), Pt('width', i.showSidePanel ? 510 : 56, 'px'),
               x('opened', !0), b(7), de(i.showSidePanel ? 8 : 9), b(2),
               x('ngIf', i.appName != '' && i.showSidePanel), b(),
               x('ngIf', i.selectedEvent && i.showSidePanel), b(2),
               x('ngIf', i.appName != ''), b(2),
               de(i.selectedAppControl.value ? -1 : 15), b(),
               x('ngIf', i.longRunningEvents.length > 0), b(),
               x('ngIf', i.appName != ''), b(), x('ngIf', i.appName != ''))
        },
    dependencies:
        [
          vn, yn, fi, hD, pi, Tr, Gi, OS, va, xi, oS, Yr, bi, Km, Fk, Pk, qb,
          gS, _h, tv, nv, av, XS, ch, sa, vI, Ch, v_, Bo, zo, yc, wc, xc, Fu
        ],
    styles:
        ['.drawer-container[_ngcontent-%COMP%]{height:100%;background-color:#131314}.generated-image[_ngcontent-%COMP%]{max-width:33%}.chat-container[_ngcontent-%COMP%]{width:100%;height:100%;max-width:1200px;margin:auto}.event-container[_ngcontent-%COMP%]{color:#fff}.drawer-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:flex-start;align-items:center}.drawer-header[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{width:36px;height:36px;color:#bdc1c6;cursor:pointer;display:flex;align-items:center;justify-content:center}.chat-card[_ngcontent-%COMP%]{display:flex;flex-direction:column;height:500px;overflow:hidden;height:95%;box-shadow:none;background-color:#131314}.chat-messages[_ngcontent-%COMP%]{flex-grow:1;overflow-y:auto;padding:20px;margin-top:16px}.message-card[_ngcontent-%COMP%]{padding:10px 20px;margin:5px;border-radius:20px;max-width:80%;font-size:16px;font-weight:400}.user-message[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;align-items:center}.user-message[_ngcontent-%COMP%]   .message-card[_ngcontent-%COMP%]{background-color:#004a77;align-self:flex-end;color:#fff;box-shadow:none}.bot-message[_ngcontent-%COMP%]{display:flex;align-items:center}.bot-message[_ngcontent-%COMP%]   .message-card[_ngcontent-%COMP%]{background-color:#303030;align-self:flex-start;color:#fff;box-shadow:none}.navigation-button-sidepanel[_ngcontent-%COMP%]{margin-left:auto;margin-right:20px}.chat-input[_ngcontent-%COMP%]{display:flex;padding:10px;width:80%;margin:0 auto}.input-field[_ngcontent-%COMP%]{flex-grow:1}.input-field[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{color:#fff;border:none;padding:10px}.input-field[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]::placeholder{color:#8e918f}.input-field[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{color:#fff;background-color:#333537}.chat-input-actions[_ngcontent-%COMP%]{margin-top:10px;display:flex;justify-content:space-between}.fab-button[_ngcontent-%COMP%]{position:fixed;bottom:200px;right:100px;z-index:1000}.sidepanel-toggle[_ngcontent-%COMP%]{position:relative;top:100px;z-index:1000}.sidenav[_ngcontent-%COMP%]{background-color:#1b1b1b;color:#fff}.tabs-container[_ngcontent-%COMP%]{margin-top:20px;padding-left:10px;padding-right:10px}.file-preview[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:5px;margin-top:2px;margin-bottom:8px}.file-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:5px;background:#eee;padding:5px;border-radius:4px}.image-preview[_ngcontent-%COMP%]{width:40px;height:40px;object-fit:cover;border-radius:4px}.image-preview-chat[_ngcontent-%COMP%]{max-width:90%;max-height:70vh;width:auto;height:auto;border-radius:8px;cursor:pointer;transition:transform .2s ease-in-out}button[_ngcontent-%COMP%]{margin-left:20px;margin-right:20px}.app-select[_ngcontent-%COMP%]{width:180px}.empty-state-container[_ngcontent-%COMP%]{color:#eee;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;font-family:Open Sans,sans-serif;font-weight:400;letter-spacing:normal;line-height:24px;font-size:18px}.empty-state-container[_ngcontent-%COMP%]   pre.warning[_ngcontent-%COMP%]{color:#ffc185}.empty-state-container[_ngcontent-%COMP%]   pre.error[_ngcontent-%COMP%]{color:#ff4545}.function-event-button[_ngcontent-%COMP%]{background-color:#fff}[_nghost-%COMP%]     .mat-mdc-text-field-wrapper{border:1px solid #8e918f}[_nghost-%COMP%]     .input-field .mat-mdc-text-field-wrapper{border:1px solid #8e918f;border-radius:16px}[_nghost-%COMP%]     .mdc-notched-outline__leading, [_nghost-%COMP%]     .mdc-notched-outline__notch, [_nghost-%COMP%]     .mdc-notched-outline__trailing{border:none}[_nghost-%COMP%]     .mat-mdc-form-field-icon-suffix{padding:0 10px 0 40px}[_nghost-%COMP%]     .segment-key{color:#d3d3d3!important}[_nghost-%COMP%]     .mat-mdc-mini-fab{background-color:#fff}[_nghost-%COMP%]     .mat-mdc-mini-fab mat-icon{color:#000}[_nghost-%COMP%]     .mat-drawer-inner-container{width:500px}.mat-mdc-select-placeholder[_ngcontent-%COMP%]{margin-left:20px}.new-session-button[_ngcontent-%COMP%]{margin-top:0;margin-left:50px;width:130px;height:28px;font-size:.8em}.app-select-container[_ngcontent-%COMP%]{background-color:#212123;margin-left:20px;height:30px;display:flex;justify-content:space-between;padding-left:20px;padding-right:20px;border-radius:10px;padding-top:5px;margin-top:-2px}.drawer-header[_ngcontent-%COMP%]{--mat-select-placeholder-text-color: #8ab4f8}.drawer-header[_ngcontent-%COMP%]{--mat-select-enabled-trigger-text-color: #8ab4f8}.drawer-header[_ngcontent-%COMP%]{--mat-select-enabled-arrow-color: #8ab4f8}.event-paginator[_ngcontent-%COMP%]{background-color:inherit;display:flex;justify-content:center}[_nghost-%COMP%]     .mat-mdc-paginator-page-size{display:none!important}.details-panel-container[_ngcontent-%COMP%]{position:absolute;height:98%;left:0;right:0;bottom:0;background:#242424;display:inline-block;justify-content:center;align-items:center;z-index:10}.details-content[_ngcontent-%COMP%]{color:#fff;font-size:20px}.event-paginator[_ngcontent-%COMP%]{margin-top:-8px;margin-right:160px}.adk-checkbox[_ngcontent-%COMP%]{position:fixed;bottom:0;left:0;right:0;margin-bottom:20px;margin-left:20px}.drawer-header[_ngcontent-%COMP%]{--mdc-filled-button-container-color: #89b4f8}.drawer-header[_ngcontent-%COMP%]{--mdc-filled-button-label-text-color: black}.chat-toolbar[_ngcontent-%COMP%]{position:sticky;top:0;height:48px;background:#1d1d20;display:flex;justify-content:space-between;align-items:center;z-index:10}.toolbar-session-text[_ngcontent-%COMP%]{color:#fdfdfd;font-family:Roboto;font-size:12px;font-style:normal;font-weight:500;line-height:12px;letter-spacing:.8px;text-transform:uppercase;margin-left:20px;padding-top:4px}.toolbar-session-id[_ngcontent-%COMP%]{color:#9aa0a6;font-family:Google Sans;font-size:13px;font-style:normal;font-weight:400;line-height:20px;letter-spacing:.25px;margin-left:5px}.toolbar-actions[_ngcontent-%COMP%]{display:flex}.toolbar-new-sesison[_ngcontent-%COMP%]{font-size:14px;margin-right:16px;color:#9aa0a6;cursor:pointer;display:flex;align-items:center}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mat-switch-label-text-size: 14px}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mat-switch-label-text-color: #9AA0A6}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-track-color: #8ab4f9}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-focus-track-color: #8ab4f9}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-hover-track-color: #8ab4f9}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-handle-color: #1b73e8}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-focus-handle-color: #1b73e8}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-selected-hover-handle-color: #1b73e8}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-track-height: 24px}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mdc-switch-track-width: 46px}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mat-switch-track-outline-color: #1b73e8}.toolbar-sse-toggle[_ngcontent-%COMP%]{--mat-switch-with-icon-handle-size: 20px}.image-container[_ngcontent-%COMP%]{position:relative;display:inline-block;border-radius:12px;overflow:hidden}.image-preview[_ngcontent-%COMP%]{display:block;width:100%;height:auto;border-radius:12px;width:80px;height:80px}.delete-button[_ngcontent-%COMP%]{position:absolute;top:1px;right:1px;background-color:#000000b3;border:none;border-radius:50%;padding:8px;cursor:pointer;color:#fff;display:flex;align-items:center;justify-content:center;margin-right:0;scale:.7}.delete-button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:20px}.file-container[_ngcontent-%COMP%]{position:relative;display:flex;flex-direction:column;gap:8px;height:80px;background-color:#1e1e1e;border-radius:12px}.file-info[_ngcontent-%COMP%]{margin-right:60px;padding-top:20px;padding-left:16px}']
  })
};
var Ea = class n {
  title = 'agent_framework_web';
  userId = '';
  appName = '';
  sessionId = '';
  constructor() {}
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275cmp = O({
    type: n,
    selectors: [['app-root']],
    standalone: !1,
    decls: 1,
    vars: 0,
    template:
        function(e, i) {
          e&1 && B(0, 'app-chat')
        },
    dependencies: [Cc],
    encapsulation: 2
  })
};
var c$ =
        [
          {path: 'dev-ui', component: Ea},
          {path: '', redirectTo: 'dev-ui', pathMatch: 'full'}
        ],
    Ah = class n {
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275mod = j({type: n});
  static \u0275inj = V({imports: [nb.forRoot(c$), nb]})
};
function QI(n) {
  return new S(3e3, !1)
}
function d$() {
  return new S(3100, !1)
}
function u$() {
  return new S(3101, !1)
}
function m$(n) {
  return new S(3001, !1)
}
function h$(n) {
  return new S(3003, !1)
}
function f$(n) {
  return new S(3004, !1)
}
function p$(n, t) {
  return new S(3005, !1)
}
function g$() {
  return new S(3006, !1)
}
function _$() {
  return new S(3007, !1)
}
function b$(n, t) {
  return new S(3008, !1)
}
function v$(n) {
  return new S(3002, !1)
}
function y$(n, t, e, i, r) {
  return new S(3010, !1)
}
function w$() {
  return new S(3011, !1)
}
function x$() {
  return new S(3012, !1)
}
function C$() {
  return new S(3200, !1)
}
function D$() {
  return new S(3202, !1)
}
function E$() {
  return new S(3013, !1)
}
function k$(n) {
  return new S(3014, !1)
}
function S$(n) {
  return new S(3015, !1)
}
function I$(n) {
  return new S(3016, !1)
}
function M$(n, t) {
  return new S(3404, !1)
}
function T$(n) {
  return new S(3502, !1)
}
function R$(n) {
  return new S(3503, !1)
}
function A$() {
  return new S(3300, !1)
}
function O$(n) {
  return new S(3504, !1)
}
function N$(n) {
  return new S(3301, !1)
}
function P$(n, t) {
  return new S(3302, !1)
}
function F$(n) {
  return new S(3303, !1)
}
function L$(n, t) {
  return new S(3400, !1)
}
function V$(n) {
  return new S(3401, !1)
}
function j$(n) {
  return new S(3402, !1)
}
function B$(n, t) {
  return new S(3505, !1)
}
function Zr(n) {
  switch (n.length) {
    case 0:
      return new Br;
    case 1:
      return n[0];
    default:
      return new nc(n)
  }
}
function lM(n, t, e = new Map, i = new Map) {
  let r = [], o = [], s = -1, a = null;
  if (t.forEach(l => {
        let c = l.get('offset'), d = c == s, m = d && a || new Map;
        l.forEach((p, h) => {
          let _ = h, v = p;
          if (h !== 'offset') switch (_ = n.normalizePropertyName(_, r), v) {
              case oh:
                v = e.get(h);
                break;
              case yi:
                v = i.get(h);
                break;
              default:
                v = n.normalizeStyleValue(h, _, v, r);
                break
            }
          m.set(_, v)
        }),
            d || o.push(m), a = m, s = c
      }),
      r.length)
    throw T$(r);
  return o
}
function iy(n, t, e, i) {
  switch (t) {
    case 'start':
      n.onStart(() => i(e && Fv(e, 'start', n)));
      break;
    case 'done':
      n.onDone(() => i(e && Fv(e, 'done', n)));
      break;
    case 'destroy':
      n.onDestroy(() => i(e && Fv(e, 'destroy', n)));
      break
  }
}
function Fv(n, t, e) {
  let i = e.totalTime, r = !!e.disabled,
      o =
          ry(n.element, n.triggerName, n.fromState, n.toState, t || n.phaseName,
             i ?? n.totalTime, r),
      s = n._data;
  return s != null && (o._data = s), o
}
function ry(n, t, e, i, r = '', o = 0, s) {
  return {
    element: n, triggerName: t, fromState: e, toState: i, phaseName: r,
        totalTime: o, disabled: !!s
  }
}
function pn(n, t, e) {
  let i = n.get(t);
  return i || n.set(t, i = e), i
}
function YI(n) {
  let t = n.indexOf(':'), e = n.substring(1, t), i = n.slice(t + 1);
  return [e, i]
}
var z$ = typeof document > 'u' ? null : document.documentElement;
function oy(n) {
  let t = n.parentNode || n.host || null;
  return t === z$ ? null : t
}
function H$(n) {
  return n.substring(1, 6) == 'ebkit'
}
var Wo = null, ZI = !1;
function U$(n) {
  Wo || (Wo = $$() || {}, ZI = Wo.style ? 'WebkitAppearance' in Wo.style : !1);
  let t = !0;
  return Wo.style && !H$(n) &&
             (t = n in Wo.style,
              !t && ZI &&
                  (t = 'Webkit' + n.charAt(0).toUpperCase() + n.slice(1) in
                       Wo.style)),
         t
}
function $$() {
  return typeof document < 'u' ? document.body : null
}
function cM(n, t) {
  for (; t;) {
    if (t === n) return !0;
    t = oy(t)
  }
  return !1
}
function dM(n, t, e) {
  if (e) return Array.from(n.querySelectorAll(t));
  let i = n.querySelector(t);
  return i ? [i] : []
}
var sy = (() => {
  class n {
    validateStyleProperty(e) {
      return U$(e)
    }
    containsElement(e, i) {
      return cM(e, i)
    }
    getParentElement(e) {
      return oy(e)
    }
    query(e, i, r) {
      return dM(e, i, r)
    }
    computeStyle(e, i, r) {
      return r || ''
    }
    animate(e, i, r, o, s, a = [], l) {
      return new Br(r, o)
    }
    static \u0275fac = function(i) {
      return new (i || n)
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})(),
    Qo = class {
  static NOOP = new sy
}
, Yo = class {};
var W$ = 1e3, uM = '{{', q$ = '}}', mM = 'ng-enter', Hv = 'ng-leave',
    Oh = 'ng-trigger', Vh = '.ng-trigger', KI = 'ng-animating',
    Uv = '.ng-animating';
function rr(n) {
  if (typeof n == 'number') return n;
  let t = n.match(/^(-?[\.\d]+)(m?s)/);
  return !t || t.length < 2 ? 0 : $v(parseFloat(t[1]), t[2])
}
function $v(n, t) {
  switch (t) {
    case 's':
      return n * W$;
    default:
      return n
  }
}
function jh(n, t, e) {
  return n.hasOwnProperty('duration') ? n : G$(n, t, e)
}
function G$(n, t, e) {
  let i = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i,
      r, o = 0, s = '';
  if (typeof n == 'string') {
    let a = n.match(i);
    if (a === null) return t.push(QI(n)), {duration: 0, delay: 0, easing: ''};
    r = $v(parseFloat(a[1]), a[2]);
    let l = a[3];
    l != null && (o = $v(parseFloat(l), a[4]));
    let c = a[5];
    c && (s = c)
  } else
    r = n;
  if (!e) {
    let a = !1, l = t.length;
    r < 0 && (t.push(d$()), a = !0), o < 0 && (t.push(u$()), a = !0),
        a && t.splice(l, 0, QI(n))
  }
  return {
    duration: r, delay: o, easing: s
  }
}
function Q$(n) {
  return n.length ?
      n[0] instanceof Map ? n : n.map(t => new Map(Object.entries(t))) :
      []
}
function Ii(n, t, e) {
  t.forEach((i, r) => {
    let o = ay(r);
    e && !e.has(r) && e.set(r, n.style[o]), n.style[o] = i
  })
}
function Go(n, t) {
  t.forEach((e, i) => {
    let r = ay(i);
    n.style[r] = ''
  })
}
function Dc(n) {
  return Array.isArray(n) ? n.length == 1 ? n[0] : Qk(n) : n
}
function Y$(n, t, e) {
  let i = t.params || {}, r = hM(n);
  r.length && r.forEach(o => {i.hasOwnProperty(o) || e.push(m$(o))})
}
var Wv = new RegExp(`${uM}\\s*(.+?)\\s*${q$}`, 'g');
function hM(n) {
  let t = [];
  if (typeof n == 'string') {
    let e;
    for (; e = Wv.exec(n);) t.push(e[1]);
    Wv.lastIndex = 0
  }
  return t
}
function kc(n, t, e) {
  let i = `${n}`, r = i.replace(Wv, (o, s) => {
    let a = t[s];
    return a == null && (e.push(h$(s)), a = ''), a.toString()
  });
  return r == i ? n : r
}
var Z$ = /-+([a-z0-9])/g;
function ay(n) {
  return n.replace(Z$, (...t) => t[1].toUpperCase())
}
function K$(n, t) {
  return n === 0 || t === 0
}
function X$(n, t, e) {
  if (e.size && t.length) {
    let i = t[0], r = [];
    if (e.forEach((o, s) => {i.has(s) || r.push(s), i.set(s, o)}), r.length)
      for (let o = 1; o < t.length; o++) {
        let s = t[o];
        r.forEach(a => s.set(a, ly(n, a)))
      }
  }
  return t
}
function fn(n, t, e) {
  switch (t.type) {
    case we.Trigger:
      return n.visitTrigger(t, e);
    case we.State:
      return n.visitState(t, e);
    case we.Transition:
      return n.visitTransition(t, e);
    case we.Sequence:
      return n.visitSequence(t, e);
    case we.Group:
      return n.visitGroup(t, e);
    case we.Animate:
      return n.visitAnimate(t, e);
    case we.Keyframes:
      return n.visitKeyframes(t, e);
    case we.Style:
      return n.visitStyle(t, e);
    case we.Reference:
      return n.visitReference(t, e);
    case we.AnimateChild:
      return n.visitAnimateChild(t, e);
    case we.AnimateRef:
      return n.visitAnimateRef(t, e);
    case we.Query:
      return n.visitQuery(t, e);
    case we.Stagger:
      return n.visitStagger(t, e);
    default:
      throw f$(t.type)
  }
}
function ly(n, t) {
  return window.getComputedStyle(n)[t]
}
var J$ = new Set([
  'width',
  'height',
  'minWidth',
  'minHeight',
  'maxWidth',
  'maxHeight',
  'left',
  'top',
  'bottom',
  'right',
  'fontSize',
  'outlineWidth',
  'outlineOffset',
  'paddingTop',
  'paddingLeft',
  'paddingBottom',
  'paddingRight',
  'marginTop',
  'marginLeft',
  'marginBottom',
  'marginRight',
  'borderRadius',
  'borderWidth',
  'borderTopWidth',
  'borderLeftWidth',
  'borderRightWidth',
  'borderBottomWidth',
  'textIndent',
  'perspective'
]),
    Bh = class extends Yo {
  normalizePropertyName(t, e) {
    return ay(t)
  }
  normalizeStyleValue(t, e, i, r) {
    let o = '', s = i.toString().trim();
    if (J$.has(e) && i !== 0 && i !== '0')
      if (typeof i == 'number')
        o = 'px';
      else {
        let a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
        a && a[1].length == 0 && r.push(p$(t, i))
      }
    return s + o
  }
};
var zh = '*';
function e4(n, t) {
  let e = [];
  return typeof n == 'string' ? n.split(/\s*,\s*/).forEach(i => t4(i, e, t)) :
                                e.push(n),
         e
}
function t4(n, t, e) {
  if (n[0] == ':') {
    let l = n4(n, e);
    if (typeof l == 'function') {
      t.push(l);
      return
    }
    n = l
  }
  let i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (i == null || i.length < 4) return e.push(S$(n)), t;
  let r = i[1], o = i[2], s = i[3];
  t.push(XI(r, s));
  let a = r == zh && s == zh;
  o[0] == '<' && !a && t.push(XI(s, r))
}
function n4(n, t) {
  switch (n) {
    case ':enter':
      return 'void => *';
    case ':leave':
      return '* => void';
    case ':increment':
      return (e, i) => parseFloat(i) > parseFloat(e);
    case ':decrement':
      return (e, i) => parseFloat(i) < parseFloat(e);
    default:
      return t.push(I$(n)), '* => *'
  }
}
var Nh = new Set(['true', '1']), Ph = new Set(['false', '0']);
function XI(n, t) {
  let e = Nh.has(n) || Ph.has(n), i = Nh.has(t) || Ph.has(t);
  return (r, o) => {
    let s = n == zh || n == r, a = t == zh || t == o;
    return !s && e && typeof r == 'boolean' && (s = r ? Nh.has(n) : Ph.has(n)),
           !a && i && typeof o == 'boolean' && (a = o ? Nh.has(t) : Ph.has(t)),
           s && a
  }
}
var fM = ':self', i4 = new RegExp(`s*${fM}s*,?`, 'g');
function pM(n, t, e, i) {
  return new qv(n).build(t, e, i)
}
var JI = '', qv = class {
  _driver;
  constructor(t) {
    this._driver = t
  }
  build(t, e, i) {
    let r = new Gv(e);
    return this._resetContextStyleTimingState(r), fn(this, Dc(t), r)
  }
  _resetContextStyleTimingState(t) {
    t.currentQuerySelector = JI, t.collectedStyles = new Map,
    t.collectedStyles.set(JI, new Map), t.currentTime = 0
  }
  visitTrigger(t, e) {
    let i = e.queryCount = 0, r = e.depCount = 0, o = [], s = [];
    return t.name.charAt(0) == '@' && e.errors.push(g$()),
           t.definitions.forEach(a => {
             if (this._resetContextStyleTimingState(e), a.type == we.State) {
               let l = a, c = l.name;
               c.toString().split(/\s*,\s*/).forEach(
                   d => {l.name = d, o.push(this.visitState(l, e))}),
                   l.name = c
             } else if (a.type == we.Transition) {
               let l = this.visitTransition(a, e);
               i += l.queryCount, r += l.depCount, s.push(l)
             } else
               e.errors.push(_$())
           }),
    {
      type: we.Trigger, name: t.name, states: o, transitions: s, queryCount: i,
          depCount: r, options: null
    }
  }
  visitState(t, e) {
    let i = this.visitStyle(t.styles, e),
        r = t.options && t.options.params || null;
    if (i.containsDynamicStyles) {
      let o = new Set, s = r || {};
      i.styles.forEach(
          a => {
              a instanceof Map &&
              a.forEach(
                  l => {
                      hM(l).forEach(c => {s.hasOwnProperty(c) || o.add(c)})})}),
          o.size && e.errors.push(b$(t.name, [...o.values()]))
    }
    return {
      type: we.State, name: t.name, style: i, options: r ? {params: r} : null
    }
  }
  visitTransition(t, e) {
    e.queryCount = 0, e.depCount = 0;
    let i = fn(this, Dc(t.animation), e), r = e4(t.expr, e.errors);
    return {
      type: we.Transition, matchers: r, animation: i, queryCount: e.queryCount,
          depCount: e.depCount, options: qo(t.options)
    }
  }
  visitSequence(t, e) {
    return {
      type: we.Sequence, steps: t.steps.map(i => fn(this, i, e)),
          options: qo(t.options)
    }
  }
  visitGroup(t, e) {
    let i = e.currentTime, r = 0, o = t.steps.map(s => {
      e.currentTime = i;
      let a = fn(this, s, e);
      return r = Math.max(r, e.currentTime), a
    });
    return e.currentTime = r, {
      type: we.Group, steps: o, options: qo(t.options)
    }
  }
  visitAnimate(t, e) {
    let i = a4(t.timings, e.errors);
    e.currentAnimateTimings = i;
    let r, o = t.styles ? t.styles : Ft({});
    if (o.type == we.Keyframes)
      r = this.visitKeyframes(o, e);
    else {
      let s = t.styles, a = !1;
      if (!s) {
        a = !0;
        let c = {};
        i.easing && (c.easing = i.easing), s = Ft(c)
      }
      e.currentTime += i.duration + i.delay;
      let l = this.visitStyle(s, e);
      l.isEmptyStep = a, r = l
    }
    return e.currentAnimateTimings = null, {
      type: we.Animate, timings: i, style: r, options: null
    }
  }
  visitStyle(t, e) {
    let i = this._makeStyleAst(t, e);
    return this._validateStyleAst(i, e), i
  }
  _makeStyleAst(t, e) {
    let i = [], r = Array.isArray(t.styles) ? t.styles : [t.styles];
    for (let a of r)
      typeof a == 'string' ? a === yi ? i.push(a) : e.errors.push(v$(a)) :
                             i.push(new Map(Object.entries(a)));
    let o = !1, s = null;
    return i.forEach(a => {
      if (a instanceof Map &&
          (a.has('easing') && (s = a.get('easing'), a.delete('easing')), !o)) {
        for (let l of a.values())
          if (l.toString().indexOf(uM) >= 0) {
            o = !0;
            break
          }
      }
    }),
    {
      type: we.Style, styles: i, easing: s, offset: t.offset,
          containsDynamicStyles: o, options: null
    }
  }
  _validateStyleAst(t, e) {
    let i = e.currentAnimateTimings, r = e.currentTime, o = e.currentTime;
    i && o > 0 && (o -= i.duration + i.delay),
        t.styles.forEach(
            s => {typeof s != 'string' && s.forEach((a, l) => {
              let c = e.collectedStyles.get(e.currentQuerySelector),
                  d = c.get(l), m = !0;
              d &&
                  (o != r && o >= d.startTime && r <= d.endTime &&
                       (e.errors.push(y$(l, d.startTime, d.endTime, o, r)),
                        m = !1),
                   o = d.startTime),
                  m && c.set(l, {startTime: o, endTime: r}),
                  e.options && Y$(a, e.options, e.errors)
            })})
  }
  visitKeyframes(t, e) {
    let i = {type: we.Keyframes, styles: [], options: null};
    if (!e.currentAnimateTimings) return e.errors.push(w$()), i;
    let r = 1, o = 0, s = [], a = !1, l = !1, c = 0, d = t.steps.map(F => {
      let se = this._makeStyleAst(F, e),
          Ce = se.offset != null ? se.offset : s4(se.styles), Ze = 0;
      return Ce != null && (o++, Ze = se.offset = Ce),
             l = l || Ze < 0 || Ze > 1, a = a || Ze < c, c = Ze, s.push(Ze), se
    });
    l && e.errors.push(x$()), a && e.errors.push(C$());
    let m = t.steps.length, p = 0;
    o > 0 && o < m ? e.errors.push(D$()) : o == 0 && (p = r / (m - 1));
    let h = m - 1, _ = e.currentTime, v = e.currentAnimateTimings,
        k = v.duration;
    return d.forEach((F, se) => {
      let Ce = p > 0 ? se == h ? 1 : p * se : s[se], Ze = Ce * k;
      e.currentTime = _ + v.delay + Ze, v.duration = Ze,
      this._validateStyleAst(F, e), F.offset = Ce, i.styles.push(F)
    }),
           i
  }
  visitReference(t, e) {
    return {
      type: we.Reference, animation: fn(this, Dc(t.animation), e),
          options: qo(t.options)
    }
  }
  visitAnimateChild(t, e) {
    return e.depCount++, {
      type: we.AnimateChild, options: qo(t.options)
    }
  }
  visitAnimateRef(t, e) {
    return {
      type: we.AnimateRef, animation: this.visitReference(t.animation, e),
          options: qo(t.options)
    }
  }
  visitQuery(t, e) {
    let i = e.currentQuerySelector, r = t.options || {};
    e.queryCount++, e.currentQuery = t;
    let [o, s] = r4(t.selector);
    e.currentQuerySelector = i.length ? i + ' ' + o : o,
    pn(e.collectedStyles, e.currentQuerySelector, new Map);
    let a = fn(this, Dc(t.animation), e);
    return e.currentQuery = null, e.currentQuerySelector = i, {
      type: we.Query, selector: o, limit: r.limit || 0, optional: !!r.optional,
          includeSelf: s, animation: a, originalSelector: t.selector,
          options: qo(t.options)
    }
  }
  visitStagger(t, e) {
    e.currentQuery || e.errors.push(E$());
    let i = t.timings === 'full' ? {duration: 0, delay: 0, easing: 'full'} :
                                   jh(t.timings, e.errors, !0);
    return {
      type: we.Stagger, animation: fn(this, Dc(t.animation), e), timings: i,
          options: null
    }
  }
};
function r4(n) {
  let t = !!n.split(/\s*,\s*/).find(e => e == fM);
  return t && (n = n.replace(i4, '')),
         n = n.replace(/@\*/g, Vh)
                 .replace(/@\w+/g, e => Vh + '-' + e.slice(1))
                 .replace(/:animating/g, Uv),
         [n, t]
}
function o4(n) {
  return n ? y({}, n) : null
}
var Gv = class {
  errors;
  queryCount = 0;
  depCount = 0;
  currentTransition = null;
  currentQuery = null;
  currentQuerySelector = null;
  currentAnimateTimings = null;
  currentTime = 0;
  collectedStyles = new Map;
  options = null;
  unsupportedCSSPropertiesFound = new Set;
  constructor(t) {
    this.errors = t
  }
};
function s4(n) {
  if (typeof n == 'string') return null;
  let t = null;
  if (Array.isArray(n))
    n.forEach(e => {
      if (e instanceof Map && e.has('offset')) {
        let i = e;
        t = parseFloat(i.get('offset')), i.delete('offset')
      }
    });
  else if (n instanceof Map && n.has('offset')) {
    let e = n;
    t = parseFloat(e.get('offset')), e.delete('offset')
  }
  return t
}
function a4(n, t) {
  if (n.hasOwnProperty('duration')) return n;
  if (typeof n == 'number') {
    let o = jh(n, t).duration;
    return Lv(o, 0, '')
  }
  let e = n;
  if (e.split(/\s+/).some(o => o.charAt(0) == '{' && o.charAt(1) == '{')) {
    let o = Lv(0, 0, '');
    return o.dynamic = !0, o.strValue = e, o
  }
  let r = jh(e, t);
  return Lv(r.duration, r.delay, r.easing)
}
function qo(n) {
  return n ? (n = y({}, n), n.params && (n.params = o4(n.params))) : n = {}, n
}
function Lv(n, t, e) {
  return {
    duration: n, delay: t, easing: e
  }
}
function cy(n, t, e, i, r, o, s = null, a = !1) {
  return {
    type: 1, element: n, keyframes: t, preStyleProps: e, postStyleProps: i,
        duration: r, delay: o, totalTime: r + o, easing: s, subTimeline: a
  }
}
var Sc = class {
  _map = new Map;
  get(t) {
    return this._map.get(t) || []
  }
  append(t, e) {
    let i = this._map.get(t);
    i || this._map.set(t, i = []), i.push(...e)
  }
  has(t) {
    return this._map.has(t)
  }
  clear() {
    this._map.clear()
  }
}
, l4 = 1, c4 = ':enter', d4 = new RegExp(c4, 'g'), u4 = ':leave',
  m4 = new RegExp(u4, 'g');
function gM(n, t, e, i, r, o = new Map, s = new Map, a, l, c = []) {
  return new Qv().buildKeyframes(n, t, e, i, r, o, s, a, l, c)
}
var Qv = class {
  buildKeyframes(t, e, i, r, o, s, a, l, c, d = []) {
    c = c || new Sc;
    let m = new Yv(t, e, c, r, o, d, []);
    m.options = l;
    let p = l.delay ? rr(l.delay) : 0;
    m.currentTimeline.delayNextStep(p),
        m.currentTimeline.setStyles([s], null, m.errors, l), fn(this, i, m);
    let h = m.timelines.filter(_ => _.containsAnimation());
    if (h.length && a.size) {
      let _;
      for (let v = h.length - 1; v >= 0; v--) {
        let k = h[v];
        if (k.element === e) {
          _ = k;
          break
        }
      }
      _ && !_.allowOnlyTimelineStyles() && _.setStyles([a], null, m.errors, l)
    }
    return h.length ? h.map(_ => _.buildKeyframes()) :
                      [cy(e, [], [], [], 0, p, '', !1)]
  }
  visitTrigger(t, e) {}
  visitState(t, e) {}
  visitTransition(t, e) {}
  visitAnimateChild(t, e) {
    let i = e.subInstructions.get(e.element);
    if (i) {
      let r = e.createSubContext(t.options), o = e.currentTimeline.currentTime,
          s = this._visitSubInstructions(i, r, r.options);
      o != s && e.transformIntoNewTimeline(s)
    }
    e.previousNode = t
  }
  visitAnimateRef(t, e) {
    let i = e.createSubContext(t.options);
    i.transformIntoNewTimeline(),
        this._applyAnimationRefDelays([t.options, t.animation.options], e, i),
        this.visitReference(t.animation, i),
        e.transformIntoNewTimeline(i.currentTimeline.currentTime),
        e.previousNode = t
  }
  _applyAnimationRefDelays(t, e, i) {
    for (let r of t) {
      let o = r?.delay;
      if (o) {
        let s = typeof o == 'number' ? o : rr(kc(o, r?.params ?? {}, e.errors));
        i.delayNextStep(s)
      }
    }
  }
  _visitSubInstructions(t, e, i) {
    let o = e.currentTimeline.currentTime,
        s = i.duration != null ? rr(i.duration) : null,
        a = i.delay != null ? rr(i.delay) : null;
    return s !== 0 && t.forEach(l => {
      let c = e.appendInstructionToTimeline(l, s, a);
      o = Math.max(o, c.duration + c.delay)
    }),
           o
  }
  visitReference(t, e) {
    e.updateOptions(t.options, !0), fn(this, t.animation, e), e.previousNode = t
  }
  visitSequence(t, e) {
    let i = e.subContextCount, r = e, o = t.options;
    if (o && (o.params || o.delay) &&
        (r = e.createSubContext(o), r.transformIntoNewTimeline(),
         o.delay != null)) {
      r.previousNode.type == we.Style &&
          (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = Hh);
      let s = rr(o.delay);
      r.delayNextStep(s)
    }
    t.steps.length &&
        (t.steps.forEach(s => fn(this, s, r)),
         r.currentTimeline.applyStylesToKeyframe(),
         r.subContextCount > i && r.transformIntoNewTimeline()),
        e.previousNode = t
  }
  visitGroup(t, e) {
    let i = [], r = e.currentTimeline.currentTime,
        o = t.options && t.options.delay ? rr(t.options.delay) : 0;
    t.steps.forEach(s => {
      let a = e.createSubContext(t.options);
      o && a.delayNextStep(o), fn(this, s, a),
          r = Math.max(r, a.currentTimeline.currentTime),
          i.push(a.currentTimeline)
    }),
        i.forEach(s => e.currentTimeline.mergeTimelineCollectedStyles(s)),
        e.transformIntoNewTimeline(r), e.previousNode = t
  }
  _visitTiming(t, e) {
    if (t.dynamic) {
      let i = t.strValue, r = e.params ? kc(i, e.params, e.errors) : i;
      return jh(r, e.errors)
    } else
      return {
        duration: t.duration, delay: t.delay, easing: t.easing
      }
  }
  visitAnimate(t, e) {
    let i = e.currentAnimateTimings = this._visitTiming(t.timings, e),
        r = e.currentTimeline;
    i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles());
    let o = t.style;
    o.type == we.Keyframes ? this.visitKeyframes(o, e) :
                             (e.incrementTime(i.duration),
                              this.visitStyle(o, e), r.applyStylesToKeyframe()),
        e.currentAnimateTimings = null, e.previousNode = t
  }
  visitStyle(t, e) {
    let i = e.currentTimeline, r = e.currentAnimateTimings;
    !r && i.hasCurrentStyleProperties() && i.forwardFrame();
    let o = r && r.easing || t.easing;
    t.isEmptyStep ? i.applyEmptyStep(o) :
                    i.setStyles(t.styles, o, e.errors, e.options),
        e.previousNode = t
  }
  visitKeyframes(t, e) {
    let i = e.currentAnimateTimings, r = e.currentTimeline.duration,
        o = i.duration, a = e.createSubContext().currentTimeline;
    a.easing = i.easing, t.styles.forEach(l => {
      let c = l.offset || 0;
      a.forwardTime(c * o),
          a.setStyles(l.styles, l.easing, e.errors, e.options),
          a.applyStylesToKeyframe()
    }),
    e.currentTimeline.mergeTimelineCollectedStyles(a),
    e.transformIntoNewTimeline(r + o), e.previousNode = t
  }
  visitQuery(t, e) {
    let i = e.currentTimeline.currentTime, r = t.options || {},
        o = r.delay ? rr(r.delay) : 0;
    o &&
        (e.previousNode.type === we.Style ||
         i == 0 && e.currentTimeline.hasCurrentStyleProperties()) &&
        (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Hh);
    let s = i,
        a = e.invokeQuery(
            t.selector, t.originalSelector, t.limit, t.includeSelf,
            !!r.optional, e.errors);
    e.currentQueryTotal = a.length;
    let l = null;
    a.forEach((c, d) => {
      e.currentQueryIndex = d;
      let m = e.createSubContext(t.options, c);
      o && m.delayNextStep(o), c === e.element && (l = m.currentTimeline),
          fn(this, t.animation, m), m.currentTimeline.applyStylesToKeyframe();
      let p = m.currentTimeline.currentTime;
      s = Math.max(s, p)
    }),
        e.currentQueryIndex = 0, e.currentQueryTotal = 0,
        e.transformIntoNewTimeline(s),
        l &&
        (e.currentTimeline.mergeTimelineCollectedStyles(l),
         e.currentTimeline.snapshotCurrentStyles()),
        e.previousNode = t
  }
  visitStagger(t, e) {
    let i = e.parentContext, r = e.currentTimeline, o = t.timings,
        s = Math.abs(o.duration), a = s * (e.currentQueryTotal - 1),
        l = s * e.currentQueryIndex;
    switch (o.duration < 0 ? 'reverse' : o.easing) {
      case 'reverse':
        l = a - l;
        break;
      case 'full':
        l = i.currentStaggerTime;
        break
    }
    let d = e.currentTimeline;
    l && d.delayNextStep(l);
    let m = d.currentTime;
    fn(this, t.animation, e), e.previousNode = t,
                              i.currentStaggerTime = r.currentTime - m +
        (r.startTime - i.currentTimeline.startTime)
  }
}
, Hh = {}, Yv = class n {
  _driver;
  element;
  subInstructions;
  _enterClassName;
  _leaveClassName;
  errors;
  timelines;
  parentContext = null;
  currentTimeline;
  currentAnimateTimings = null;
  previousNode = Hh;
  subContextCount = 0;
  options = {};
  currentQueryIndex = 0;
  currentQueryTotal = 0;
  currentStaggerTime = 0;
  constructor(t, e, i, r, o, s, a, l) {
    this._driver = t, this.element = e, this.subInstructions = i,
    this._enterClassName = r, this._leaveClassName = o, this.errors = s,
    this.timelines = a, this.currentTimeline = l || new Uh(this._driver, e, 0),
    a.push(this.currentTimeline)
  }
  get params() {
    return this.options.params
  }
  updateOptions(t, e) {
    if (!t) return;
    let i = t, r = this.options;
    i.duration != null && (r.duration = rr(i.duration)),
        i.delay != null && (r.delay = rr(i.delay));
    let o = i.params;
    if (o) {
      let s = r.params;
      s || (s = this.options.params = {}),
          Object.keys(o).forEach(
              a => {
                  (!e || !s.hasOwnProperty(a)) &&
                  (s[a] = kc(o[a], s, this.errors))})
    }
  }
  _copyOptions() {
    let t = {};
    if (this.options) {
      let e = this.options.params;
      if (e) {
        let i = t.params = {};
        Object.keys(e).forEach(r => {i[r] = e[r]})
      }
    }
    return t
  }
  createSubContext(t = null, e, i) {
    let r = e || this.element,
        o = new n(
            this._driver, r, this.subInstructions, this._enterClassName,
            this._leaveClassName, this.errors, this.timelines,
            this.currentTimeline.fork(r, i || 0));
    return o.previousNode = this.previousNode,
           o.currentAnimateTimings = this.currentAnimateTimings,
           o.options = this._copyOptions(), o.updateOptions(t),
           o.currentQueryIndex = this.currentQueryIndex,
           o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this,
           this.subContextCount++, o
  }
  transformIntoNewTimeline(t) {
    return this.previousNode = Hh,
           this.currentTimeline = this.currentTimeline.fork(this.element, t),
           this.timelines.push(this.currentTimeline), this.currentTimeline
  }
  appendInstructionToTimeline(t, e, i) {
    let r = {
      duration: e ?? t.duration,
      delay: this.currentTimeline.currentTime + (i ?? 0) + t.delay,
      easing: ''
    },
        o = new Zv(
            this._driver, t.element, t.keyframes, t.preStyleProps,
            t.postStyleProps, r, t.stretchStartingKeyframe);
    return this.timelines.push(o), r
  }
  incrementTime(t) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + t)
  }
  delayNextStep(t) {
    t > 0 && this.currentTimeline.delayNextStep(t)
  }
  invokeQuery(t, e, i, r, o, s) {
    let a = [];
    if (r && a.push(this.element), t.length > 0) {
      t = t.replace(d4, '.' + this._enterClassName),
      t = t.replace(m4, '.' + this._leaveClassName);
      let l = i != 1, c = this._driver.query(this.element, t, l);
      i !== 0 && (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)),
          a.push(...c)
    }
    return !o && a.length == 0 && s.push(k$(e)), a
  }
}
, Uh = class n {
  _driver;
  element;
  startTime;
  _elementTimelineStylesLookup;
  duration = 0;
  easing = null;
  _previousKeyframe = new Map;
  _currentKeyframe = new Map;
  _keyframes = new Map;
  _styleSummary = new Map;
  _localTimelineStyles = new Map;
  _globalTimelineStyles;
  _pendingStyles = new Map;
  _backFill = new Map;
  _currentEmptyStepKeyframe = null;
  constructor(t, e, i, r) {
    this._driver = t, this.element = e, this.startTime = i,
    this._elementTimelineStylesLookup = r,
    this._elementTimelineStylesLookup ||
        (this._elementTimelineStylesLookup = new Map),
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e),
    this._globalTimelineStyles ||
        (this._globalTimelineStyles = this._localTimelineStyles,
         this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)),
    this._loadKeyframe()
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return !1;
      case 1:
        return this.hasCurrentStyleProperties();
      default:
        return !0
    }
  }
  hasCurrentStyleProperties() {
    return this._currentKeyframe.size > 0
  }
  get currentTime() {
    return this.startTime + this.duration
  }
  delayNextStep(t) {
    let e = this._keyframes.size === 1 && this._pendingStyles.size;
    this.duration || e ? (this.forwardTime(this.currentTime + t),
                          e && this.snapshotCurrentStyles()) :
                         this.startTime += t
  }
  fork(t, e) {
    return this.applyStylesToKeyframe(),
           new n(
               this._driver, t, e || this.currentTime,
               this._elementTimelineStylesLookup)
  }
  _loadKeyframe() {
    this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe),
        this._currentKeyframe = this._keyframes.get(this.duration),
        this._currentKeyframe ||
        (this._currentKeyframe = new Map,
         this._keyframes.set(this.duration, this._currentKeyframe))
  }
  forwardFrame() {
    this.duration += l4, this._loadKeyframe()
  }
  forwardTime(t) {
    this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe()
  }
  _updateStyle(t, e) {
    this._localTimelineStyles.set(t, e), this._globalTimelineStyles.set(t, e),
        this._styleSummary.set(t, {time: this.currentTime, value: e})
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe
  }
  applyEmptyStep(t) {
    t && this._previousKeyframe.set('easing', t);
    for (let [e, i] of this._globalTimelineStyles)
      this._backFill.set(e, i || yi), this._currentKeyframe.set(e, yi);
    this._currentEmptyStepKeyframe = this._currentKeyframe
  }
  setStyles(t, e, i, r) {
    e && this._previousKeyframe.set('easing', e);
    let o = r && r.params || {}, s = h4(t, this._globalTimelineStyles);
    for (let [a, l] of s) {
      let c = kc(l, o, i);
      this._pendingStyles.set(a, c),
          this._localTimelineStyles.has(a) ||
          this._backFill.set(a, this._globalTimelineStyles.get(a) ?? yi),
          this._updateStyle(a, c)
    }
  }
  applyStylesToKeyframe() {
    this._pendingStyles.size != 0 &&
        (this._pendingStyles.forEach(
             (t, e) => {this._currentKeyframe.set(e, t)}),
         this._pendingStyles.clear(),
         this._localTimelineStyles.forEach(
             (t, e) => {
                 this._currentKeyframe.has(e) ||
                 this._currentKeyframe.set(e, t)}))
  }
  snapshotCurrentStyles() {
    for (let [t, e] of this._localTimelineStyles)
      this._pendingStyles.set(t, e), this._updateStyle(t, e)
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration)
  }
  get properties() {
    let t = [];
    for (let e in this._currentKeyframe) t.push(e);
    return t
  }
  mergeTimelineCollectedStyles(t) {
    t._styleSummary.forEach((e, i) => {
      let r = this._styleSummary.get(i);
      (!r || e.time > r.time) && this._updateStyle(i, e.value)
    })
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    let t = new Set, e = new Set,
        i = this._keyframes.size === 1 && this.duration === 0, r = [];
    this._keyframes.forEach((a, l) => {
      let c = new Map([...this._backFill, ...a]);
      c.forEach((d, m) => {d === oh ? t.add(m) : d === yi && e.add(m)}),
          i || c.set('offset', l / this.duration), r.push(c)
    });
    let o = [...t.values()], s = [...e.values()];
    if (i) {
      let a = r[0], l = new Map(a);
      a.set('offset', 0), l.set('offset', 1), r = [a, l]
    }
    return cy(
        this.element, r, o, s, this.duration, this.startTime, this.easing, !1)
  }
}
, Zv = class extends Uh {
  keyframes;
  preStyleProps;
  postStyleProps;
  _stretchStartingKeyframe;
  timings;
  constructor(t, e, i, r, o, s, a = !1) {
    super(t, e, s.delay), this.keyframes = i, this.preStyleProps = r,
                          this.postStyleProps = o,
                          this._stretchStartingKeyframe = a, this.timings = {
                            duration: s.duration,
                            delay: s.delay,
                            easing: s.easing
                          }
  }
  containsAnimation() {
    return this.keyframes.length > 1
  }
  buildKeyframes() {
    let t = this.keyframes, {delay: e, duration: i, easing: r} = this.timings;
    if (this._stretchStartingKeyframe && e) {
      let o = [], s = i + e, a = e / s, l = new Map(t[0]);
      l.set('offset', 0), o.push(l);
      let c = new Map(t[0]);
      c.set('offset', eM(a)), o.push(c);
      let d = t.length - 1;
      for (let m = 1; m <= d; m++) {
        let p = new Map(t[m]), h = p.get('offset'), _ = e + h * i;
        p.set('offset', eM(_ / s)), o.push(p)
      }
      i = s, e = 0, r = '', t = o
    }
    return cy(
        this.element, t, this.preStyleProps, this.postStyleProps, i, e, r, !0)
  }
};
function eM(n, t = 3) {
  let e = Math.pow(10, t - 1);
  return Math.round(n * e) / e
}
function h4(n, t) {
  let e = new Map, i;
  return n.forEach(r => {
    if (r === '*') {
      i ??= t.keys();
      for (let o of i) e.set(o, yi)
    } else
      for (let [o, s] of r) e.set(o, s)
  }),
         e
}
function tM(n, t, e, i, r, o, s, a, l, c, d, m, p) {
  return {
    type: 0, element: n, triggerName: t, isRemovalTransition: r, fromState: e,
        fromStyles: o, toState: i, toStyles: s, timelines: a,
        queriedElements: l, preStyleProps: c, postStyleProps: d, totalTime: m,
        errors: p
  }
}
var Vv = {}, $h = class {
  _triggerName;
  ast;
  _stateStyles;
  constructor(t, e, i) {
    this._triggerName = t, this.ast = e, this._stateStyles = i
  }
  match(t, e, i, r) {
    return f4(this.ast.matchers, t, e, i, r)
  }
  buildStyles(t, e, i) {
    let r = this._stateStyles.get('*');
    return t !== void 0 && (r = this._stateStyles.get(t?.toString()) || r),
           r ? r.buildStyles(e, i) : new Map
  }
  build(t, e, i, r, o, s, a, l, c, d) {
    let m = [], p = this.ast.options && this.ast.options.params || Vv,
        h = a && a.params || Vv, _ = this.buildStyles(i, h, m),
        v = l && l.params || Vv, k = this.buildStyles(r, v, m), F = new Set,
        se = new Map, Ce = new Map, Ze = r === 'void',
        kn = {params: _M(v, p), delay: this.ast.options?.delay},
        Ut = d ? [] : gM(t, e, this.ast.animation, o, s, _, k, kn, c, m),
        ft = 0;
    return Ut.forEach(ut => {ft = Math.max(ut.duration + ut.delay, ft)}),
           m.length ?
               tM(e, this._triggerName, i, r, Ze, _, k, [], [], se, Ce, ft, m) :
               (Ut.forEach(ut => {
                 let Kr = ut.element, Zo = pn(se, Kr, new Set);
                 ut.preStyleProps.forEach(Xr => Zo.add(Xr));
                 let dy = pn(Ce, Kr, new Set);
                 ut.postStyleProps.forEach(Xr => dy.add(Xr)),
                     Kr !== e && F.add(Kr)
               }),
                tM(e, this._triggerName, i, r, Ze, _, k, Ut, [...F.values()],
                   se, Ce, ft))
  }
};
function f4(n, t, e, i, r) {
  return n.some(o => o(t, e, i, r))
}
function _M(n, t) {
  let e = y({}, t);
  return Object.entries(n).forEach(([i, r]) => {r != null && (e[i] = r)}), e
}
var Kv = class {
  styles;
  defaultParams;
  normalizer;
  constructor(t, e, i) {
    this.styles = t, this.defaultParams = e, this.normalizer = i
  }
  buildStyles(t, e) {
    let i = new Map, r = _M(t, this.defaultParams);
    return this.styles.styles.forEach(
               o => {typeof o != 'string' && o.forEach((s, a) => {
                 s && (s = kc(s, r, e));
                 let l = this.normalizer.normalizePropertyName(a, e);
                 s = this.normalizer.normalizeStyleValue(a, l, s, e),
                 i.set(a, s)
               })}),
           i
  }
};
function p4(n, t, e) {
  return new Xv(n, t, e)
}
var Xv = class {
  name;
  ast;
  _normalizer;
  transitionFactories = [];
  fallbackTransition;
  states = new Map;
  constructor(t, e, i) {
    this.name = t, this.ast = e, this._normalizer = i, e.states.forEach(r => {
      let o = r.options && r.options.params || {};
      this.states.set(r.name, new Kv(r.style, o, i))
    }),
    nM(this.states, 'true', '1'), nM(this.states, 'false', '0'),
    e.transitions.forEach(
        r => {this.transitionFactories.push(new $h(t, r, this.states))}),
    this.fallbackTransition = g4(t, this.states)
  }
  get containsQueries() {
    return this.ast.queryCount > 0
  }
  matchTransition(t, e, i, r) {
    return this.transitionFactories.find(s => s.match(t, e, i, r)) || null
  }
  matchStyles(t, e, i) {
    return this.fallbackTransition.buildStyles(t, e, i)
  }
};
function g4(n, t, e) {
  let i = [(s, a) => !0], r = {type: we.Sequence, steps: [], options: null},
      o = {
        type: we.Transition,
        animation: r,
        matchers: i,
        options: null,
        queryCount: 0,
        depCount: 0
      };
  return new $h(n, o, t)
}
function nM(n, t, e) {
  n.has(t) ? n.has(e) || n.set(e, n.get(t)) : n.has(e) && n.set(t, n.get(e))
}
var _4 = new Sc, Jv = class {
  bodyNode;
  _driver;
  _normalizer;
  _animations = new Map;
  _playersById = new Map;
  players = [];
  constructor(t, e, i) {
    this.bodyNode = t, this._driver = e, this._normalizer = i
  }
  register(t, e) {
    let i = [], r = [], o = pM(this._driver, e, i, r);
    if (i.length) throw R$(i);
    this._animations.set(t, o)
  }
  _buildPlayer(t, e, i) {
    let r = t.element, o = lM(this._normalizer, t.keyframes, e, i);
    return this._driver.animate(r, o, t.duration, t.delay, t.easing, [], !0)
  }
  create(t, e, i = {}) {
    let r = [], o = this._animations.get(t), s, a = new Map;
    if (o ? (s = gM(this._driver, e, o, mM, Hv, new Map, new Map, i, _4, r),
             s.forEach(d => {
               let m = pn(a, d.element, new Map);
               d.postStyleProps.forEach(p => m.set(p, null))
             })) :
            (r.push(A$()), s = []),
        r.length)
      throw O$(r);
    a.forEach(
        (d, m) => {d.forEach(
            (p, h) => {d.set(h, this._driver.computeStyle(m, h, yi))})});
    let l = s.map(d => {
      let m = a.get(d.element);
      return this._buildPlayer(d, new Map, m)
    }),
        c = Zr(l);
    return this._playersById.set(t, c), c.onDestroy(() => this.destroy(t)),
           this.players.push(c), c
  }
  destroy(t) {
    let e = this._getPlayer(t);
    e.destroy(), this._playersById.delete(t);
    let i = this.players.indexOf(e);
    i >= 0 && this.players.splice(i, 1)
  }
  _getPlayer(t) {
    let e = this._playersById.get(t);
    if (!e) throw N$(t);
    return e
  }
  listen(t, e, i, r) {
    let o = ry(e, '', '', '');
    return iy(this._getPlayer(t), i, o, r), () => {}
  }
  command(t, e, i, r) {
    if (i == 'register') {
      this.register(t, r[0]);
      return
    }
    if (i == 'create') {
      let s = r[0] || {};
      this.create(t, e, s);
      return
    }
    let o = this._getPlayer(t);
    switch (i) {
      case 'play':
        o.play();
        break;
      case 'pause':
        o.pause();
        break;
      case 'reset':
        o.reset();
        break;
      case 'restart':
        o.restart();
        break;
      case 'finish':
        o.finish();
        break;
      case 'init':
        o.init();
        break;
      case 'setPosition':
        o.setPosition(parseFloat(r[0]));
        break;
      case 'destroy':
        this.destroy(t);
        break
    }
  }
}
, iM = 'ng-animate-queued', b4 = '.ng-animate-queued',
  jv = 'ng-animate-disabled', v4 = '.ng-animate-disabled',
  y4 = 'ng-star-inserted', w4 = '.ng-star-inserted', x4 = [], bM = {
    namespaceId: '',
    setForRemoval: !1,
    setForMove: !1,
    hasAnimation: !1,
    removedBeforeQueried: !1
  },
  C4 = {
    namespaceId: '',
    setForMove: !1,
    setForRemoval: !1,
    hasAnimation: !1,
    removedBeforeQueried: !0
  },
  Yn = '__ng_removed', Ic = class {
  namespaceId;
  value;
  options;
  get params() {
    return this.options.params
  }
  constructor(t, e = '') {
    this.namespaceId = e;
    let i = t && t.hasOwnProperty('value'), r = i ? t.value : t;
    if (this.value = E4(r), i) {
      let o = t, {value: s} = o, a = Xh(o, ['value']);
      this.options = a
    } else
      this.options = {};
    this.options.params || (this.options.params = {})
  }
  absorbOptions(t) {
    let e = t.params;
    if (e) {
      let i = this.options.params;
      Object.keys(e).forEach(r => {i[r] == null && (i[r] = e[r])})
    }
  }
}
, Ec = 'void', Bv = new Ic(Ec), ey = class {
  id;
  hostElement;
  _engine;
  players = [];
  _triggers = new Map;
  _queue = [];
  _elementListeners = new Map;
  _hostClassName;
  constructor(t, e, i) {
    this.id = t, this.hostElement = e, this._engine = i,
    this._hostClassName = 'ng-tns-' + t, En(e, this._hostClassName)
  }
  listen(t, e, i, r) {
    if (!this._triggers.has(e)) throw P$(i, e);
    if (i == null || i.length == 0) throw F$(e);
    if (!k4(i)) throw L$(i, e);
    let o = pn(this._elementListeners, t, []),
        s = {name: e, phase: i, callback: r};
    o.push(s);
    let a = pn(this._engine.statesByElement, t, new Map);
    return a.has(e) || (En(t, Oh), En(t, Oh + '-' + e), a.set(e, Bv)), () => {
      this._engine.afterFlush(() => {
        let l = o.indexOf(s);
        l >= 0 && o.splice(l, 1), this._triggers.has(e) || a.delete(e)
      })
    }
  }
  register(t, e) {
    return this._triggers.has(t) ? !1 : (this._triggers.set(t, e), !0)
  }
  _getTrigger(t) {
    let e = this._triggers.get(t);
    if (!e) throw V$(t);
    return e
  }
  trigger(t, e, i, r = !0) {
    let o = this._getTrigger(e), s = new Mc(this.id, e, t),
        a = this._engine.statesByElement.get(t);
    a ||
        (En(t, Oh), En(t, Oh + '-' + e),
         this._engine.statesByElement.set(t, a = new Map));
    let l = a.get(e), c = new Ic(i, this.id);
    if (!(i && i.hasOwnProperty('value')) && l && c.absorbOptions(l.options),
        a.set(e, c), l || (l = Bv), !(c.value === Ec) && l.value === c.value) {
      if (!M4(l.params, c.params)) {
        let v = [], k = o.matchStyles(l.value, l.params, v),
            F = o.matchStyles(c.value, c.params, v);
        v.length ? this._engine.reportError(v) :
                   this._engine.afterFlush(() => {Go(t, k), Ii(t, F)})
      }
      return
    }
    let p = pn(this._engine.playersByElement, t, []);
    p.forEach(
        v => {
            v.namespaceId == this.id && v.triggerName == e && v.queued &&
            v.destroy()});
    let h = o.matchTransition(l.value, c.value, t, c.params), _ = !1;
    if (!h) {
      if (!r) return;
      h = o.fallbackTransition, _ = !0
    }
    return this._engine.totalQueuedPlayers++, this._queue.push({
      element: t,
      triggerName: e,
      transition: h,
      fromState: l,
      toState: c,
      player: s,
      isFallbackTransition: _
    }),
           _ || (En(t, iM), s.onStart(() => {ka(t, iM)})), s.onDone(() => {
             let v = this.players.indexOf(s);
             v >= 0 && this.players.splice(v, 1);
             let k = this._engine.playersByElement.get(t);
             if (k) {
               let F = k.indexOf(s);
               F >= 0 && k.splice(F, 1)
             }
           }),
           this.players.push(s), p.push(s), s
  }
  deregister(t) {
    this._triggers.delete(t),
        this._engine.statesByElement.forEach(e => e.delete(t)),
        this._elementListeners.forEach(
            (e,
             i) => {this._elementListeners.set(i, e.filter(r => r.name != t))})
  }
  clearElementCache(t) {
    this._engine.statesByElement.delete(t), this._elementListeners.delete(t);
    let e = this._engine.playersByElement.get(t);
    e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(t))
  }
  _signalRemovalForInnerTriggers(t, e) {
    let i = this._engine.driver.query(t, Vh, !0);
    i.forEach(r => {
      if (r[Yn]) return;
      let o = this._engine.fetchNamespacesByElement(r);
      o.size ? o.forEach(s => s.triggerLeaveAnimation(r, e, !1, !0)) :
               this.clearElementCache(r)
    }),
        this._engine.afterFlushAnimationsDone(
            () => i.forEach(r => this.clearElementCache(r)))
  }
  triggerLeaveAnimation(t, e, i, r) {
    let o = this._engine.statesByElement.get(t), s = new Map;
    if (o) {
      let a = [];
      if (o.forEach((l, c) => {
            if (s.set(c, l.value), this._triggers.has(c)) {
              let d = this.trigger(t, c, Ec, r);
              d && a.push(d)
            }
          }),
          a.length)
        return this._engine.markElementAsRemoved(this.id, t, !0, e, s),
               i && Zr(a).onDone(() => this._engine.processLeaveNode(t)), !0
    }
    return !1
  }
  prepareLeaveAnimationListeners(t) {
    let e = this._elementListeners.get(t),
        i = this._engine.statesByElement.get(t);
    if (e && i) {
      let r = new Set;
      e.forEach(o => {
        let s = o.name;
        if (r.has(s)) return;
        r.add(s);
        let l = this._triggers.get(s).fallbackTransition, c = i.get(s) || Bv,
            d = new Ic(Ec), m = new Mc(this.id, s, t);
        this._engine.totalQueuedPlayers++, this._queue.push({
          element: t,
          triggerName: s,
          transition: l,
          fromState: c,
          toState: d,
          player: m,
          isFallbackTransition: !0
        })
      })
    }
  }
  removeNode(t, e) {
    let i = this._engine;
    if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e),
        this.triggerLeaveAnimation(t, e, !0))
      return;
    let r = !1;
    if (i.totalAnimations) {
      let o = i.players.length ? i.playersByQueriedElement.get(t) : [];
      if (o && o.length)
        r = !0;
      else {
        let s = t;
        for (; s = s.parentNode;)
          if (i.statesByElement.get(s)) {
            r = !0;
            break
          }
      }
    }
    if (this.prepareLeaveAnimationListeners(t), r)
      i.markElementAsRemoved(this.id, t, !1, e);
    else {
      let o = t[Yn];
      (!o || o === bM) &&
          (i.afterFlush(() => this.clearElementCache(t)),
           i.destroyInnerAnimations(t), i._onRemovalComplete(t, e))
    }
  }
  insertNode(t, e) {
    En(t, this._hostClassName)
  }
  drainQueuedTransitions(t) {
    let e = [];
    return this._queue.forEach(i => {
      let r = i.player;
      if (r.destroyed) return;
      let o = i.element, s = this._elementListeners.get(o);
      s && s.forEach(a => {
        if (a.name == i.triggerName) {
          let l = ry(o, i.triggerName, i.fromState.value, i.toState.value);
          l._data = t, iy(i.player, a.phase, l, a.callback)
        }
      }),
          r.markedForDestroy ? this._engine.afterFlush(() => {r.destroy()}) :
                               e.push(i)
    }),
           this._queue = [], e.sort((i, r) => {
             let o = i.transition.ast.depCount, s = r.transition.ast.depCount;
             return o == 0 || s == 0 ? o - s :
                 this._engine.driver.containsElement(i.element, r.element) ? 1 :
                                                                             -1
           })
  }
  destroy(t) {
    this.players.forEach(e => e.destroy()),
        this._signalRemovalForInnerTriggers(this.hostElement, t)
  }
}
, ty = class {
  bodyNode;
  driver;
  _normalizer;
  players = [];
  newHostElements = new Map;
  playersByElement = new Map;
  playersByQueriedElement = new Map;
  statesByElement = new Map;
  disabledNodes = new Set;
  totalAnimations = 0;
  totalQueuedPlayers = 0;
  _namespaceLookup = {};
  _namespaceList = [];
  _flushFns = [];
  _whenQuietFns = [];
  namespacesByHostElement = new Map;
  collectedEnterElements = [];
  collectedLeaveElements = [];
  onRemovalComplete = (t, e) => {};
  _onRemovalComplete(t, e) {
    this.onRemovalComplete(t, e)
  }
  constructor(t, e, i) {
    this.bodyNode = t, this.driver = e, this._normalizer = i
  }
  get queuedPlayers() {
    let t = [];
    return this._namespaceList.forEach(
               e => {e.players.forEach(i => {i.queued && t.push(i)})}),
           t
  }
  createNamespace(t, e) {
    let i = new ey(t, e, this);
    return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ?
               this._balanceNamespaceList(i, e) :
               (this.newHostElements.set(e, i), this.collectEnterElement(e)),
           this._namespaceLookup[t] = i
  }
  _balanceNamespaceList(t, e) {
    let i = this._namespaceList, r = this.namespacesByHostElement;
    if (i.length - 1 >= 0) {
      let s = !1, a = this.driver.getParentElement(e);
      for (; a;) {
        let l = r.get(a);
        if (l) {
          let c = i.indexOf(l);
          i.splice(c + 1, 0, t), s = !0;
          break
        }
        a = this.driver.getParentElement(a)
      }
      s || i.unshift(t)
    } else
      i.push(t);
    return r.set(e, t), t
  }
  register(t, e) {
    let i = this._namespaceLookup[t];
    return i || (i = this.createNamespace(t, e)), i
  }
  registerTrigger(t, e, i) {
    let r = this._namespaceLookup[t];
    r && r.register(e, i) && this.totalAnimations++
  }
  destroy(t, e) {
    t && (this.afterFlush(() => {}), this.afterFlushAnimationsDone(() => {
      let i = this._fetchNamespace(t);
      this.namespacesByHostElement.delete(i.hostElement);
      let r = this._namespaceList.indexOf(i);
      r >= 0 && this._namespaceList.splice(r, 1), i.destroy(e),
          delete this._namespaceLookup[t]
    }))
  }
  _fetchNamespace(t) {
    return this._namespaceLookup[t]
  }
  fetchNamespacesByElement(t) {
    let e = new Set, i = this.statesByElement.get(t);
    if (i) {
      for (let r of i.values())
        if (r.namespaceId) {
          let o = this._fetchNamespace(r.namespaceId);
          o && e.add(o)
        }
    }
    return e
  }
  trigger(t, e, i, r) {
    if (Fh(e)) {
      let o = this._fetchNamespace(t);
      if (o) return o.trigger(e, i, r), !0
    }
    return !1
  }
  insertNode(t, e, i, r) {
    if (!Fh(e)) return;
    let o = e[Yn];
    if (o && o.setForRemoval) {
      o.setForRemoval = !1, o.setForMove = !0;
      let s = this.collectedLeaveElements.indexOf(e);
      s >= 0 && this.collectedLeaveElements.splice(s, 1)
    }
    if (t) {
      let s = this._fetchNamespace(t);
      s && s.insertNode(e, i)
    }
    r && this.collectEnterElement(e)
  }
  collectEnterElement(t) {
    this.collectedEnterElements.push(t)
  }
  markElementAsDisabled(t, e) {
    e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), En(t, jv)) :
        this.disabledNodes.has(t) && (this.disabledNodes.delete(t), ka(t, jv))
  }
  removeNode(t, e, i) {
    if (Fh(e)) {
      let r = t ? this._fetchNamespace(t) : null;
      r ? r.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i);
      let o = this.namespacesByHostElement.get(e);
      o && o.id !== t && o.removeNode(e, i)
    } else
      this._onRemovalComplete(e, i)
  }
  markElementAsRemoved(t, e, i, r, o) {
    this.collectedLeaveElements.push(e), e[Yn] = {
      namespaceId: t,
      setForRemoval: r,
      hasAnimation: i,
      removedBeforeQueried: !1,
      previousTriggersValues: o
    }
  }
  listen(t, e, i, r, o) {
    return Fh(e) ? this._fetchNamespace(t).listen(e, i, r, o) : () => {}
  }
  _buildInstruction(t, e, i, r, o) {
    return t.transition.build(
        this.driver, t.element, t.fromState.value, t.toState.value, i, r,
        t.fromState.options, t.toState.options, e, o)
  }
  destroyInnerAnimations(t) {
    let e = this.driver.query(t, Vh, !0);
    e.forEach(i => this.destroyActiveAnimationsForElement(i)),
        this.playersByQueriedElement.size != 0 &&
        (e = this.driver.query(t, Uv, !0),
         e.forEach(i => this.finishActiveQueriedAnimationOnElement(i)))
  }
  destroyActiveAnimationsForElement(t) {
    let e = this.playersByElement.get(t);
    e && e.forEach(i => {i.queued ? i.markedForDestroy = !0 : i.destroy()})
  }
  finishActiveQueriedAnimationOnElement(t) {
    let e = this.playersByQueriedElement.get(t);
    e && e.forEach(i => i.finish())
  }
  whenRenderingDone() {
    return new Promise(t => {
      if (this.players.length) return Zr(this.players).onDone(() => t());
      t()
    })
  }
  processLeaveNode(t) {
    let e = t[Yn];
    if (e && e.setForRemoval) {
      if (t[Yn] = bM, e.namespaceId) {
        this.destroyInnerAnimations(t);
        let i = this._fetchNamespace(e.namespaceId);
        i && i.clearElementCache(t)
      }
      this._onRemovalComplete(t, e.setForRemoval)
    }
    t.classList?.contains(jv) && this.markElementAsDisabled(t, !1),
        this.driver.query(t, v4, !0).forEach(
            i => {this.markElementAsDisabled(i, !1)})
  }
  flush(t = -1) {
    let e = [];
    if (this.newHostElements.size &&
            (this.newHostElements.forEach(
                 (i, r) => this._balanceNamespaceList(i, r)),
             this.newHostElements.clear()),
        this.totalAnimations && this.collectedEnterElements.length)
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        let r = this.collectedEnterElements[i];
        En(r, y4)
      }
    if (this._namespaceList.length &&
        (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      let i = [];
      try {
        e = this._flushAnimations(i, t)
      } finally {
        for (let r = 0; r < i.length; r++) i[r]()
      }
    } else
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        let r = this.collectedLeaveElements[i];
        this.processLeaveNode(r)
      }
    if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0,
        this.collectedLeaveElements.length = 0,
        this._flushFns.forEach(i => i()), this._flushFns = [],
        this._whenQuietFns.length) {
      let i = this._whenQuietFns;
      this._whenQuietFns = [],
      e.length ? Zr(e).onDone(() => {i.forEach(r => r())}) : i.forEach(r => r())
    }
  }
  reportError(t) {
    throw j$(t)
  }
  _flushAnimations(t, e) {
    let i = new Sc, r = [], o = new Map, s = [], a = new Map, l = new Map,
        c = new Map, d = new Set;
    this.disabledNodes.forEach(X => {
      d.add(X);
      let ne = this.driver.query(X, b4, !0);
      for (let ue = 0; ue < ne.length; ue++) d.add(ne[ue])
    });
    let m = this.bodyNode, p = Array.from(this.statesByElement.keys()),
        h = sM(p, this.collectedEnterElements), _ = new Map, v = 0;
    h.forEach((X, ne) => {
      let ue = mM + v++;
      _.set(ne, ue), X.forEach(Ne => En(Ne, ue))
    });
    let k = [], F = new Set, se = new Set;
    for (let X = 0; X < this.collectedLeaveElements.length; X++) {
      let ne = this.collectedLeaveElements[X], ue = ne[Yn];
      ue && ue.setForRemoval &&
          (k.push(ne), F.add(ne),
           ue.hasAnimation ?
               this.driver.query(ne, w4, !0).forEach(Ne => F.add(Ne)) :
               se.add(ne))
    }
    let Ce = new Map, Ze = sM(p, Array.from(F));
    Ze.forEach((X, ne) => {
      let ue = Hv + v++;
      Ce.set(ne, ue), X.forEach(Ne => En(Ne, ue))
    }),
        t.push(() => {
          h.forEach((X, ne) => {
            let ue = _.get(ne);
            X.forEach(Ne => ka(Ne, ue))
          }),
          Ze.forEach((X, ne) => {
            let ue = Ce.get(ne);
            X.forEach(Ne => ka(Ne, ue))
          }),
          k.forEach(X => {this.processLeaveNode(X)})
        });
    let kn = [], Ut = [];
    for (let X = this._namespaceList.length - 1; X >= 0; X--)
      this._namespaceList[X].drainQueuedTransitions(e).forEach(ue => {
        let Ne = ue.player, xt = ue.element;
        if (kn.push(Ne), this.collectedEnterElements.length) {
          let Mt = xt[Yn];
          if (Mt && Mt.setForMove) {
            if (Mt.previousTriggersValues &&
                Mt.previousTriggersValues.has(ue.triggerName)) {
              let Jr = Mt.previousTriggersValues.get(ue.triggerName),
                  gn = this.statesByElement.get(ue.element);
              if (gn && gn.has(ue.triggerName)) {
                let Rc = gn.get(ue.triggerName);
                Rc.value = Jr, gn.set(ue.triggerName, Rc)
              }
            }
            Ne.destroy();
            return
          }
        }
        let Zn = !m || !this.driver.containsElement(m, xt), on = Ce.get(xt),
            or = _.get(xt), tt = this._buildInstruction(ue, i, or, on, Zn);
        if (tt.errors && tt.errors.length) {
          Ut.push(tt);
          return
        }
        if (Zn) {
          Ne.onStart(() => Go(xt, tt.fromStyles)),
              Ne.onDestroy(() => Ii(xt, tt.toStyles)), r.push(Ne);
          return
        }
        if (ue.isFallbackTransition) {
          Ne.onStart(() => Go(xt, tt.fromStyles)),
              Ne.onDestroy(() => Ii(xt, tt.toStyles)), r.push(Ne);
          return
        }
        let hy = [];
        tt.timelines.forEach(Mt => {
          Mt.stretchStartingKeyframe = !0,
          this.disabledNodes.has(Mt.element) || hy.push(Mt)
        }),
            tt.timelines = hy, i.append(xt, tt.timelines);
        let DM = {instruction: tt, player: Ne, element: xt};
        s.push(DM), tt.queriedElements.forEach(Mt => pn(a, Mt, []).push(Ne)),
            tt.preStyleProps.forEach((Mt, Jr) => {
              if (Mt.size) {
                let gn = l.get(Jr);
                gn || l.set(Jr, gn = new Set),
                    Mt.forEach((Rc, Kh) => gn.add(Kh))
              }
            }),
            tt.postStyleProps.forEach((Mt, Jr) => {
              let gn = c.get(Jr);
              gn || c.set(Jr, gn = new Set), Mt.forEach((Rc, Kh) => gn.add(Kh))
            })
      });
    if (Ut.length) {
      let X = [];
      Ut.forEach(ne => {X.push(B$(ne.triggerName, ne.errors))}),
          kn.forEach(ne => ne.destroy()), this.reportError(X)
    }
    let ft = new Map, ut = new Map;
    s.forEach(X => {
      let ne = X.element;
      i.has(ne) &&
          (ut.set(ne, ne),
           this._beforeAnimationBuild(X.player.namespaceId, X.instruction, ft))
    }),
        r.forEach(X => {
          let ne = X.element;
          this._getPreviousPlayers(ne, !1, X.namespaceId, X.triggerName, null)
              .forEach(Ne => {pn(ft, ne, []).push(Ne), Ne.destroy()})
        });
    let Kr = k.filter(X => aM(X, l, c)), Zo = new Map;
    oM(Zo, this.driver, se, c, yi).forEach(X => {aM(X, l, c) && Kr.push(X)});
    let Xr = new Map;
    h.forEach((X, ne) => {oM(Xr, this.driver, new Set(X), l, oh)}),
        Kr.forEach(X => {
          let ne = Zo.get(X), ue = Xr.get(X);
          Zo.set(X, new Map([...ne?.entries() ?? [], ...ue?.entries() ?? []]))
        });
    let Zh = [], uy = [], my = {};
    s.forEach(X => {
      let {element: ne, player: ue, instruction: Ne} = X;
      if (i.has(ne)) {
        if (d.has(ne)) {
          ue.onDestroy(() => Ii(ne, Ne.toStyles)),
              ue.disabled = !0, ue.overrideTotalTime(Ne.totalTime), r.push(ue);
          return
        }
        let xt = my;
        if (ut.size > 1) {
          let on = ne, or = [];
          for (; on = on.parentNode;) {
            let tt = ut.get(on);
            if (tt) {
              xt = tt;
              break
            }
            or.push(on)
          }
          or.forEach(tt => ut.set(tt, xt))
        }
        let Zn = this._buildAnimation(ue.namespaceId, Ne, ft, o, Xr, Zo);
        if (ue.setRealPlayer(Zn), xt === my)
          Zh.push(ue);
        else {
          let on = this.playersByElement.get(xt);
          on && on.length && (ue.parentPlayer = Zr(on)), r.push(ue)
        }
      } else
        Go(ne, Ne.fromStyles), ue.onDestroy(() => Ii(ne, Ne.toStyles)),
            uy.push(ue), d.has(ne) && r.push(ue)
    }),
        uy.forEach(X => {
          let ne = o.get(X.element);
          if (ne && ne.length) {
            let ue = Zr(ne);
            X.setRealPlayer(ue)
          }
        }),
        r.forEach(
            X => {
                X.parentPlayer ? X.syncPlayerEvents(X.parentPlayer) :
                                 X.destroy()});
    for (let X = 0; X < k.length; X++) {
      let ne = k[X], ue = ne[Yn];
      if (ka(ne, Hv), ue && ue.hasAnimation) continue;
      let Ne = [];
      if (a.size) {
        let Zn = a.get(ne);
        Zn && Zn.length && Ne.push(...Zn);
        let on = this.driver.query(ne, Uv, !0);
        for (let or = 0; or < on.length; or++) {
          let tt = a.get(on[or]);
          tt && tt.length && Ne.push(...tt)
        }
      }
      let xt = Ne.filter(Zn => !Zn.destroyed);
      xt.length ? S4(this, ne, xt) : this.processLeaveNode(ne)
    }
    return k.length = 0, Zh.forEach(X => {
      this.players.push(X),
      X.onDone(() => {
        X.destroy();
        let ne = this.players.indexOf(X);
        this.players.splice(ne, 1)
      }),
      X.play()
    }),
           Zh
  }
  afterFlush(t) {
    this._flushFns.push(t)
  }
  afterFlushAnimationsDone(t) {
    this._whenQuietFns.push(t)
  }
  _getPreviousPlayers(t, e, i, r, o) {
    let s = [];
    if (e) {
      let a = this.playersByQueriedElement.get(t);
      a && (s = a)
    } else {
      let a = this.playersByElement.get(t);
      if (a) {
        let l = !o || o == Ec;
        a.forEach(c => {c.queued || !l && c.triggerName != r || s.push(c)})
      }
    }
    return (i || r) &&
               (s = s.filter(
                    a =>
                        !(i && i != a.namespaceId || r && r != a.triggerName))),
           s
  }
  _beforeAnimationBuild(t, e, i) {
    let r = e.triggerName, o = e.element,
        s = e.isRemovalTransition ? void 0 : t,
        a = e.isRemovalTransition ? void 0 : r;
    for (let l of e.timelines) {
      let c = l.element, d = c !== o, m = pn(i, c, []);
      this._getPreviousPlayers(c, d, s, a, e.toState).forEach(h => {
        let _ = h.getRealPlayer();
        _.beforeDestroy && _.beforeDestroy(), h.destroy(), m.push(h)
      })
    }
    Go(o, e.fromStyles)
  }
  _buildAnimation(t, e, i, r, o, s) {
    let a = e.triggerName, l = e.element, c = [], d = new Set, m = new Set,
        p = e.timelines.map(_ => {
          let v = _.element;
          d.add(v);
          let k = v[Yn];
          if (k && k.removedBeforeQueried) return new Br(_.duration, _.delay);
          let F = v !== l,
              se = I4((i.get(v) || x4).map(ft => ft.getRealPlayer()))
                       .filter(ft => {
                         let ut = ft;
                         return ut.element ? ut.element === v : !1
                       }),
              Ce = o.get(v), Ze = s.get(v),
              kn = lM(this._normalizer, _.keyframes, Ce, Ze),
              Ut = this._buildPlayer(_, kn, se);
          if (_.subTimeline && r && m.add(v), F) {
            let ft = new Mc(t, a, v);
            ft.setRealPlayer(Ut), c.push(ft)
          }
          return Ut
        });
    c.forEach(_ => {
      pn(this.playersByQueriedElement, _.element, []).push(_),
      _.onDone(() => D4(this.playersByQueriedElement, _.element, _))
    }),
        d.forEach(_ => En(_, KI));
    let h = Zr(p);
    return h.onDestroy(() => {d.forEach(_ => ka(_, KI)), Ii(l, e.toStyles)}),
           m.forEach(_ => {pn(r, _, []).push(h)}), h
  }
  _buildPlayer(t, e, i) {
    return e.length > 0 ?
        this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) :
        new Br(t.duration, t.delay)
  }
}
, Mc = class {
  namespaceId;
  triggerName;
  element;
  _player = new Br;
  _containsRealPlayer = !1;
  _queuedCallbacks = new Map;
  destroyed = !1;
  parentPlayer = null;
  markedForDestroy = !1;
  disabled = !1;
  queued = !0;
  totalTime = 0;
  constructor(t, e, i) {
    this.namespaceId = t, this.triggerName = e, this.element = i
  }
  setRealPlayer(t) {
    this._containsRealPlayer ||
        (this._player = t,
         this._queuedCallbacks.forEach(
             (e, i) => {e.forEach(r => iy(t, i, void 0, r))}),
         this._queuedCallbacks.clear(), this._containsRealPlayer = !0,
         this.overrideTotalTime(t.totalTime), this.queued = !1)
  }
  getRealPlayer() {
    return this._player
  }
  overrideTotalTime(t) {
    this.totalTime = t
  }
  syncPlayerEvents(t) {
    let e = this._player;
    e.triggerCallback && t.onStart(() => e.triggerCallback('start')),
        t.onDone(() => this.finish()), t.onDestroy(() => this.destroy())
  }
  _queueEvent(t, e) {
    pn(this._queuedCallbacks, t, []).push(e)
  }
  onDone(t) {
    this.queued && this._queueEvent('done', t), this._player.onDone(t)
  }
  onStart(t) {
    this.queued && this._queueEvent('start', t), this._player.onStart(t)
  }
  onDestroy(t) {
    this.queued && this._queueEvent('destroy', t), this._player.onDestroy(t)
  }
  init() {
    this._player.init()
  }
  hasStarted() {
    return this.queued ? !1 : this._player.hasStarted()
  }
  play() {
    !this.queued && this._player.play()
  }
  pause() {
    !this.queued && this._player.pause()
  }
  restart() {
    !this.queued && this._player.restart()
  }
  finish() {
    this._player.finish()
  }
  destroy() {
    this.destroyed = !0, this._player.destroy()
  }
  reset() {
    !this.queued && this._player.reset()
  }
  setPosition(t) {
    this.queued || this._player.setPosition(t)
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition()
  }
  triggerCallback(t) {
    let e = this._player;
    e.triggerCallback && e.triggerCallback(t)
  }
};
function D4(n, t, e) {
  let i = n.get(t);
  if (i) {
    if (i.length) {
      let r = i.indexOf(e);
      i.splice(r, 1)
    }
    i.length == 0 && n.delete(t)
  }
  return i
}
function E4(n) {
  return n ?? null
}
function Fh(n) {
  return n && n.nodeType === 1
}
function k4(n) {
  return n == 'start' || n == 'done'
}
function rM(n, t) {
  let e = n.style.display;
  return n.style.display = t ?? 'none', e
}
function oM(n, t, e, i, r) {
  let o = [];
  e.forEach(l => o.push(rM(l)));
  let s = [];
  i.forEach((l, c) => {
    let d = new Map;
    l.forEach(m => {
      let p = t.computeStyle(c, m, r);
      d.set(m, p), (!p || p.length == 0) && (c[Yn] = C4, s.push(c))
    }),
        n.set(c, d)
  });
  let a = 0;
  return e.forEach(l => rM(l, o[a++])), s
}
function sM(n, t) {
  let e = new Map;
  if (n.forEach(a => e.set(a, [])), t.length == 0) return e;
  let i = 1, r = new Set(t), o = new Map;
  function s(a) {
    if (!a) return i;
    let l = o.get(a);
    if (l) return l;
    let c = a.parentNode;
    return e.has(c) ? l = c : r.has(c) ? l = i : l = s(c), o.set(a, l), l
  }
  return t.forEach(a => {
    let l = s(a);
    l !== i && e.get(l).push(a)
  }),
         e
}
function En(n, t) {
  n.classList?.add(t)
}
function ka(n, t) {
  n.classList?.remove(t)
}
function S4(n, t, e) {
  Zr(e).onDone(() => n.processLeaveNode(t))
}
function I4(n) {
  let t = [];
  return vM(n, t), t
}
function vM(n, t) {
  for (let e = 0; e < n.length; e++) {
    let i = n[e];
    i instanceof nc ? vM(i.players, t) : t.push(i)
  }
}
function M4(n, t) {
  let e = Object.keys(n), i = Object.keys(t);
  if (e.length != i.length) return !1;
  for (let r = 0; r < e.length; r++) {
    let o = e[r];
    if (!t.hasOwnProperty(o) || n[o] !== t[o]) return !1
  }
  return !0
}
function aM(n, t, e) {
  let i = e.get(n);
  if (!i) return !1;
  let r = t.get(n);
  return r ? i.forEach(o => r.add(o)) : t.set(n, i), e.delete(n), !0
}
var Sa = class {
  _driver;
  _normalizer;
  _transitionEngine;
  _timelineEngine;
  _triggerCache = {};
  onRemovalComplete = (t, e) => {};
  constructor(t, e, i) {
    this._driver = e, this._normalizer = i,
    this._transitionEngine = new ty(t.body, e, i),
    this._timelineEngine = new Jv(t.body, e, i),
    this._transitionEngine.onRemovalComplete = (r, o) =>
        this.onRemovalComplete(r, o)
  }
  registerTrigger(t, e, i, r, o) {
    let s = t + '-' + r, a = this._triggerCache[s];
    if (!a) {
      let l = [], c = [], d = pM(this._driver, o, l, c);
      if (l.length) throw M$(r, l);
      a = p4(r, d, this._normalizer), this._triggerCache[s] = a
    }
    this._transitionEngine.registerTrigger(e, r, a)
  }
  register(t, e) {
    this._transitionEngine.register(t, e)
  }
  destroy(t, e) {
    this._transitionEngine.destroy(t, e)
  }
  onInsert(t, e, i, r) {
    this._transitionEngine.insertNode(t, e, i, r)
  }
  onRemove(t, e, i) {
    this._transitionEngine.removeNode(t, e, i)
  }
  disableAnimations(t, e) {
    this._transitionEngine.markElementAsDisabled(t, e)
  }
  process(t, e, i, r) {
    if (i.charAt(0) == '@') {
      let [o, s] = YI(i), a = r;
      this._timelineEngine.command(o, e, s, a)
    } else
      this._transitionEngine.trigger(t, e, i, r)
  }
  listen(t, e, i, r, o) {
    if (i.charAt(0) == '@') {
      let [s, a] = YI(i);
      return this._timelineEngine.listen(s, e, a, o)
    }
    return this._transitionEngine.listen(t, e, i, r, o)
  }
  flush(t = -1) {
    this._transitionEngine.flush(t)
  }
  get players() {
    return [...this._transitionEngine.players, ...this._timelineEngine.players]
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone()
  }
  afterFlushAnimationsDone(t) {
    this._transitionEngine.afterFlushAnimationsDone(t)
  }
};
function T4(n, t) {
  let e = null, i = null;
  return Array.isArray(t) && t.length ?
             (e = zv(t[0]), t.length > 1 && (i = zv(t[t.length - 1]))) :
             t instanceof Map && (e = zv(t)),
         e || i ? new R4(n, e, i) : null
}
var R4 = (() => {
  class n {
    _element;
    _startStyles;
    _endStyles;
    static initialStylesByElement = new WeakMap;
    _state = 0;
    _initialStyles;
    constructor(e, i, r) {
      this._element = e, this._startStyles = i, this._endStyles = r;
      let o = n.initialStylesByElement.get(e);
      o || n.initialStylesByElement.set(e, o = new Map), this._initialStyles = o
    }
    start() {
      this._state < 1 &&
          (this._startStyles &&
               Ii(this._element, this._startStyles, this._initialStyles),
           this._state = 1)
    }
    finish() {
      this.start(),
          this._state < 2 &&
          (Ii(this._element, this._initialStyles),
           this._endStyles &&
               (Ii(this._element, this._endStyles), this._endStyles = null),
           this._state = 1)
    }
    destroy() {
      this.finish(),
          this._state < 3 &&
          (n.initialStylesByElement.delete(this._element),
           this._startStyles &&
               (Go(this._element, this._startStyles), this._endStyles = null),
           this._endStyles &&
               (Go(this._element, this._endStyles), this._endStyles = null),
           Ii(this._element, this._initialStyles), this._state = 3)
    }
  } return n
})();
function zv(n) {
  let t = null;
  return n.forEach((e, i) => {A4(i) && (t = t || new Map, t.set(i, e))}), t
}
function A4(n) {
  return n === 'display' || n === 'position'
}
var Wh = class {
  element;
  keyframes;
  options;
  _specialStyles;
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _duration;
  _delay;
  _initialized = !1;
  _finished = !1;
  _started = !1;
  _destroyed = !1;
  _finalKeyframe;
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  domPlayer;
  time = 0;
  parentPlayer = null;
  currentSnapshot = new Map;
  constructor(t, e, i, r) {
    this.element = t, this.keyframes = e, this.options = i,
    this._specialStyles = r, this._duration = i.duration,
    this._delay = i.delay || 0, this.time = this._duration + this._delay
  }
  _onFinish() {
    this._finished ||
        (this._finished = !0, this._onDoneFns.forEach(t => t()),
         this._onDoneFns = [])
  }
  init() {
    this._buildPlayer(), this._preparePlayerBeforeStart()
  }
  _buildPlayer() {
    if (this._initialized) return;
    this._initialized = !0;
    let t = this.keyframes;
    this.domPlayer = this._triggerWebAnimation(this.element, t, this.options),
    this._finalKeyframe = t.length ? t[t.length - 1] : new Map;
    let e = () => this._onFinish();
    this.domPlayer.addEventListener('finish', e),
        this.onDestroy(() => {this.domPlayer.removeEventListener('finish', e)})
  }
  _preparePlayerBeforeStart() {
    this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
  }
  _convertKeyframesToObject(t) {
    let e = [];
    return t.forEach(i => {e.push(Object.fromEntries(i))}), e
  }
  _triggerWebAnimation(t, e, i) {
    return t.animate(this._convertKeyframesToObject(e), i)
  }
  onStart(t) {
    this._originalOnStartFns.push(t), this._onStartFns.push(t)
  }
  onDone(t) {
    this._originalOnDoneFns.push(t), this._onDoneFns.push(t)
  }
  onDestroy(t) {
    this._onDestroyFns.push(t)
  }
  play() {
    this._buildPlayer(),
        this.hasStarted() ||
        (this._onStartFns.forEach(t => t()), this._onStartFns = [],
         this._started = !0,
         this._specialStyles && this._specialStyles.start()),
        this.domPlayer.play()
  }
  pause() {
    this.init(), this.domPlayer.pause()
  }
  finish() {
    this.init(), this._specialStyles && this._specialStyles.finish(),
        this._onFinish(), this.domPlayer.finish()
  }
  reset() {
    this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1,
                                 this._started = !1,
                                 this._onStartFns = this._originalOnStartFns,
                                 this._onDoneFns = this._originalOnDoneFns
  }
  _resetDomPlayerState() {
    this.domPlayer && this.domPlayer.cancel()
  }
  restart() {
    this.reset(), this.play()
  }
  hasStarted() {
    return this._started
  }
  destroy() {
    this._destroyed ||
        (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(),
         this._specialStyles && this._specialStyles.destroy(),
         this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
  }
  setPosition(t) {
    this.domPlayer === void 0 && this.init(),
        this.domPlayer.currentTime = t * this.time
  }
  getPosition() {
    return +(this.domPlayer.currentTime ?? 0) / this.time
  }
  get totalTime() {
    return this._delay + this._duration
  }
  beforeDestroy() {
    let t = new Map;
    this.hasStarted() &&
        this._finalKeyframe.forEach(
            (i, r) => {
                r !== 'offset' &&
                t.set(r, this._finished ? i : ly(this.element, r))}),
        this.currentSnapshot = t
  }
  triggerCallback(t) {
    let e = t === 'start' ? this._onStartFns : this._onDoneFns;
    e.forEach(i => i()), e.length = 0
  }
}
, qh = class {
  validateStyleProperty(t) {
    return !0
  }
  validateAnimatableStyleProperty(t) {
    return !0
  }
  containsElement(t, e) {
    return cM(t, e)
  }
  getParentElement(t) {
    return oy(t)
  }
  query(t, e, i) {
    return dM(t, e, i)
  }
  computeStyle(t, e, i) {
    return ly(t, e)
  }
  animate(t, e, i, r, o, s = []) {
    let a = r == 0 ? 'both' : 'forwards', l = {duration: i, delay: r, fill: a};
    o && (l.easing = o);
    let c = new Map, d = s.filter(h => h instanceof Wh);
    K$(i, r) &&
        d.forEach(h => {h.currentSnapshot.forEach((_, v) => c.set(v, _))});
    let m = Q$(e).map(h => new Map(h));
    m = X$(t, m, c);
    let p = T4(t, m);
    return new Wh(t, m, l, p)
  }
};
var Lh = '@', yM = '@.disabled', Gh = class {
  namespaceId;
  delegate;
  engine;
  _onDestroy;
  \u0275type = 0;
  constructor(t, e, i, r) {
    this.namespaceId = t, this.delegate = e, this.engine = i,
    this._onDestroy = r
  }
  get data() {
    return this.delegate.data
  }
  destroyNode(t) {
    this.delegate.destroyNode?.(t)
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate),
        this.engine.afterFlushAnimationsDone(
            () => {queueMicrotask(() => {this.delegate.destroy()})}),
        this._onDestroy?.()
  }
  createElement(t, e) {
    return this.delegate.createElement(t, e)
  }
  createComment(t) {
    return this.delegate.createComment(t)
  }
  createText(t) {
    return this.delegate.createText(t)
  }
  appendChild(t, e) {
    this.delegate.appendChild(t, e),
        this.engine.onInsert(this.namespaceId, e, t, !1)
  }
  insertBefore(t, e, i, r = !0) {
    this.delegate.insertBefore(t, e, i),
        this.engine.onInsert(this.namespaceId, e, t, r)
  }
  removeChild(t, e, i) {
    this.parentNode(e) &&
        this.engine.onRemove(this.namespaceId, e, this.delegate)
  }
  selectRootElement(t, e) {
    return this.delegate.selectRootElement(t, e)
  }
  parentNode(t) {
    return this.delegate.parentNode(t)
  }
  nextSibling(t) {
    return this.delegate.nextSibling(t)
  }
  setAttribute(t, e, i, r) {
    this.delegate.setAttribute(t, e, i, r)
  }
  removeAttribute(t, e, i) {
    this.delegate.removeAttribute(t, e, i)
  }
  addClass(t, e) {
    this.delegate.addClass(t, e)
  }
  removeClass(t, e) {
    this.delegate.removeClass(t, e)
  }
  setStyle(t, e, i, r) {
    this.delegate.setStyle(t, e, i, r)
  }
  removeStyle(t, e, i) {
    this.delegate.removeStyle(t, e, i)
  }
  setProperty(t, e, i) {
    e.charAt(0) == Lh && e == yM ? this.disableAnimations(t, !!i) :
                                   this.delegate.setProperty(t, e, i)
  }
  setValue(t, e) {
    this.delegate.setValue(t, e)
  }
  listen(t, e, i, r) {
    return this.delegate.listen(t, e, i, r)
  }
  disableAnimations(t, e) {
    this.engine.disableAnimations(t, e)
  }
}
, ny = class extends Gh {
  factory;
  constructor(t, e, i, r, o) {
    super(e, i, r, o), this.factory = t, this.namespaceId = e
  }
  setProperty(t, e, i) {
    e.charAt(0) == Lh ?
        e.charAt(1) == '.' && e == yM ?
        (i = i === void 0 ? !0 : !!i, this.disableAnimations(t, i)) :
        this.engine.process(this.namespaceId, t, e.slice(1), i) :
        this.delegate.setProperty(t, e, i)
  }
  listen(t, e, i, r) {
    if (e.charAt(0) == Lh) {
      let o = O4(t), s = e.slice(1), a = '';
      return s.charAt(0) != Lh && ([s, a] = N4(s)),
             this.engine.listen(this.namespaceId, o, s, a, l => {
               let c = l._data || -1;
               this.factory.scheduleListenerCallback(c, i, l)
             })
    }
    return this.delegate.listen(t, e, i, r)
  }
};
function O4(n) {
  switch (n) {
    case 'body':
      return document.body;
    case 'document':
      return document;
    case 'window':
      return window;
    default:
      return n
  }
}
function N4(n) {
  let t = n.indexOf('.'), e = n.substring(0, t), i = n.slice(t + 1);
  return [e, i]
}
var Qh = class {
  delegate;
  engine;
  _zone;
  _currentId = 0;
  _microtaskId = 1;
  _animationCallbacksBuffer = [];
  _rendererCache = new Map;
  _cdRecurDepth = 0;
  constructor(t, e, i) {
    this.delegate = t, this.engine = e, this._zone = i,
    e.onRemovalComplete = (r, o) => {
      o?.removeChild(null, r)
    }
  }
  createRenderer(t, e) {
    let i = '', r = this.delegate.createRenderer(t, e);
    if (!t || !e?.data?.animation) {
      let c = this._rendererCache, d = c.get(r);
      if (!d) {
        let m = () => c.delete(r);
        d = new Gh(i, r, this.engine, m), c.set(r, d)
      }
      return d
    }
    let o = e.id, s = e.id + '-' + this._currentId;
    this._currentId++, this.engine.register(s, t);
    let a = c => {
      Array.isArray(c) ? c.forEach(a) :
                         this.engine.registerTrigger(o, s, t, c.name, c)
    };
    return e.data.animation.forEach(a), new ny(this, s, r, this.engine)
  }
  begin() {
    this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
  }
  _scheduleCountTask() {
    queueMicrotask(() => {this._microtaskId++})
  }
  scheduleListenerCallback(t, e, i) {
    if (t >= 0 && t < this._microtaskId) {
      this._zone.run(() => e(i));
      return
    }
    let r = this._animationCallbacksBuffer;
    r.length == 0 && queueMicrotask(() => {this._zone.run(() => {
                                      r.forEach(o => {
                                        let [s, a] = o;
                                        s(a)
                                      }),
                                      this._animationCallbacksBuffer = []
                                    })}),
        r.push([e, i])
  }
  end() {
    this._cdRecurDepth--,
        this._cdRecurDepth == 0 && this._zone.runOutsideAngular(() => {
          this._scheduleCountTask(),
          this.engine.flush(this._microtaskId)
        }),
        this.delegate.end && this.delegate.end()
  }
  whenRenderingDone() {
    return this.engine.whenRenderingDone()
  }
  componentReplaced(t) {
    this.engine.flush(), this.delegate.componentReplaced?.(t)
  }
};
var F4 = (() => {
  class n extends Sa {
    constructor(e, i, r) {
      super(e, i, r)
    }
    ngOnDestroy() {
      this.flush()
    }
    static \u0275fac = function(i) {
      return new (i || n)(A(ce), A(Qo), A(Yo))
    };
    static \u0275prov = C({token: n, factory: n.\u0275fac})
  } return n
})();
function L4() {
  return new Bh
}
function V4(n, t, e) {
  return new Qh(n, t, e)
}
var xM =
        [
          {provide: Yo, useFactory: L4}, {provide: Sa, useClass: F4},
          {provide: Ot, useFactory: V4, deps: [$u, Sa, U]}
        ],
    j4 =
        [
          {provide: Qo, useClass: sy},
          {provide: Ve, useValue: 'NoopAnimations'}, ...xM
        ],
    wM =
        [
          {provide: Qo, useFactory: () => new qh},
          {provide: Ve, useFactory: () => 'BrowserAnimations'}, ...xM
        ],
    CM = (() => {
      class n {
        static withConfig(e) {
          return {
            ngModule: n, providers: e.disableAnimations ? j4 : wM
          }
        }
        static \u0275fac = function(i) {
          return new (i || n)
        };
        static \u0275mod = j({type: n});
        static \u0275inj = V({providers: wM, imports: [qu]})
      } return n
    })();
var Yh = class n {
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275mod = j({type: n});
  static \u0275inj = V({
    imports: [
      Er, am, NS, BS, tr, hh, Lr, fS,           Lr, wS,
      zS, WS, JS, dh, DI, HI, qI, yI.forRoot(), wI, fE
    ]
  })
};
var Tc = class n {
  static \u0275fac = function(e) {
    return new (e || n)
  };
  static \u0275mod = j({type: n, bootstrap: [Ea]});
  static \u0275inj = V({
    providers: [Wn, Hr, Di, _a, ba, Ur, Si, ga, Da],
    imports: [Yh, qu, am, AD, Ah, hh, tr, Lr, CM, Lr]
  })
};
fetch('/assets/config/runtime-config.json').then(n => n.json()).then(n => {
  window.runtimeConfig = n,
  c_().bootstrapModule(Tc).catch(t => console.error(t))
});
c_().bootstrapModule(Tc).catch(n => console.error(n));
